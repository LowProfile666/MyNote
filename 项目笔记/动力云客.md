技术栈：

+ 前端：Html、CSS、JavaScript、Vue、Axios、Element Plus
+ 后端：Spring Boot、Spring Security、MyBatis、MySQL、Redis
+ 相关组件：HiKariCP（Spring Boot默认数据库连接池）、Spring-Data-Redis（Spring整合Redis）、Lombok（代码生成工具）、jwt（Json web token）、EasyExcel（Excel处理类库）、ECharts（前端图表库）
+ 服务器：MySQL、Redis、Linux
+ 项目依赖管理：Maven
+ 项目开发工具：IDEA、Apifox

# 1、环境

node.js（js的运行时环境，相当于Java的jdk）、npm（js的依赖包管理工具，相当于Java的maven）、vite（构建Vue项目的脚手架）

安装node.js，配置npm仓库源，安装vite。

# 2、准备数据库

连接数据库，将初始化的表导入数据库中。

# 3、创建前端项目

使用vite创建出前端vue项目，然后要下载依赖，才能启动

```
// 创建项目
npm create vite@latest
// 进入项目目录后，安装依赖
npm install
// 启动
npm run dev
```

创建好的工程目录结构：

1、node_modules/ 项目依赖的各种js依赖包；

2、public/ 公共的静态文件，一个网站图标；

3、src/ 源代码，我们前端写的源代码都会在这个文件夹下；

4、gitignore 提交git时忽略哪些文件；

5、index.html 项目的首页，访问入口文件；

6、package.json 整个项目对js依赖库的配置，还包括了启动、构建项目命令等；（类似maven的pom.xml）

7、package-lock.json 锁定各个js依赖包的来源和版本；

8、README.md 项目的使用帮助文档；

9、vite.config.js  vite的配置文件；

# 4、创建后端项目

创建后端的SpringBoot项目，需要依赖：

+ Spring Boot DevTools：是一个用于增强 Spring Boot 开发体验的工具集。
  + **自动重启**：当你修改了代码后，DevTools 会自动重新启动应用程序，而不用手动停止和重新启动。这使得开发过程更为流畅，特别是在频繁修改代码时。
  + **热替换**：结合 IDE 的集成，可以实现热替换（Hot Swap），在某些情况下可以在不重启应用的情况下应用代码更改。这对于前端开发或小的后端修改非常有用。
  + **自动清除缓存**：在开发过程中，DevTools 会自动清除某些缓存（如模板引擎缓存），确保你看到的是代码最新的效果。
  + **开发配置**：DevTools 提供了一些开发环境的配置选项，比如开启某些调试功能或者简化日志配置等，使得开发过程更加方便。
  + **自定义配置**：DevTools 允许你为开发环境提供自定义配置，而不影响生产环境的设置。
  + **快速访问控制台**：在应用程序运行时，可以通过访问特定的 URL （如 `/restart`）手动触发应用程序的重启

+ Lombok
+ Spring Configuration Processor：为 Spring Boot 应用程序中的配置属性提供自动补全、类型检查和文档生成等功能。
+ Spring Web
+ Spring Security
+ Mybatis Framework
+ MySQL Driver
+ Spring Data Redis

然后在IDEA中连接上数据库，下载Free MyBatis Tools插件，选中数据库中的所有表，右键，使用逆向工程生成mapper、model等文件。

![image-20240824174019717](https://gitee.com/LowProfile666/image-bed/raw/master/img/202408241740826.png)

![image-20240824174055050](https://gitee.com/LowProfile666/image-bed/raw/master/img/202408241740134.png)

## 4.1、项目分层

![image-20240820194322845](https://gitee.com/LowProfile666/image-bed/raw/master/img/202408201946474.png)

+ web
+ service
+ manager
+ mapper

## 4.2、领域对象

【参考】分层领域模型规约：

• DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。

• DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。

• BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。

• Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。

• VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。

我们只使用其中的三个，如果都使用的话，反而把代码弄得复杂繁琐一些了；

1、DO（等价于我们的model）

2、Query （controller --> service -->manager --> dao 上一层往下一层传参数）

3、VO（等价于我们的result中的R对象）

再建三个包：

+ model
+ query
+ result：封装web层向前端页面返回的结果

# 5、登录模块

## 5.1、安装ElementPlus

安装Element-plus的依赖：

```
npm install element-plus --save
```

+ -g 全局安装
+ --save表示安装包信息会写入package.json的dependencies中，在dependencies中，那么项目打包就会依赖到该模块，如果项目打包时不需要依赖该模块，那么就使用--save-dev，它会在devDependencies下，表示项目开发需要依赖该模块，项目打包发布就不需要它；

安装好后，要使用，在main.js中，导入ElementPlus的依赖：

```js
import ElementPlus from 'element-plus'
```

导入样式：

```js
import 'element-plus/dist/index.css'
```

使用依赖，通过 `use` 方法将 Element Plus 作为插件注册到应用中，可以在项目的任何地方使用 Element Plus 提供的 UI 组件，而无需在每个单独的组件中手动导入和注册这些组件。：

```js
app.use(ElementPlus)
```

elmentPlus默认的语言环境是英文，提示都是英文。可以进行全局设置，将其配置为中文：

```js
import ElementPlus from 'element-plus'
import zhCn from 'element-plus/es/locale/lang/zh-cn'

app.use(ElementPlus, {
  locale: zhCn,
})
```



## 5.2、登录组件

LoginView.vue：组合式API：

```vue
<template>
    <el-container>
        <el-aside>
            <img src="../assets/loginBox.svg" alt="" />
            <p>欢迎登录动力云客系统</p>
        </el-aside>
        <el-main>
            <el-form :model="user" label-width="auto" :rules="rules" ref="loginForm">
                <p>欢迎登录</p>
                <el-form-item label="账号" prop="username">
                    <el-input v-model="user.username" />
                </el-form-item>
                <el-form-item label="密码" prop="password">
                    <el-input v-model="user.password" />
                </el-form-item>
                <el-form-item>
                    <el-button type="primary" @click="login">登录</el-button>
                </el-form-item>
                <el-checkbox v-model="user.remember"> 记住我 </el-checkbox>
            </el-form>
        </el-main>
    </el-container>
</template>

<script>
import { reactive, ref } from "vue";

export default {
    name: "LoginView",
    setup() {
        const rules = {
            username: [{ required: true, message: "请输入账号", trigger: "blur" }],
            password: [
                { required: true, message: "请输入密码", trigger: "blur" },
                { min: 6, max: 10, message: "密码在6到10位之间" },
            ],
        };
        let loginForm = ref();
        function login() {
            loginForm.value.validate((res) => console.log(res));
        }
        let user = reactive({});

        return {
            user,
            rules,
            login,
            loginForm,
        };
    },
};
</script>

<style scoped>
.el-aside {
    width: 40%;
    background-color: #1a1a1a;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: center;
}
.el-aside img {
    height: 50%;
}
.el-aside p {
    color: white;
    font-size: 20px;
}
.el-main {
    height: calc(100vh);
    display: flex;
    flex-direction: column;
    justify-content: center;
}
.el-main p {
    text-align: center;
    margin-bottom: 10px;
}
.el-form {
    width: 60%;
    margin: auto;
}
.el-button {
    width: 100%;
}
</style>
```

选项式API：

```js
export default {
    name: "LoginView",
    methods: {
        login() {
            this.$refs.loginForm.validate((res) => console.log(res));
        },
    },
    data() {
        return {
            user: {
                username: "",
                password: "",
            },
            rules: {
                username: [{ required: true, message: "请输入账号", trigger: "blur" }],
                password: [
                    { required: true, message: "请输入密码", trigger: "blur" },
                    { min: 6, max: 10, message: "密码在6到10位之间" },
                ],
            },
        };
    },
};
```

ElementPlus提供的标签，被渲染后其实就是元素的类名，所以可以直接用来定义类样式。

它的表单中，有一些ElementPlus中独特的属性：

+ `model`：表示表单数据对象，
+ `rules`：表示表单验证规则
+ `prop`：`model` 的键名。 它可以是一个属性的值(如 `a.b.0` 或 `['a', 'b', '0']`)。 在使用了 `validate`、`resetFields` 的方法时，该属性是必填的。

prop属性必须使用在<el-form-item>标签上，否则没用。

定义的规则对象rules，中的属性名必须和prop属性的值一致，才能绑定规则。

在使用组合式API时，不能使用this.$refs来获取使用ref标记的元素。需要使用ref函数自定义一个对象，对象名和在模板中使用的ref标记名一样才能关联。

validate函数是表单对象的函数，用来校验表单中所有的字段，需要传递一个回调函数，只有一个参数，就是表单校验的结果，校验通过为true，否则为false。

## 5.3、安装axios

安装：

```
npm install axios
```

在一个js文件中封装四个方法，将四种请求的结果返回回去：

```js
import axios from "axios";

export function doGet(url, params) {
    return axios({
        method: "get",
        url: url,
        params: params,
        dataType: "json",
    })
}

export function doPost(url, data) {
    return axios({
        method: "post",
        url: url,
        data: data,
        dataType: "json",
    })
}

export function doDelete(url, params) {
    return axios({
        method: "delete",
        url: url,
        params: params,
        dataType: "json",
    })
}

export function doPut(url, data) {
    return axios({
        method: "put",
        url: url,
        data: data,
        dataType: "json",
    })
}
```

axios中，get和delete方法的参数名为params，put和post的参数名为data。

## 5.4、登录请求

```js
function login() {
    loginForm.value.validate((res) => {
        if (res) {
            let formData = new FormData();
            formData.append("username", user.username);
            formData.append("password", user.password);
            doPost("/api/login", formData).then((resp) => {
                console.log(resp)
            })
        }
    });
}
```

FormData是一个js类，提供了一种简单且强大的方式来处理表单数据，特别是文件上传和复杂表单数据，相当于一个Java中的map集合，使用append方法来设置数据。

## 5.5、登录接口

登录使用SpringSecurity的接口，先新建一个UserService接口，需要从数据库中查询用户，这个接口需要继承UserDetailsService接口（SpringSecurity中的接口），该接口中有一个从数据库中查询用户的方法需要实现：

```java
public interface UserService extends UserDetailsService {
}
```

然后写它的实现类UserServiceImpl，实现从数据库查询的方法：

```java
@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private TUserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        TUser user = userMapper.selectByUsername(username);

        if (user == null) {
            throw new UsernameNotFoundException("用户不存在");
        }

        return user;
    }
}
```

+ 还要实现mapper接口和mapper.xml文件中的sql

同时，要将TUser类变成UserDetails类，就要实现UserDetails接口，也要多加两个属性，用来表示角色列表和权限列表：

```java
@Data
public class TUser implements UserDetails, Serializable {
    //。。。
    private List<String> roles;
    private List<String> permissions;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        List<GrantedAuthority> authorities = new ArrayList<GrantedAuthority>();

        // 角色
        if (this.getRoles() != null) {
            this.getRoles().forEach(role -> authorities.add(new SimpleGrantedAuthority(role)));
        }

        // 权限
        if (this.getPermissions() != null) {
            this.getPermissions().forEach(permission -> authorities.add(new SimpleGrantedAuthority(permission)));
        }

        return authorities;
    }

    @JsonIgnore
    @Override
    public String getPassword() {
        return this.getPassword();
    }

    @JsonIgnore
    @Override
    public String getUsername() {
        return this.getUsername();
    }

    @JsonIgnore
    @Override
    public boolean isAccountNonExpired() {
        return this.getAccountNoExpired() == 1;
    }

    @JsonIgnore
    @Override
    public boolean isAccountNonLocked() {
        return this.getAccountNoLocked() == 1;
    }

    @JsonIgnore
    @Override
    public boolean isCredentialsNonExpired() {
        return this.getCredentialsNoExpired() == 1;
    }

    @JsonIgnore
    @Override
    public boolean isEnabled() {
        return this.getAccountEnabled() == 1;
    }
}
```

创建SpringSecurity配置类：

```java
@Configuration
public class SpringSecurityConfig {
    @Autowired
    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;
    @Autowired
    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;

    @Bean
    public PasswordEncoder bCryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, CorsConfigurationSource corsConfigurationSource) throws Exception {
        return http.formLogin((formlogin) -> {  // 处理表单登录
                    formlogin.loginProcessingUrl("/api/login")  // 处理登录的地址
                            .usernameParameter("loginAct")  // 设置登录时的参数名
                            .passwordParameter("loginPwd")  // 设置登录时的密码名
                            .successHandler(myAuthenticationSuccessHandler)  // 登录成功处理器
                            .failureHandler(myAuthenticationFailureHandler);  // 登录失败处理器
                })
                .authorizeRequests((authorize) -> {
                    authorize.requestMatchers("/api/login").permitAll()  // 放开登录请求地址
                            .anyRequest().authenticated();  // 拦截所有请求
                })

                .csrf((csrf) -> {csrf.disable();})  // 禁用crsf跨站伪造请求
                .build();
    }
}
```

## 5.6、解决跨域

第一种方法：使用vue的内置代理服务器，在vite.config.js中配置：

```js
export default defineConfig({
    plugins: [vue()],
    server: {
        proxy: {
            "/api": {
                target: "http://localhost:8080/",
            },
        },
    },
});
```

第二种方法：在后端配置SpringSecurity，创建一个解决跨域问题的对象

```java
@Configuration
public class SpringSecurityConfig {
    @Autowired
    private MyAuthenticationSuccessHandler myAuthenticationSuccessHandler;
    @Autowired
    private MyAuthenticationFailureHandler myAuthenticationFailureHandler;

    @Bean
    public PasswordEncoder bCryptPasswordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http, CorsConfigurationSource corsConfigurationSource) throws Exception {
        return http.formLogin((formlogin) -> {  // 处理表单登录
                    formlogin.loginProcessingUrl("/api/login")  // 处理登录的地址
                            .usernameParameter("loginAct")  // 设置登录时的参数名
                            .passwordParameter("loginPwd")  // 设置登录时的密码名
                            .successHandler(myAuthenticationSuccessHandler)  // 登录成功处理器
                            .failureHandler(myAuthenticationFailureHandler);  // 登录失败处理器
                })
                .authorizeRequests((authorize) -> {
                    authorize.requestMatchers("/api/login").permitAll()  // 放开登录请求地址
                            .anyRequest().authenticated();  // 拦截所有请求
                })

                .csrf((csrf) -> {csrf.disable();})  // 禁用crsf跨站伪造请求

                .cors((cors) -> {  // 配置跨域请求
                    cors.configurationSource(corsConfigurationSource);
                })
                .build();
    }

    // 跨域配置需要的bean，使用方法注入到上面的方法中
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration corsConfiguration = new CorsConfiguration();
        // 允许所有来源
        corsConfiguration.setAllowedOrigins(Arrays.asList("*"));
        // 允许所有方法
        corsConfiguration.setAllowedMethods(Arrays.asList("*"));
        // 允许所有请求头
        corsConfiguration.setAllowedHeaders(Arrays.asList("*"));

        UrlBasedCorsConfigurationSource resource = new UrlBasedCorsConfigurationSource();
        resource.registerCorsConfiguration("/**", corsConfiguration);
        return resource;
    }
}
```

## 5.7、消息提示

使用ElementPlus的反馈组件中的消息提示组件，封装成一个工具类util/index.js，用来显示提示消息：

```js
import {ElMessage} from "element-plus";

export function messageTip(msg, type) {
    ElMessage({
        showClose: true,  //  可关闭
        message: msg,  // 提示内容
        type: type,  // 提示类型
        center: true,  // 文字居中
    })
}
```

定义一个消息提示类型的常量constant/index.js：

```js
export const MESSAGE_TIP_TYPE = {
    SUCCESS: 'success',
    ERROR: 'error',
    WARNING: 'warning',
    INFO: 'info',
}
```

登录后，根据登录结果弹窗提示：

```js
doPost("/api/login", formData).then((resp) => {
    if (resp.data.code === 200) {
        messageTip("登录成功", MESSAGE_TIP_TYPE.SUCCESS);
    } else {
        messageTip("登录失败", MESSAGE_TIP_TYPE.ERROR);
    }
})
```

## 5.8、引入路由

安装：

```
npm i vue-router
```

创建router/index.js：

```js
import {createRouter, createWebHistory} from "vue-router";
import LoginView from "../ views/LoginView.vue";
import DashBoard from "../ views/DashBoard.vue";

const routes = [
    {
        path: '/login',
        name: 'login',
        component: LoginView
    },
    {
        path: '/dashboard',
        name: 'dashboard',
        component: DashBoard,
    }
];

export default createRouter({
    routes: routes,
    history: createWebHistory()
});
```

使用createRouter创建路由器对象时，必须提供history属性。使用createWebHashHistory()可以创建hash模式的路由记录。

在main.js中使用路由器对象：

```js
import router from './router/index.js'

createApp(App).use(ElementPlus).use(router).mount('#app')
```

在App.vue中使用显示路由：

```vue
<template>
    <router-view></router-view>
</template>
```

## 5.9、驾驶舱

dashboard页面就是驾驶舱，就是一个数据概览页面。

### 5.9.1、布局

使用elementsplus的布局容器。

### 5.9.2、左侧菜单

使用elementplus的menu组件。

使用elementplus的图标库，先安装：

```
npm install @element-plus/icons-vue
```

然后在main.js中引入：

```js
import * as ElementPlusIconsVue from '@element-plus/icons-vue'

const app = createApp(App)
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
    app.component(key, component)
}

app.use(ElementPlus).use(router).mount('#app')
```

左侧菜单：

```vue
<template>
    <el-container>
        <el-aside :width="asideWidth">
            <div class="menu-title">@动力云客管理系统</div>
            <el-menu
                active-text-color="#ffd04b"
                background-color="#a9a9a9"
                class="el-menu-vertical-demo"
                default-active="2"
                text-color="#fff"
                unique-opened="true"
                style="border: 0"
                :collapse="isCollapse"
                :collapse-transition="false"
            >
                <el-sub-menu index="1">
                    <template #title>
                        <el-icon><UserFilled /></el-icon>
                        <span>用户管理</span>
                    </template>
                    <el-menu-item index="1-1">
                        <el-icon><User /></el-icon>
                        用户列表
                    </el-menu-item>
                </el-sub-menu>
                <el-sub-menu index="2">
                    <template #title>
                        <el-icon><Grid /></el-icon>
                        <span>市场活动</span>
                    </template>
                    <el-menu-item index="2-1">
                        <el-icon><HelpFilled /></el-icon>
                        市场活动
                    </el-menu-item>
                </el-sub-menu>
                <el-sub-menu index="3">
                    <template #title>
                        <el-icon><location /></el-icon>
                        <span>线索管理</span>
                    </template>
                    <el-menu-item index="3-1">
                        <el-icon><Promotion /></el-icon>
                        线索管理
                    </el-menu-item>
                </el-sub-menu>

            </el-menu>
        </el-aside>
        <el-container class="right-container">
            <el-header>
                <el-icon class="icon-collapse" @click="showMenu"><Fold /></el-icon>
            </el-header>
            <el-main>Main</el-main>
            <el-footer>@ZSM </el-footer>
        </el-container>
    </el-container>
</template>

<script>
import {ref} from "vue";

export default {
    name: "DashBoard",
    setup() {
        let isCollapse = ref(false);
        let asideWidth = ref("200px");

        const showMenu = () => {
            isCollapse.value = !isCollapse.value;
            if (isCollapse.value) asideWidth.value = "64px";
            else asideWidth.value = "200px";
        }

        return {
            isCollapse,
            showMenu,
            asideWidth
        }
    }
}
</script>


<style scoped>
.el-aside {
    background-color: black;
}
.el-header, .el-footer {
    background-color: azure;
    height: 35px;
}
.el-footer {
    text-align: center;
    line-height: 35px;
}
.right-container {
    height: calc(100vh);
}
.menu-title {
    height: 35px;
    color: white;
    line-height: 35px;
    text-align: center;
    font-weight: bold;
}
.el-header {
    line-height: 35px;
}
.icon-collapse {
    cursor: pointer;
}
</style>
```

细节：

使用属性：

### 5.9.3、获取登录信息

用于驾驶舱页面显示登录者的名字。使用jwt。

登录成功后应该是返回一个jwt。

RedisServiceImpl：

```java
@Service
public class RedisServiceImpl implements RedisService {
    @Autowired
    private RedisTemplate<Object, Object> redisTemplate;

    @Override
    public void setValue(String key, Object value) {
        redisTemplate.opsForValue().set(key, value);
    }

    @Override
    public Object getValue(String key) {
        return redisTemplate.opsForValue().get(key);
    }

    @Override
    public Boolean delete(String key) {
        return redisTemplate.delete(key);
    }

    @Override
    public Boolean expire(String key, long timeout, TimeUnit unit) {
        return redisTemplate.expire(key, timeout, unit);
    }
}
```

### 5.9.4、axios拦截器

让请求头中带token，使用拦截器，给每个axios请求都加上请求头。

拦截器模板，来自官网：

```js
// Add a request interceptor
axios.interceptors.request.use(function (config) {
    // Do something before request is sent
    return config;
  }, function (error) {
    // Do something with request error
    return Promise.reject(error);
  });

// Add a response interceptor
axios.interceptors.response.use(function (response) {
    // Any status code that lie within the range of 2xx cause this function to trigger
    // Do something with response data
    return response;
  }, function (error) {
    // Any status codes that falls outside the range of 2xx cause this function to trigger
    // Do something with response error
    return Promise.reject(error);
  });
```

使用响应拦截器，拦截后端返回的验证token的结果，进行提示和页面跳转。

### 5.9.5、验证token

使用一个过滤器验证token，要将这个过滤器加入到SpringSecurity的过滤器链中。自定义filter如果使用了@Component注解，那么 Spring 容器自动将其添加到过滤器链中。虽然这简化了配置，但如果你希望控制过滤器的顺序或插入位置，手动配置过滤器链是更为精确的方法。

并返回验证token后的信息，前端做出对应提示。

### 5.9.6、禁用session



## 5.10、免登录

根据上一次登录时是否选择“记住我”来判断是否免登录。免登录就在登录页面渲染时，拿着本地的token，去后端验证，如果该token有效，就直接跳过登录，否则重新登录。

## 5.11、退出登录

退出登录的代码在SpringSecurity中配置。

## 5.12、token刷新

记住我后，每次请求都刷新7天的事件；没有记住我，每次请求都刷新30分钟。

在验证token的filter中刷新即可。最好使用异步处理。使用线程池。Spring自带的线程池ThreadPoolTaskExecutor。

```java
// 刷新token，异步处理
//        new Thread(() -> {
//            if (rememberMe) {
//                redisService.expire(Constants.REDIS_JWT_KEY + userId, Constants.EXPIRE_TIME, TimeUnit.SECONDS);
//            } else {
//                redisService.expire(Constants.REDIS_JWT_KEY + userId, Constants.DEFAULT_EXPIRE_TIME, TimeUnit.SECONDS);
//            }
//        }).start();

// 使用线程池，这是Spring自带的线程池
threadPoolTaskExecutor.execute(() -> {
    if (rememberMe) {
        redisService.expire(Constants.REDIS_JWT_KEY + userId, Constants.EXPIRE_TIME, TimeUnit.SECONDS);
    } else {
        redisService.expire(Constants.REDIS_JWT_KEY + userId, Constants.DEFAULT_EXPIRE_TIME, TimeUnit.SECONDS);
    }
});
```



# 6、用户管理

## 6.1、菜单路由

elementplus的菜单组件有一个router属性，可以将菜单项变成一个路由链接。

## 6.2、子路由

用户列表路由的路径是/dashboard/user，是/dashboard的子路由。

## 6.3、用户列表

使用table组件展示用户列表。table需要绑定一个数组，在table-column上使用prop对应元素的属性名，用table-column来显示数组中每个元素的对应的属性。

## 6.4、查询用户

使用pagehleper来实现分页查询。

时间的显示要设置jackson依赖的时区和格式。

## 6.5、分页显示

使用elementplus的Pagination 分页组件。

## 6.6、用户详情

使用Elementplus中的插槽，可以拿到表格中当前显示的数据。

reactive包裹的对象不能直接修改，只能修改它的属性，或者使用Object.assign()。

后端中需要联合查询，将用户的创建者和修改者也查出来。

使用useRouter()获取路由器对象时，要注意上下文，如果在一个箭头函数中使用的话，可以不会有预期的效果：

```js
const goBack = () => {
    useRouter().go(-1);
};
```

## 6.7、新增用户

用elementplus的dialog弹窗来显示添加用户的窗口。

使用query对象来接收前端传过来的数据，在业务方法中将query对象转为TUser对象，使用BeanUtils.copyProperties方法复制属性，要求两个对象之间的属性的名称和类型都一样。

添加用户时要拿到请求的token，用token获取发送该请求的用户的id，用来作新增用户的创建人。

前端添加发送请求时，数据如果是一个formData，那么后端接口接收不要使用RequestBody注解，如果是一个json字符串或普通js对象，那么要使用ResponseBody注解。

新增用户后的页面需要刷新一下，显示新的数据。可以在父组件DashBoard中，使用v-if来控制路由组件的显示，再使用provide提供一个刷新路由组件的函数，然后在子组件UsesrView中在提交成功后通过inject获得并调用这个函数。其实也可以直接重新调用一次获取数据的方法即可。

## 6.8、修改用户

修改用户和新增用户共用一个dialog弹窗，根据是否有id来判断是新增还是修改。

elemenplus中的select选择器组件，其中的option选项，它的value值会判断数据类型，数字1和字符串"1"是不同效果的。当select选择器绑定的值是数字1时，只能和option中绑定的数据也是数字1的匹配。

想要将一个reactive包裹的对象全部改为某种状态时，只能手动赋值每个属性，可以使用Object.keys来获取所有的key，然后遍历赋值。

要确保dialog显示出来后，再对dialog进行修改，否则可能不会生效。要将表单的东西重置，可以使用表单对象的resetFields()方法。

编辑和添加公用一个dialog，这样两个方法调用前都要先重置一遍表单，确定每次打开dialog时，不会有另一个操作中的错误提示信息，但是可以使用一个变量来记录是否有错误信息，是的话就重置表单，否则就不重置，这样就可以保证我添加数据时，不小心关闭后，重新打开表单，数据还在。

在第一次打开dialog时，使用表单的resetFields方法可能会报错，因为此时dialog中的表单元素可能还未被渲染，所以可以使用nextTick来调用resetFields方法，保证该方法被调用时，对应的表单对象已经渲染出来。

```js
const edit = (id) => {
    addUserDialogVisible.value = true;
    nextTick(() => {
        addUserForm.value.resetFields();
    })
    doGet("/api/user/" + id).then(resp => {
        if (resp.data.code === 200) {
            Object.assign(userQuery, resp.data.data);
        }
    })
}
```

## 6.9、删除用户

外键约束：

![image-20240825145715206](https://gitee.com/LowProfile666/image-bed/raw/master/img/202408251457355.png)

## 6.10、全局异常捕获

创建一个全局异常捕获的类，用来在出异常时，像前端返回异常信息，前端可以显示这异常信息。

## 6.11、批量删除

elementplus的带复选框的表格，选中复选框时会触发一个函数，会将当前所有已选择的数据传给该函数。

后端使用数组来接收被删除的数据id时，前端要使用对应的格式：

```
ids=1,2,3,4,5
ids=1&ids=2&ids=3
```

如果直接传递一个数组给后端的话，使用delete请求的话，实际的参数是：

```
ids[]=1$ids[]=2&ids[]=3
```

所以要先将ids数组转为字符串 "1,2,3" ，传过去就是id=1,2,3

在mybatis中再使用foreach来循环数组。参数类型可以写int[]。

# 7、数据权限

使用sql语句进行过滤。使用aop保证所有操作都有数据权限。让管理员角色的用户可以查看所有的用户，普通用户就只能查看自己。

先引入aop的依赖：

```xml
<!-- https://mvnrepository.com/artifact/org.springframework.boot/spring-boot-starter-aop -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
    <version>3.3.3</version>
</dependency>
```

本质就是在sql语句后面拼上一句限制，所以在mapper接口的方法中，传递一个参数，该参数中有一个字符串，就是会被拼接到sql语句后面的字符串：

```java
List<TUser> list(BaseQuery baseQuery);
```

新建一个BaseQuery类，所有的query类都继承这个类，这个类用来放一些所有query都需要的字段：

```java
public class BaseQuery {
    public String filterSql = "";
}
```

这个filterSql就是将来要拼接到sql语句中的部分。

比如，id为2的用户只能查看自己的用户列表：

```sql
select * from t_user where id = 2
```

那这个id=2这一部分就是filterSql，被使用aop拼接上去的。要是有多表的话，还需要利用表的别名。

所以可以自定义一个注解DataScope，用两个属性，一个是表的别名，一个是字段的名字：

```java
@Target(ElementType.METHOD)
@Documented
@Retention(RetentionPolicy.RUNTIME)
public @interface DataScope {
    String typeAlias() default "";
    String filedName() default "";
}
```

然后将这个注解使用在具体的查询用户的mapper接口上：

```java
@DataScope(typeAlias = "tu", filedName = "id")
List<TUser> list(BaseQuery baseQuery);
```

这样的结果就是会生成这样的sql语句：

```sql
select * from t_user tu where tu.id = 2
```

那么还需要使用切面。

其中，需要判断用户的角色，所以在登录时，要将用户的角色查询出来，最后一起封装到token中，那么在切面类中就可以直接通过token获得角色列表。SpringSecurity成功登录后，会调用自定义的登录成功处理器，在这里面会将登录用户信息封装成一个token，而这里的用户信息事调用UserDetailsService接口实现类的loadUserByUsername方法获得的，所以在这个方法中，查出用户的角色信息，然后返回去封装进token中：

```java
public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
    TUser user = userMapper.selectByUsername(username);

    if (user == null) {
        throw new UsernameNotFoundException("用户不存在");
    }
    // 查询角色
    List<TRole> roles = roleMapper.selectByUserId(user.getId());
    // 转成角色列表
    List<String> roleList = roles.stream().map(role -> role.getRole()).collect(Collectors.toList());

    user.setRoles(roleList);

    return user;
}
```

新建一个切面类：需要用到token

```java
@Aspect
@Component
public class DataScopeAspect {

    @Pointcut("@annotation(com.zsm.dlyk.dlykbackend.commons.DataScope)")
    public void pointCut() {

    }

    @Around("pointCut()")
    public Object appendSql(JoinPoint joinPoint) throws Throwable {
        // 先拿到方法签名
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        // 获取到方法上面的注解
        DataScope annotation = signature.getMethod().getAnnotation(DataScope.class);
        // 拿到注解中的值
        String tableAlias = annotation.tableAlias();
        String filedName = annotation.filedName();

        // 需要判断用户的角色
        // 先获取到token
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
        String token = request.getHeader(Constants.HEADER_TOKEN_NAME);
        // 解析token，获取用户角色
        List<String> roles = JWTUtils.parseJWTByUserRole(token);
        Integer userId = JWTUtils.parseJWTByUserId(token);

        // 如果是管理员角色不用拼接sql
        // 如果是普通用户，需要限制只能查看自己用户
        if (roles == null || !roles.contains("admin")) {
            // 获取到方法上的参数
            BaseQuery baseQuery = (BaseQuery) joinPoint.getArgs()[0];
            // 设置where子句，表名.字段名=用户id
            baseQuery.setFilterSql(" and " + tableAlias + "." + filedName + " = '" + userId + "'");
        }

        // 继续执行被拦截的方法，并获取其返回值
        return ((ProceedingJoinPoint) joinPoint).proceed();
    }
}
```

那么mapper.xml文件中的sql语句就要这样写，设置别名，设置where子句：

```xml
<select id="list" resultMap="BaseResultMap">
    select
    <include refid="Base_Column_List" />
    from t_user tu
    <where>
        ${filterSql}
    </where>
</select>
```

这里的sql语句要注意，使用的是${}，而不是#{}，因为#{}会先编译，pageHelper会调用一个sql语句，如果使用#{}的话，这个语句就是这样，因为#{}的会位置会被当作一个参数：

```
SELECT count(0) FROM t_user tu where ?
```

而使用${}的时候，这个位置不会被当作参数，而只是字符串拼接，所以更加适合。

最终生成的sql语句是这样的：

```sql
select id, login_act, login_pwd, `name`, phone, email, account_no_expired, cr
edentials_no_expired, account_no_locked, account_enabled, create_time, create_by, edit_time, edit_by, last_login_time 
from t_user tu 
WHERE tu.id = '2'
```



# 8、市场活动

## 8.1、活动列表

基本上和用户管理差不多的。

## 8.2、搜索框

根据条件搜索，搜索出的内容也可以分页。

获取负责人列表，从redis缓存中获取，如果没有，再从数据库中获取，并写到缓存中。

elementPlus的el-date-picker时间选择器组件，要使用value-format属性来设置值的格式，否则是date的格式。且如果是选择时间范围的话，得到的值是一个Proxy对象，里面包含开始时间和结尾时间，需要遍历属性才能拿到每个时间：

```vue
<el-date-picker
                v-model="activityQuery.createTime"
                type="datetime"
                placeholder="请选择创建时间"
                format="YYYY-MM-DD HH:mm:ss"
                date-format="MMM DD, YYYY"
                time-format="HH:mm"
                value-format="YYYY-MM-DD HH:mm:ss"
                />

let startTime = '';
let endTime = '';

for (let key in activityQuery.rangeTime) {
	if (key === '0') startTime = activityQuery.rangeTime[key];
	if (key === '1') endTime = activityQuery.rangeTime[key];
}
```

或者这样获取，前提是，rangeTime需要初始化，否则会报错：

```js
let [startTime,endTime] = activityQuery.rangeTime;
```

且，当选中时间后，然后叉掉所选时间后，该对象就会被置为null，所以如果使用以上方式，最好还要判断一下是否为空。

在表单上使用规则时，表单项上的prop属性的名字一定要和输入框绑定的属性名能对上，表单上绑定的对象加上表单项上的prop属性名，应该是和input输入框绑定的值一样，这样才能使用规则：

```vue
<el-form :inline="true" :model="activityQuery" ref="activityForm" :rules="rules">
    <el-form-item label="活动预算" prop="cost">
        <el-input v-model="activityQuery.cost" placeholder="请输入活动预算" clearable/>
    </el-form-item>
</el-form>
```

+ 这里表单绑定的值activityQuery加上表单项的prop就是activityQuery.cost，就是input绑定的值



## 8.3、缓存工具类

这是一个带有缓存的查询方法，使用到了生产者和消费者设计模式。

```java
public class CacheUtils {

    public static <T> T getCacheData(Supplier<T> cacheSelector, Supplier<T> dbSelector, Consumer<T> cacheSave) {
        // 从缓存中获取数据
        T res = cacheSelector.get();
        // 如果数据为空
        if (Objects.isNull(res)) {
            // 从数据库中获取数据
            res = dbSelector.get();
            // 数据库中数据不为空的话u
            if (!Objects.isNull(res)) {
                // 就写入缓存中一份
                cacheSave.accept(res);
            }
        }
        return res;
    }
}
```

jdk8中有四大功能性接口

+ Supplier
+ Consumer
+ Function
+ Predicate

以上代码中使用了Supplier和Consumer：

+ Supplier<T> cacheSelector：生产者，返回数据，从redis中获取数据并返回
+ Supplier<T> dbSelector：生产者，返回数据，从数据库中获取数据并返回
+ Consumer<T> cacheSave：消费者，接收数据，将数据存到redis中

那么调用这个方法时就这样调用：

```java
public List<TUser> getOwners() {
    return CacheUtils.getCacheData(
        () -> {
            // 生产者，从redis中获取数据
        }, () -> {
            // 生产者，从mysql中获取数据
        }, (data) -> {
            // 消费者，将数据存到redis中
        });
}
```

按照阿里开发规范，将对Service层的通用能力的下沉的代码，如缓存方案，写在manager层中。 所以创建一个RedisManager类：

```java
@Component
public class RedisManager {
    @Resource
    private RedisTemplate<String, Object> redisTemplate;
    
    public List<Object> getValue(String key) {
        return redisTemplate.opsForList().range(key, 0, -1);
    } 
    
    // 这样写法，以数组的形式，将每个元素分别写入到redis的list中
    public <T> void setValue(String key, Collection<T> value) {
        Object[] t  = new Object[value.size()];
        value.toArray(t);
        redisTemplate.opsForList().rightPushAll(key, t);
    }
    
    // 如果是这样的写法，会将所有的元素写在list中的一个元素中
    // public <T> void setValue(String key, Collection<T> value) {
        // redisTemplate.opsForList().rightPushAll(key, value);
    // }
}
```

这个manager类提供了一个get和set方法，用来向redis中读取和写入数据的。然后在getOwners方法中这样用：

```java
public List<TUser> getOwners() {
    return CacheUtils.getCacheData(
        () -> {
            // 生产者，从redis中获取数据
            return (List<TUser>) redisManager.getValue(Constants.REDIS_OWNERS_KEY);
        }, () -> {
            // 生产者，从mysql中获取数据
            return userMapper.getOwners();
        }, (data) -> {
            // 消费者，将数据存到redis中
            redisManager.setValue(Constants.REDIS_OWNERS_KEY, data);
        });
}
```

而在userMapper中的sql语句这样写，只需要查用户的id和姓名即可：

```xml
<select id="getOwners" resultType="com.zsm.dlyk.dlykbackend.model.TUser">
    select id, name from t_user
</select>
```

## 8.4、搜索功能

前端时间使用value-format控制了格式，后端也要控制格式，在ActivityQuery中，使用@DateTimeFormat注解来控制时间格式，它通常用于将字符串形式的日期和时间转换为 Java 的 `Date` 对象。前端传来的数据如果是 2023-04-30 17:48:54 这种格式，不能直接转为date对象的，就需要使用该注解指定格式。

在编写sql语句时，不能直接写<=，因为<号是一个特殊符号，需要转义，可以写成`&lt;`，也可将带有小于号的代码写在`<![CDATA[]]>`中。

## 8.5、录入市场活动

点击录入，打开一个新的表单页面，也就是需要一个新的路由组件。和添加用户差不多。



## 8.6、编辑市场活动

编辑和添加公用一个页面。路径 同，组件相同，路径发生改变后，组件会重新渲染，所以两个路由中的同一个组件不会相互影响。

## 8.7、查看详情

展示详情，同时可以添加一条备注，下面还要显示历史的备注信息。

显示备注时，将备注通过创建时间降序排序，让新创建的备注显示在前面。

实现假删除，那么查询的时候就要加上一个条件，不查询deleted为1的数据，但是，如果deleted默认为null的话，不要使用deleted!=1来判断，因为它的结果是未知的。可以这样判断：

```xml
<select id="listActivityRemarks" resultMap="ActivityRemarkMap">
    select tar.*,
    tu1.id creatorId, tu1.name creatorName,
    tu2.id editorId, tu2.name editorName
    from t_activity_remark tar left join t_user tu1 on tar.create_by = tu1.id
    left join t_user tu2 on tar.edit_by = tu2.id
    where activity_id = #{activityId} and (tar.deleted != 1 or tar.deleted is null)
    order by tar.create_time desc
</select>
```

或者使用coalesce。`COALESCE` 是一个 SQL 函数，用于返回其参数列表中第一个非空（非 `NULL`）的值。它可以接受任意数量的参数，并逐个检查，直到找到第一个不是 `NULL` 的值为止：

```xml
<select id="listActivityRemarks" resultMap="ActivityRemarkMap">
    select tar.*,
    tu1.id creatorId, tu1.name creatorName,
    tu2.id editorId, tu2.name editorName
    from t_activity_remark tar left join t_user tu1 on tar.create_by = tu1.id
    left join t_user tu2 on tar.edit_by = tu2.id
    WHERE activity_id = #{activityId} AND COALESCE(tar.deleted, 0) != 1
    order by tar.create_time desc
</select>
```

在查询传参的时候，如果有多个参数，比如一个int一个对象，那么sql语句中，int参数名保持一致，但是对象的属性这个参数需要使用对象名点：

```java
@DataScope(tableAlias = "tu1", filedName = "id")
List<TActivityRemark> listActivityRemarks(Integer activityId,  BaseQuery baseQuery);
```

```xml
<select id="listActivityRemarks" resultMap="ActivityRemarkMap">
    select tar.*,
    tu1.id creatorId, tu1.name creatorName,
    tu2.id editorId, tu2.name editorName
    from t_activity_remark tar left join t_user tu1 on tar.create_by = tu1.id
    left join t_user tu2 on tar.edit_by = tu2.id
    <where>
        activity_id = #{activityId}
        and (tar.deleted != 1 or tar.deleted is null)
        ${baseQuery.filterSql}
    </where>
    order by tar.create_time desc
</select>
```



# 9、redis序列化

将启动类改成：

```java
@MapperScan(basePackages = {"com.zsm.dlyk.dlykbackend.mapper"})
@SpringBootApplication
public class Application implements CommandLineRunner {
    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    public static void main(String[] args) {
        ConfigurableApplicationContext context = SpringApplication.run(Application.class, args);
    }

    @Override
    public void run(String... args) throws Exception {
        //springboot项目启动后，把redisTemplate这个Bean修改一下，修改一下key和value的序列化方式

        //设置key序列化
        redisTemplate.setKeySerializer(new StringRedisSerializer());

        //对象映射工具，Java对象 和 json对象进行相互转化
        ObjectMapper mapper = new ObjectMapper();
        //设置可见性
        mapper.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        //激活类型
        mapper.activateDefaultTyping(mapper.getPolymorphicTypeValidator(), ObjectMapper.DefaultTyping.EVERYTHING);

        //设置value序列化
        redisTemplate.setValueSerializer(new Jackson2JsonRedisSerializer<Object>(mapper, Object.class));

        //设置hashKey序列化
        redisTemplate.setHashKeySerializer(new StringRedisSerializer());

        //设置haskValue序列化
        redisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer<Object>(mapper, Object.class));
    }
}
```

实现 `CommandLineRunner`

- **接口作用**：`CommandLineRunner` 是一个回调接口，它的 `run` 方法会在 Spring Boot 应用启动后执行。可以在这个方法中添加初始化逻辑、数据加载、配置 Bean 等。

- **在这个例子中的实现**：

  - RedisTemplate 配置

    ：在应用启动时，设置 Redis 的序列化方式。

    - **Key 和 HashKey 序列化**：使用 `StringRedisSerializer` 来确保 Redis 中的 Key 是以字符串形式存储的。
    - **Value 和 HashValue 序列化**：使用 `Jackson2JsonRedisSerializer` 来将对象序列化为 JSON 格式，便于存储和读取。

  这种方法确保 Redis 存储的数据是可读的，并且可以轻松地将 Java 对象与 JSON 进行相互转换。

`ObjectMapper` 配置

- **可见性和类型激活**：通过配置 `ObjectMapper`，可以控制在序列化和反序列化时如何处理 Java 对象的属性。设置可见性后，`ObjectMapper` 会考虑所有属性进行序列化。
- **类型激活**：激活默认类型，这有助于在反序列化时处理多态类型。

总结

- **实现 `CommandLineRunner` 接口** 的主要目的是在应用程序启动后执行初始化逻辑。
- **配置 RedisTemplate** 及其序列化方式，提高了与 Redis 交互时的灵活性和数据一致性。
- 这种设计使得应用程序在启动时就配置好所有依赖，确保在处理请求时 Redis 已经处于一个正确的状态。

这种做法是 Spring Boot 应用程序中的一种常见模式，确保了应用程序的可配置性和可维护性。

# 10、线索管理

线索就是有意向客户的联系方式。

## 10.1、导入excel

使用elementplus中的上传组件。默认是选择文件后就自动上传，通过设置auto-upload属性来设置手动上传。

通过http-request属性可以设置真正的上传实现逻辑，会覆盖原有默认的行为，该属性绑定的方法会在上传组件发送请求时执行。该方法自动会传一个参数，这个参数是上传文件的信息，可以拿到上传的文件以及一些信息。

```vue
<el-dialog
           v-model="importDialogVisible"
           title="导入线索"
           center
           width="40%"
           draggable
           overflow
           >
    <el-upload
               ref="uploadRef"
               :http-request="doUploadFile"
               :auto-upload="false">
        <template #trigger>
<el-button type="primary" style="margin-right: 10px">选择文件</el-button>
仅支持后缀名为.xls或.xlsx的文件
        </template>
        <div style="margin-top: 20px">重要提示：</div>
        <ul style="margin-left: 50px">
            <li>上传仅支持后缀名为.xls或.xlsx的文件；</li>
            <li>给定Excel文件的第一行将视为字段名；</li>
            <li>请确认您的文件大小不超过50MB；</li>
            <li>日期值以文本形式保存，必须符合yyyy-MM-dd格式；</li>
            <li>日期时间以文本形式保存，必须符合yyyy-MM-dd HH:mm:ss的格式；</li>
        </ul>
    </el-upload>
    <template #footer>
<div class="dialog-footer">
    <el-button @click="importDialogVisible = false">取消</el-button>
    <el-button type="primary" @click="importExcelSubmit">
        提交
        </el-button>
        </div>
    </template>
</el-dialog>
```

当点击提交按钮，会执行importExcelSubmit方法：

```js
let uploadRef = ref();
const importExcelSubmit = () => {
    uploadRef.value.submit();  // 提交该上传组件中的文件
}
```

这会将upload组件选择的文件提交，会执行doUploadFile方法，这个方法会自带一个参数，这个参数中包含了被上传的文件，以及其他的信息：

```js
const doUploadFile = (info) => {
    console.log(info);
    let file = info.file;  // 获取被上传的文件
    console.log(file);
    uploadRef.value.clearFiles();  // 清空已上传的文件
}
```

如果选择了多个文件的话，点击提交时，会一个一个的上传，一次一次的执行该方法。

使用formData来上传文件：

```js
const doUploadFile = (info) => {
    let file = info.file;
    let formData = new FormData();
    formData.append("file", file);
    doPost("/api/clue/upload", formData).then(resp => {
        if (resp.data.code === 200) {
            messageTip("上传成功！", MESSAGE_TIP_TYPE.SUCCESS);
            uploadRef.value.clearFiles();
        } else {
            messageTip("上传失败！" + resp.data.msg, MESSAGE_TIP_TYPE.ERROR);
        }
    })
}
```

后端接收前端传过来的一个文件时，使用MultipartFile类来接收，这个参数的名字要和前端传过来的名字一样：

```java
@PostMapping("/api/clue/upload")
public R upload(MultipartFile file) {
    System.out.println(file);
    return R.OK();
}
```

接收到的文件会被放在一个临时文件夹里面：

![image-20240901145014707](https://gitee.com/LowProfile666/image-bed/raw/master/img/202409011450905.png)

然后将文件数据读出来，转成Java对象，保存到数据库中。使用EasyExcel库。

## 10.2、EasyExcel上传

官网：[EasyExcel官方文档 - 基于Java的Excel处理工具 | Easy Excel 官网 (alibaba.com)](https://easyexcel.opensource.alibaba.com/)，官网中有实例代码。

引入依赖：

```xml
<!-- https://mvnrepository.com/artifact/com.alibaba/easyexcel -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>easyexcel</artifactId>
    <version>4.0.2</version>
</dependency>
```

web上传文件：

```java
/**
     * 文件上传
     * <p>1. 创建excel对应的实体对象 参照{@link UploadData}
     * <p>2. 由于默认一行行的读取excel，所以需要创建excel一行一行的回调监听器，参照{@link UploadDataListener}
     * <p>3. 直接读即可
     */
@PostMapping("upload")
@ResponseBody
public String upload(MultipartFile file) throws IOException {
    EasyExcel.read(file.getInputStream(), UploadData.class, new UploadDataListener(uploadDAO)).sheet().doRead();
    return "success";
}
```

参数：

1. 上传的文件的输入流形式
2. 模板类，文件的模板类
3. 监听器，监听器中有一些方法

在具体的业务实现类中使用：

```java
public void upload(MultipartFile file) {
    try {
        EasyExcel.read(file.getInputStream(), TClue.class, new UploadClueListener(clueMapper)).sheet().doRead();
    } catch (IOException e) {
        throw new RuntimeException(e);
    }
}
```

这个模板类，需要使用到注解`ExcelProperty`，来将类中的属性对应到excel表中的列名：

```java
@Data
public class TClue implements Serializable {
    /**
     * 主键，自动增长，线索ID
     */
    private Integer id;

    /**
     * 线索所属人ID
     */
    @ExcelProperty(value = "负责人")
    private Integer ownerId;

    /**
     * 活动ID
     */
    @ExcelProperty(value = "所属活动")
    private Integer activityId;

    /**
     * 姓名
     */
    @ExcelProperty(value = "姓名")
    private String fullName;

    /**
     * 称呼
     */
    @ExcelProperty(value = "称呼")
    private Integer appellation;

    /**
     * 手机号
     */
    @ExcelProperty(value = "手机号")
    private String phone;

    /**
     * 微信号
     */
    @ExcelProperty(value = "微信号")
    private String weixin;

    /**
     * QQ号
     */
    @ExcelProperty(value = "QQ号")
    private String qq;

    /**
     * 邮箱
     */
    @ExcelProperty(value = "邮箱")
    private String email;

    /**
     * 年龄
     */
    @ExcelProperty(value = "年龄")
    private Integer age;

    /**
     * 职业
     */
    @ExcelProperty(value = "职业")
    private String job;

    /**
     * 年收入
     */
    @ExcelProperty(value = "年收入")
    private BigDecimal yearIncome;

    /**
     * 地址
     */
    @ExcelProperty(value = "地址")
    private String address;

    /**
     * 是否需要贷款（0不需要，1需要）
     */
    @ExcelProperty(value = "是否贷款")
    private Integer needLoan;

    /**
     * 意向状态
     */
    @ExcelProperty(value = "意向状态")
    private Integer intentionState;

    /**
     * 意向产品
     */
    @ExcelProperty(value = "意向产品")
    private Integer intentionProduct;

    /**
     * 线索状态
     */
    @ExcelProperty(value = "线索状态")
    private Integer state;

    /**
     * 线索来源
     */
    @ExcelProperty(value = "线索来源")
    private Integer source;

    /**
     * 线索描述
     */
    @ExcelProperty(value = "线索描述")
    private String description;

    /**
     * 下次联系时间
     */
    @ExcelProperty(value = "下次联系时间")
    private Date nextContactTime;
    /**
     * 创建时间
     */
    private Date createTime;

    /**
     * 创建人
     */
    private Integer createBy;

    /**
     * 编辑时间
     */
    private Date editTime;

    /**
     * 编辑人
     */
    private Integer editBy;

    private TUser ownerDO = new TUser();
    private TActivity activityDO = new TActivity();
    private TDicValue appellationDO = new TDicValue();
    private TDicValue needLoanDO = new TDicValue();
    private TDicValue intentionStateDO = new TDicValue();
    private TProduct intentionProductDO = new TProduct();
    private TDicValue stateDO = new TDicValue();
    private TDicValue sourceDO = new TDicValue();

    private static final long serialVersionUID = 1L;
}
```

这个监听器的模板写法：[easyexcel-test/src/test/java/com/alibaba/easyexcel/test/demo/web/UploadDataListener.java · easyexcel/easyexcel - 码云 - 开源中国 (gitee.com)](https://gitee.com/easyexcel/easyexcel/blob/master/easyexcel-test/src/test/java/com/alibaba/easyexcel/test/demo/web/UploadDataListener.java)

```java
/**
 * 模板的读取类
 *
 * @author Jiaju Zhuang
 */
// 有个很重要的点 DemoDataListener 不能被spring管理，要每次读取excel都要new,然后里面用到spring可以构造方法传进去
@Slf4j
public class UploadDataListener implements ReadListener<UploadData> {
    /**
     * 每隔5条存储数据库，实际使用中可以100条，然后清理list ，方便内存回收
     */
    private static final int BATCH_COUNT = 5;
    private List<UploadData> cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);
    /**
     * 假设这个是一个DAO，当然有业务逻辑这个也可以是一个service。当然如果不用存储这个对象没用。
     */
    private UploadDAO uploadDAO;

    public UploadDataListener() {
        // 这里是demo，所以随便new一个。实际使用如果到了spring,请使用下面的有参构造函数
        uploadDAO = new UploadDAO();
    }

    /**
     * 如果使用了spring,请使用这个构造方法。每次创建Listener的时候需要把spring管理的类传进来
     *
     * @param uploadDAO
     */
    public UploadDataListener(UploadDAO uploadDAO) {
        this.uploadDAO = uploadDAO;
    }

    /**
     * 这个每一条数据解析都会来调用
     *
     * @param data    one row value. It is same as {@link AnalysisContext#readRowHolder()}
     * @param context
     */
    @Override
    public void invoke(UploadData data, AnalysisContext context) {
        log.info("解析到一条数据:{}", JSON.toJSONString(data));
        cachedDataList.add(data);
        // 达到BATCH_COUNT了，需要去存储一次数据库，防止数据几万条数据在内存，容易OOM
        if (cachedDataList.size() >= BATCH_COUNT) {
            saveData();
            // 存储完成清理 list
            cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);
        }
    }

    /**
     * 所有数据解析完成了 都会来调用
     *
     * @param context
     */
    @Override
    public void doAfterAllAnalysed(AnalysisContext context) {
        // 这里也要保存数据，确保最后遗留的数据也存储到数据库
        saveData();
        log.info("所有数据解析完成！");
    }

    /**
     * 加上存储数据库
     */
    private void saveData() {
        log.info("{}条数据，开始存储数据库！", cachedDataList.size());
        uploadDAO.save(cachedDataList);
        log.info("存储数据库成功！");
    }
}
```

每次读一行数据都会调用一次监听器中invoke方法。读完所有行数据就会调用一次doAfterAllAnalysed方法。

```java
public class UploadClueListener implements ReadListener<TClue> {
    private static final int BATCH_COUNT = 100;  // 每隔100条存数据库
    private List<TClue> cachedDataList = ListUtils.newArrayListWithExpectedSize(BATCH_COUNT);  // 100条数据的暂存list
    private TClueMapper clueMapper;  // 用来存入数据库

    public UploadClueListener(TClueMapper clueMapper) {
        this.clueMapper = clueMapper;
    }

    @Override
    public void invoke(TClue tClue, AnalysisContext analysisContext) {
        cachedDataList.add(tClue);  // 解析到一条数据，添加到缓存中
        if (cachedDataList.size() >= BATCH_COUNT) {  // 缓存中存到了最大数量的数据，就像数据库中写入
            saveData();  // 保存一次
            cachedDataList.clear();  // 清空list
        }
    }

    @Override
    public void doAfterAllAnalysed(AnalysisContext analysisContext) {
        saveData();
    }

    private void saveData() {
        clueMapper.upload(cachedDataList);
    }
}
```

然后就是要实现clueMapper的upload方法，将集合中的数据写入数据库中即可。

就可以在invoke中检查每一条数据，如果有不对的数据可以抛出异常，返回给前端。

## 10.3、转换单元格数据

但是现在导入有个问题，在导入的excel表中，称呼这一栏数据的值是“先生”或“女士”，但是对应的Java对象的属性确实Integer型的，所以这样导入会报错，无法将一个字符串转为Integer。还有其他的属性也有这个问题。所以需要写个转换。

比如，实现一个称呼的转换器，需要实现Converter接口，实现其中的将excel数据转为java数据的方法：

```java
public class AppellationConverter implements Converter<Object> {
    @Override
    public Object convertToJavaData(ReadCellData<?> cellData, ExcelContentProperty contentProperty, GlobalConfiguration globalConfiguration) throws Exception {
        // cellData是excel表中单元格中的数据
        // 在这里，要将称呼对应的code从数据库中查出，但是这里无法使用注入获取数据库对象
        // 所以可以先将数据放入内存中，然后从内存中获取
        // 可以在项目启动后设置一个定时任务，每隔几分钟就从数据库中查询并存到内存中
        return null;
    }
}
```

那么需要先设置一个定时任务，将数据库中的数据查出来，然后放入内存中，也就是一个变量中。在启动类中可以创建一个全局的map变量：

```java
public static final Map<String, Object> cacheMap = new HashMap<>();
```

设置定时任务：

在application.yml中定义定时任务的cron表达式：每10分钟一次

```yaml
project:
  task:
    cron: '* 10 * * * *'
```

然后实习一个定时任务：在该任务中去获取数据库中的数据

```java
@EnableScheduling //开启定时任务的支持
@Component
public class DataCacheTask {
    @Resource
    private DicTypeService dicTypeService;

    @Scheduled(cron = "${project.task.cron}")
    public void task() {
        List<TDicType> dicTypeList = dicTypeService.getAll();  // 获取所有的dicType
        dicTypeList.forEach(dicType -> {
            String typeCode = dicType.getTypeCode();  // 获取到typecode，比如：appellation
            List<TDicValue> dicValues = dicType.getDicValues();  // 获取到对应typevalue集合，比如：先生、女士
            Application.cacheMap.put(typeCode, dicValues);  // 存入内存中
        });
    }
}
```

+ 底层的sql语句，因为是使用的一对多，一个typecode对应多个typevalue，所以结果集映射要使用collection，使用ofType属性表示集合中的元素类型。

这样设置定时只会在10分钟后开始执行，最开始不能执行，要这样：fixedDelay设置每次执行间隔，initialDelay设置初次执行延迟

```java
@Scheduled(fixedDelay = 10 * 60 * 1000, initialDelay = 1000)  // 运行1秒后执行一次，之后每10分钟执行一次
public void task() {
    List<TDicType> dicTypeList = dicTypeService.getAll();  // 获取所有的dicType
    dicTypeList.forEach(dicType -> {
        String typeCode = dicType.getTypeCode();  // 获取到typecode，比如：appellation
        List<TDicValue> dicValues = dicType.getDicValues();  // 获取到对应typevalue集合，比如：先生、女士
        Application.cacheMap.put(typeCode, dicValues);  // 存入内存中
    });

    List<TProduct> products = productService.getAllOnLine();
    products.forEach(product -> {
        Integer id = product.getId();
        String name = product.getName();
        Application.cacheMap.put(name, id);
    });
}
```

## 10.4、录入

负责人选项框设为禁用，用来显示当前登录用户的名字。需要使用options组件，因为用来匹配当前登录用的名字。

手机号是必填，其他属性非必填，但是如果填了就会有对应的规则。

还要验证手机号是否是唯一的，使用方法验证，在规则中使用方法验证：

```js
{validator: check, trigger: 'blur'}
```

这个check是一个函数。这个函数会自动携带三个参数：
