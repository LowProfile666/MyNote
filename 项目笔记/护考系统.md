# 护考系统

> 护士资格考试刷题系统

## 一、建库

### 1. 建表

所有考试题目分为两种类型：

+ 专业实务
+ 实践能力

现有的题库中将所有题目按照 年度真题 和 章节题目 分成了两部分，所以考虑将刷题页面做成两个：

+ 章节练习：根据章节来刷题
+ 真题练习：根据真题的年度来刷题

![image-20231210132501919](https://gitee.com/LowProfile666/image-bed/raw/master/img/202312101325009.png)

+ Year 表示真题的年度，可以使用一张表来存，也可可以用 WTMPlus 提供的数据字典或枚举类型来管理；
+ QuestionType 表示题目的类型，也用 WTMPlus 提供的数据字典来处理，有两个值：专业实务、实践能力；
+ Chapter 和 Section 用数据表存储，因为章节的关系应该是一对多的关系，一个章有多个节。

### 2. 创建模型

使用 WTMPlus ，新建两个区域：QuestionBank 和 StudentArea

+ QuestionBank 用来存放题库相关的模型和页面
+ StudentArea 用来存放学生能看到的页面的，就是刷题页面

按照上面的表设计，在 QuestionBank 区域中建三个模型，分别是：Question（题）、Chapter（章）、Section（节），均勾选上 “是否为BasePoco” 选项，然后分别创建它们所含有的字段，注意 Photo 字段需要使用 “附件类型”。

其中 Question 模型的 QuestionType、Year 两个字段使用 “单个数据字典” 类型，在 “资源维护” 中的 “数据字典维护” 中添加两个字典：“真题年度” 和 “题目类型”，真题年度中的值就为 2011 到 2022，题目类型中的值就是 专业实务、实践能力。还有 Chapter 和 Section 字段，都设为 “一对多关联” 类型，Chapter 字段关联的模型是 Chapter，Section 字段关联的模型是 Section，这表示一个章和一个节对应着多个题目。

还有 Section 模型中的 Chapter 字段需要使用 “一对多关联” 类型，关联的模型是 Chapter，表示一个章有多个节。

并且三个模型均使用自定义主键，在页面右边选择主键类型为 int，字段名为 id。

![image-20231210134718160](https://gitee.com/LowProfile666/image-bed/raw/master/img/202312101347237.png)

然后保存模型，并且都生成默认页面。生成默认页面后，需要改动一下有的页面，将章节信息设置为联动。

比如在创建题目的时候，在 Question 的 Create 页面中，会有两个章节的下拉选择框，将 “章” 的那个下拉框设置联动，“节” 下拉框不需要设置联动：

![image-20231210135214523](https://gitee.com/LowProfile666/image-bed/raw/master/img/202312101352576.png)

除了这个页面，还有其他只要出现了章节信息的页面都将下拉框设为联动。

### 3. 创建页面

在 StudentArea 区域下新建三个页面：ChapterExam、RealExam 和 MockExam（按需创建），分别是章节训练、真题训练和模拟考试。这三个页面都只需要拖入一个表单即可，因为最终的页面由我们自己手写完成，通过 WTMPlus 创建好页面就可以直接使用，不用再去人工配置。

## 二、实现后端API

将代码下载下来，然后使用 VS 打开，先在 appsetting.json 中将数据库改成本地的 MySQL 数据库。

然后在 Areas/StudentArea/Controllers 下新建两个文件：\_ChapterExamController.cs 和 \_RealExamController.cs，分别用来控制章节训练和真题训练的业务逻辑。

这两个新建的 controller 要继承 BaseController，如：

```cs
public class _ChapterExamController : BaseController
{
    
}
```

### 1. 章节训练

先在类名上添加路由：

```cs
[Route("/ChapterExam")]
public class _ChapterExamController : BaseController
{
}
```

这样表示该类中所有的 API 的路径都是在 /ChapterExam 下。

#### 1.1 获取章节信息

可以新建一个内部类来做返回数据的结构，这个类包括两个属性，章的名字和该章所有的节的名字，返回的是一个 List 集合：

```cs
// 用做返回结果的结构
public class ChapterResult
{
    public string Name { get; set; }
    public List<string> SectionList { get; set; }
}
// 获取章节信息
[HttpGet("GetChapterInfo")]
public List<ChapterResult> GetChapterInfo()
{
    var ChapterList = DC.Set<Chapter>().ToList();
    List<ChapterResult> res = new List<ChapterResult>();
    foreach (var item in ChapterList)
    {
        ChapterResult c = new ChapterResult();
        c.SectionList = DC.Set<Section>().Where(x => x.ChapterIDId == item.ID).Select(x => x.Name).ToList();
        c.Name = item.Name;
        res.Add(c);
    }
    return res;
}
```

这个 API 的访问地址就是：`/ChapterExam/GetChapterInfo/`。

#### 1.2 根据章节获取题目信息

使用 `[FromBody]` 来接收前端传来的章节信息，然后拿到数据库中的值，返回给前端：

```cs
// 获取指定章节的所有题目
[HttpPost("GetQuestionByChapter")]
public List<Question> GetQuestionByChapter([FromBody] string chapter, [FromBody] string section)
{
    List<Question> list = new List<Question>();
    list = DC.Set<Question>().Where(x => x.Chapter.Name == chapter && x.Section.Name == section).ToList();
    return list;
}
```

#### 1.3 获取题目的图片

前端传过来题目的 ID，根据这个 ID 去拿到数据库中对应的图片，然后返回图片的二进制信息，再由前端将这个二进制信息转为图片：

```cs
public class PhotoRequest
{
    public string PhotoId { get; set; }
}
// 获取题目图片
[HttpPost("GetQuestionPhoto")]
public IActionResult GetQuestionPhoto([FromBody] PhotoRequest request)
{
    var fileAttachment = DC.Set<FileAttachment>().Single(x => x.ID.ToString() == request.PhotoId);

    // 根据文件类型设置 Content-Type 头
    string contentType = "image/png"; // 根据你的实际文件类型进行调整
    Response.Headers.Add("Content-Type", contentType);
    // 返回文件数据
    return File(fileAttachment.FileData, contentType);
}
```

因为前端在请求的时候，传过来的 ID 并不是一个简单的字符串，而是一个 json 对象，所以要使用一个对应这个 json 对象的格式的对象来接收。

### 2. 真题训练

和章节训练的API类似：

```cs
[Route("/RealExam/")]
public class _RealExamController : BaseController
{
}
```

#### 2.1 获取年度信息

年度的存储是数据字典的形式，数据库中会有一个 DicDef 表，这个表里放着定义的所有的数据字典，还有一个 DicField 表，这个表里记录着所有数据字典的数据，有个字段是指明了这条数据属于的数据字典。

所以先找到要的数据字典的 ID，然后过根据这个 ID 拿到这个数据字典里的所有数据，返回给前端：

```cs
[HttpGet("GetYearInfo")]
public List<string> GetYearInfo()
{
    var YearId = DC.Set<DicDef>().Single(x => x.DicName == "YearDic").ID;
    var YearList = DC.Set<DicField>().Where(x => x.DicDefId == YearId).OrderBy(x => x.DicFieldName).Select(x => x.DicFieldName).ToList();
    return YearList;
}
```

#### 2.2 获取类型信息

类型也是用的数据字典保存的：

```cs
[HttpGet("GetTypeInfo")]
public List<string> GetTypeInfo()
{
    var TypeId = DC.Set<DicDef>().Single(x => x.DicName == "QuestionTypeDic").ID;
    var TypeList = DC.Set<DicField>().Where(x => x.DicDefId == TypeId).OrderBy(x => x.DicFieldName).Select(x => x.DicFieldName).ToList();
    return TypeList;
}
```

#### 2.3 获取年度题目信息

前台传过来指定的年度和类型，然后拿到数据库中对应的年度和类型的 ID，再用这两个 ID 去题目表中去找，最后返回给前端：

```cs
[HttpPost("GetQuestionByYear")]
public List<Question> GetQuestionByYear([FromBody] string year, [FromBody] string type)
{
    List<Question> list = new List<Question>();
    var yearId = DC.Set<DicField>().Single(x => x.DicFieldName == year).ID;
    var typeId = DC.Set<DicField>().Single(x => x.DicFieldName == type).ID;
    list = DC.Set<Question>().Where(x => x.YearId == yearId && x.QuestionTypeId == typeId).ToList();
    return list;
}
```

## 三、实现前端页面

打开 Areas/StudentArea/Views/\_Default 下的 ChapterExam.cshtml 和 RealExam.cshtml，这是章节训练和真题训练的页面，将框架自己生成的代码删除掉，只留一下一个关闭按钮：

```html
<wt:closebutton></wt:closebutton>
```

这个关闭按钮可以将当前这个 tab 页给关闭掉。然后使用纯 HTML 代码写页面。

### 1. 整体布局

![image-20231210174014916](https://gitee.com/LowProfile666/image-bed/raw/master/img/202312101740973.png)

```html
<div id="selectArea">
    <label for="firstSelect" class="lable">章：</label>
    <select id="firstSelect" onchange="firstSelectChange()"></select>
    <label for="secondSelect" class="lable">节：</label>
    <select id="secondSelect" onchange="updateContent()"></select>
</div>
<div id="questionNumber">
    <div id="questionNumberInfo"></div>
    <div id="questionNumberInput">
        <label for="jumpToQuestion">跳转至题号:</label>
        <input type="text" id="jumpToQuestion" placeholder="题号">
        <button onclick="jumpToQuestion()">跳转</button>
    </div>
</div>
<hr />
<div id="contentArea">
    <div id="summeryArea"></div>
    <div id="questionArea"></div>
    <div id="parseArea"></div>
    <div id="buttonArea">
        <button type="button" class="button" id="preBtn" onclick="preQuestion()">上一题</button>
        <button type="button" class="button" id="submitBtn" onclick="submit()">提交</button>
        <button type="button" class="button" id="nextBtn" onclick="nextQuestion()">下一题</button>
        <button type="button" class="button" id="parseBtn" onclick="showParse()">查看解析</button>
    </div>
</div>
<hr />
<wt:closebutton></wt:closebutton>
```

### 2. 前台逻辑

```js
<div id="selectArea">
    <label for="firstSelect" class="lable">章：</label>
    <select id="firstSelect" onchange="firstSelectChange()">
    </select>

    <label for="secondSelect" class="lable">节：</label>
    <select id="secondSelect" onchange="updateContent()">
    </select>
</div>
<div id="questionNumber">
    <div id="questionNumberInfo">

    </div>
    <div id="questionNumberInput">
        <label for="jumpToQuestion">跳转至题号:</label>
        <input type="text" id="jumpToQuestion" placeholder="题号">
        <button onclick="jumpToQuestion()" id="jumpBtn">跳转</button>
    </div>

</div>
<hr />
<div id="contentArea">
    <div id="summeryArea"></div>
    <div id="questionArea"></div>
    <div id="parseArea"></div>
    <div id="buttonArea">
        <button type="button" class="button" id="preBtn" onclick="preQuestion()">上一题</button>
        <button type="button" class="button" id="submitBtn" onclick="submit()">提交</button>
        <button type="button" class="button" id="nextBtn" onclick="nextQuestion()">下一题</button>
        <button type="button" class="button" id="parseBtn" onclick="showParse()">查看解析</button>
    </div>
</div>
<hr />

<script>
    let cInfo = new Map();
    let qInfo = {
        q: [],
        idx: 0,
    };
    var userAnswers = new Map();
    var isSubmit = false;
    var isNull = false;
    var isParse = false;
    var preBtn = document.getElementById("preBtn");
    var nextBtn = document.getElementById("nextBtn");
    var submitBtn = document.getElementById("submitBtn");
    var parseBtn = document.getElementById("parseBtn");
    var jumpBtn = document.getElementById("jumpBtn");
    var firstSelect = document.getElementById("firstSelect");
    var secondSelect = document.getElementById("secondSelect");
    var questionNumberInput = document.getElementById("questionNumberInput");
    
    // 拿到所有的章节信息，并显示第一章和第一节
    function getBasicData() {
        addKeyDownListener();
        $.ajax({
            url: "/ChapterExam/GetChapterInfo/",
            type: "get",
            success: function (resp) {
                // 将章节信息对应保存起来
                resp.forEach((c, i) => {
                    var sections = [];
                    c.SectionList.forEach((s, j) => {
                        sections.push(s);
                    });
                    cInfo.set(c.Name, sections);
                });

                // 设置章下拉框的内容
                var html = ``, idx = 1;
                for (var name of cInfo.keys()) {
                    html += `<option value="` + name + `">第` + idx++ + `章：` + name + `</option>`;
                }
                $("#firstSelect").html(html);

                // 设置第一章的节下拉框的内容
                html = ``, idx = 1;
                for (var name of cInfo.get(resp[0].Name)) {
                    html += `<option value="` + name + `">第` + idx++ + `节：` + name + `</optino>`;
                }
                $("#secondSelect").html(html);

                // 设置题号区域的信息
                setQuestionNumber();

                // 设置题目页面第一章第一节的第一题
                getQuestion(resp[0].Name, resp[0].SectionList[0]);
                showBtns();
            }
        });
    }
    // 设置题号区域的信息
    function setQuestionNumber() {
        var sum = qInfo.q.length;
        var cur = qInfo.idx + 1;
        if (sum == 0) cur = 0;
        var html = `<span>总题数: ` + sum + `</span>`;
        html += `<span>当前题号: ` + cur + `</span>`;
        $("#questionNumberInfo").html(html);
    }
    // 空页
    function setNullPage() {
        isNull = true;
        var html = `<h1 style="margin-top:30px; margin-bottom:30px;">当前章节下没有题目！</h1>`;
        $("#questionArea").html(html);
        qInfo.idx = 0;
        qInfo.q = [];
        setQuestionNumber();
        showBtns();
    }
    // 根据章节，获取题目
    function getQuestion(c, s) {
        $.ajax({
            url: "/ChapterExam/GetQuestionByChapter/",
            type: 'post',
            data: {
                chapter: c,
                section: s,
            },
            success: function (resp) {
                // 当前章节没有题目时
                if (resp.length == 0) {
                    setNullPage();
                    return;
                }
               
                // 将题目保存到本地
                qInfo.q = resp;
                qInfo.idx = 0;

                // 渲染题目
                showQuestion(resp[0], 0);
            },
        });
    }
    // 渲染按钮
    function showBtns() {
        nextBtn.style.display = "";
        preBtn.style.display = "";
        submitBtn.style.display = "";
        parseBtn.style.display = "";
        questionNumberInput.style.display = "";
        // 空页时，不显示按钮区域
        if (isNull) {
            document.getElementById("buttonArea").style.display = "none";
            questionNumberInput.style.display = "none";
            isNull = false;
            return;
        } 
        document.getElementById("buttonArea").style.display = "";
        // 提交后，只显示查看解析按钮
        if (isSubmit) {
            nextBtn.style.display = "none";
            preBtn.style.display = "none";
            submitBtn.style.display = "none";
            parseBtn.style.display = "";
            questionNumberInput.style.display = "none";
            isSubmit = false;
            return;
        }
        parseBtn.style.display = "none";
        // 显示解析信息时不显示提交
        if (isParse) {
            submitBtn.style.display = "none";
            nextBtn.style.display = "";
            preBtn.style.display = "";
        }
        // 没有下一题时不显示下一题按钮
        if (qInfo.q.length <= 1 || qInfo.idx >= qInfo.q.length - 1)
            nextBtn.style.display = "none";
        else nextBtn.style.display = "";
        // 没有上一题时不显示上一题按钮
        if (qInfo.q.length <= 0 || qInfo.idx == 0)
            preBtn.style.display = "none";
        else preBtn.style.display = "";
    }
    // 章节改变时
    function firstSelectChange() {
        var c = document.getElementById('firstSelect').value;
        var html = ``, idx = 1;
        for (var name of cInfo.get(c)) {
            html += `<option value="` + name + `">第` + idx++ + `节：` + name + `</optino>`;
        }
        $("#secondSelect").html(html);
        updateContent();
    }
    // 获取题目图片
    function getQuestionPhoto(photoId, imgId) {
        fetch("/ChapterExam/GetQuestionPhoto/", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                photoId: photoId,
            }),
        })
            .then(response => response.blob())
            .then(blob => {
                let imageUrl = URL.createObjectURL(blob);
                document.getElementById(imgId).src = imageUrl;
            })
            .catch(error => console.error('Error fetching image:', error));
    }
    // 渲染题目
    function showQuestion(q, idx, disabled) {

        var html = '<h4 style="line-height:40px">' + (idx + 1) + `、` + q.Text + `</h4>`;
        html += `<img id="questionPhoto" src=""></img>`
        html += `<div style = "line-height:20px;" >`;
        html += `<input type="radio" id="CA" value="A" name="` + 'c' + idx + `" ` + disabled + `/><label for="CA"> &nbsp;&nbsp;A：` + q.OptionA + `<br /><img src="" id="CAPhoto" /></label><br />`;
        html += `<input type="radio" id="CB" value="B" name="` + 'c' + idx + `" ` + disabled + `/><label for="CB"> &nbsp;&nbsp;B：` + q.OptionB + `<br /><img src="" id="CBPhoto" /></label><br />`;
        html += `<input type="radio" id="CC" value="C" name="` + 'c' + idx + `" ` + disabled + `/><label for="CC"> &nbsp;&nbsp;C：` + q.OptionC + `<br /><img src="" id="CCPhoto" /></label><br />`;
        html += `<input type="radio" id="CD" value="D" name="` + 'c' + idx + `" ` + disabled + `/><label for="CD"> &nbsp;&nbsp;D：` + q.OptionD + `<br /><img src="" id="CDPhoto" /></label><br />`;
        html += `<input type="radio" id="CE" value="E" name="` + 'c' + idx + `" ` + disabled + `/><label for="CE"> &nbsp;&nbsp;E：` + q.OptionE + `<br /><img src="" id="CEPhoto" /></label><br />`;
        html += `</div>`;
        $("#questionArea").html(html);

        if(q.PhotoId !== undefined) {
            getQuestionPhoto(q.PhotoId, "questionPhoto");
        }

        if (q.PhotoAId !== undefined) {
            getQuestionPhoto(q.PhotoAId, "CAPhoto");
        }

        if (q.PhotoBId !== undefined) {
            getQuestionPhoto(q.PhotoBId, "CBPhoto");
        }

        if (q.PhotoCId !== undefined) {
            getQuestionPhoto(q.PhotoCId, "CCPhoto");
        }

        if (q.PhotoDId !== undefined) {
            getQuestionPhoto(q.PhotoDId, "CDPhoto");
        }

        if (q.PhotoEId !== undefined) {
            getQuestionPhoto(q.PhotoEId, "CEPhoto");
        }
        setQuestionNumber();
        showBtns();
    }
    // 根据下拉框的变化来更改题目
    function updateContent() {
        isParse = false;
        // 获取第一个下拉框的值
        var c = firstSelect.value.split("：");

        // 获取第二个下拉框的值
        var s = secondSelect.value.split("：");

        // 获取显示内容的区域
        var questionArea = document.getElementById('questionArea');

        // 根据下拉框的值更新内容
        getQuestion(c, s)
        userAnswers.clear();

        $("#parseArea").html("");
        showBtns();

    }
    // 获取当前题目的用户选的答案
    function getAnswer(idx) {
        var radios = document.getElementsByName('c'+idx);
        for (var i = 0; i < 5; i++) {
            if (radios[i].checked) {
                return radios[i].value;
            }
        }
    }
    // 单选框上显示用户选的答案
    function setRadios(idx) {
        var radios = document.getElementsByName('c' + idx);
        for (var i = 0; i < 5; i++) {
            if (radios[i].value === userAnswers.get(idx)) {
                radios[i].checked = "true";
                return;
            }
        }
    }
    // 下一题
    function nextQuestion() {
        // 先保存当前选的答案
        userAnswers.set(qInfo.idx, getAnswer(qInfo.idx));

        ++qInfo.idx;
        showQuestion(qInfo.q[qInfo.idx], qInfo.idx);
        setRadios(qInfo.idx);
        // 显示解析
        if (isParse) {
            showParse(qInfo.idx);
        }
    }
    // 上一题
    function preQuestion() {
        userAnswers.set(qInfo.idx, getAnswer(qInfo.idx));
        --qInfo.idx
        showQuestion(qInfo.q[qInfo.idx], qInfo.idx);
        setRadios(qInfo.idx);
        if (isParse) {
            showParse(qInfo.idx);
        }
    }
    // 提交题目
    function submit() {
        isSubmit = true;
        userAnswers.set(qInfo.idx, getAnswer(qInfo.idx));
        var total = 0, correct = 0, score = 0;
        for (var i = 0; i < userAnswers.size; i++) {
            var a = qInfo.q[i].Answer;
            var b = userAnswers.get(i);
            if (b !== undefined) {
                total++;
                if (a === b) {
                    correct++;
                    score++;
                }
            }
        }
        var html = `<h4>总做题数：` + total
            + `</h4><h4>正确数：` + correct
            + `</h4><h4>错误数：` + (total - correct)
            + `</h4><h4>总得分：` + score + `</h4>`;
        html += `<hr/>`;
        $("#questionArea").html(html);
        qInfo.idx = 0;
        showBtns();
    }
    // 渲染解析页面
    function showParse() {
        isParse = true;
        showQuestion(qInfo.q[qInfo.idx], qInfo.idx, "disabled");
        setRadios(qInfo.idx);
        var a = userAnswers.get(qInfo.idx);
        var b = qInfo.q[qInfo.idx].Answer;
        if (a === undefined)    a = "";
        var html = `<p>你的答案：` + a + `</p><p>正确答案：` + b + `</p>`;
        html += `<p>` + qInfo.q[qInfo.idx].Parse + `</p><img src="" id="parsePhoto"/>`;

        if (qInfo.q[qInfo.idx].PhotoParseId !== undefined) {
            getQuestionPhoto(qInfo.q[qInfo.idx].PhotoParseId, "parsePhoto");
        }
        $("#parseArea").html(html);
        setQuestionNumber();
        showBtns();
        isSubmit = true;
    }
    function jumpToQuestion() {
        // 获取输入的题号并进行相应的处理
        var num = document.getElementById("jumpToQuestion").value;
        if (num === "") return;  // 当前没有输入题号
        if (num > qInfo.q.length) {
            num = qInfo.q.length;
            document.getElementById("jumpToQuestion").value = qInfo.q.length;
        }

        // 这里可以添加具体的跳转逻辑，例如更新题目内容等
        qInfo.idx = num - 1;
        if (isParse) showParse();
        else showQuestion(qInfo.q[qInfo.idx], qInfo.idx);

        document.getElementById("jumpToQuestion").value = "";
    }
    getBasicData();

    var keydownHandler;
    // 添加事件监听器的函数
    function addKeyDownListener() {
        removeKeyDownListener();
        keydownHandler = function (event) {
            // 获取按下的键的键码
            var keyCode = event.keyCode;
            const elements = document.querySelectorAll('.layui-this');
            var cur = elements[0].dataset["name"];
            // 判断按下的是哪个键
            if (cur === "章节练习") {
                switch (keyCode) {
                    case 65: // 键码 65 对应 'a'
                        if (!isParse) document.getElementById("CA").checked = true;
                        break;
                    case 66: // 键码 66 对应 'b'
                        if (!isParse) document.getElementById("CB").checked = true;
                        break;
                    case 67: // 键码 67 对应 'c'
                        if (!isParse) document.getElementById("CC").checked = true;
                        break;
                    case 68: // 键码 68 对应 'd'
                        if (!isParse) document.getElementById("CD").checked = true;
                        break;
                    case 69: // 键码 69 对应 'e'
                        if (!isParse) document.getElementById("CE").checked = true;
                        break;
                    case 38: // 键码 38 对应向上箭头
                        event.preventDefault();
                        if (qInfo.idx > 0)
                            preQuestion();
                        break;
                    case 40: // 键码 40 对应向下箭头
                        event.preventDefault();
                        if (qInfo.idx < qInfo.q.length - 1)
                            nextQuestion();
                        break;
                    case 13:
                        if (!isSubmit)
                            submit();
                        break;
                    default:
                        // 其他键
                        break;
                }
            }
        }
        document.addEventListener("keydown", keydownHandler);
    }

    // 移除事件监听器的函数
    function removeKeyDownListener() {
        if (keydownHandler) {
            document.removeEventListener("keydown", keydownHandler);
            keydownHandler = null;
        }
    }
    // 限制题号输入框只能输入数字
    document.getElementById('jumpToQuestion').addEventListener('keydown', function (e) {
        // 允许数字、删除键、退格键
        if (!(e.key === '0' || e.key === '1' || e.key === '2' || e.key === '3' || e.key === '4' || e.key === '5' || e.key === '6' || e.key === '7' || e.key === '8' || e.key === '9' || e.key === 'Backspace' || e.key === 'Delete')) {
            e.preventDefault();
        }
    });
</script>
```

## 四、更换网站logo等

登录页面的左上角的 logo 在主项目的 Views/Login/Login.cshtml 中修改，在该页面的 <title> 中修改当前网站的标题，

```html
<header class="login-header">
    <img src="/images/logo.png" alt="" height="48">
</header>
```

这一块就是登录页面左上角的 logo 图片，所以只需要将新的 logo 图片复制到 wwwroot/images 下即可。

登录进去后的主页面左侧的顶部的 logo 在 Views/Home/Layout.cshtml 页面中修改，找到代码中的侧边菜单区域，修改如下：

```html
<div class="layui-logo" lay-href="">
    <span><img src="~/layuiadmin/style/res/logo1.png" style="margin-right:5px;" />海通教育</span>
</div>
```

这个 logo1 就是新的 logo 图片，需要放在 wwwroot/layuiadmin/style/res 下。

还需要修改所有页面的标题，要在 Views/Shared/\_Layout.cshtml 中修改，直接将 <title> 的内容换掉即可。

## 五、设置主页

设置根据不同登录用户的角色来显示不同的主页。

在 Views/Home/FrontPage.cshtml 中，删除主页一些不用的代码，只留下快捷方式那一块代码，然后将快捷方式改为自己想要的快捷方式，再通过用户的角色 ID 来决定显示哪些快捷方式。

获取到用户的所有角色 ID ，并把所有的角色ID拿到，和对应的快捷方式链接一起放入一个字典中：

```cs
@{
    var code1 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "管理员").RoleCode;
    var code2 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "超级管理员").RoleCode;
    var code3 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "护士").RoleCode;
    var code4 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "初级护师").RoleCode;
    var code5 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "中级护师").RoleCode;
    var code6 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "考公考编").RoleCode;
    var code7 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "其他类").RoleCode;
    var code8 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "学历提升-专科").RoleCode;
    var code9 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "学历提升-本科").RoleCode;
    var code10 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "学历提升-研究生").RoleCode;
    var userCode = Model.DC.Set<FrameworkUserRole>().Where(x => x.UserCode == Model.LoginUserInfo.ITCode).ToList();
    Dictionary<string, string[]> hrefs = new Dictionary<string, string[]>();
    hrefs.Add(code2, new string[] { "_Admin/FrameworkUser/Index?用户?layui-icon-username",
                                   "questionbank/chapter/index?章管理?layui-icon-date",
                                   "questionbank/section/index?节管理?layui-icon-layer",
                                   "questionbank/question/index?题目管理?layui-icon-template-1"});
    hrefs.Add(code1, new string[] { "_Admin/FrameworkUser/Index?用户?layui-icon-username",
                                   "questionbank/chapter/index?章管理?layui-icon-date",
                                   "questionbank/section/index?节管理?layui-icon-layer",
                                   "questionbank/question/index?题目管理?layui-icon-template-1"});
    hrefs.Add(code3, new string[] { "studentarea/_default/chapterexam?章节训练?layui-icon-tabs",
                                   "studentarea/_default/realexam?真题训练?layui-icon-tabs"});
    hrefs.Add(code4, new string[] { "studentarea/_default/PrimayCareExam?初级护师?layui-icon-tabs"});
    hrefs.Add(code5, new string[] { "studentarea/_default/MiddelCareExam?中级护师?layui-icon-tabs"});
    hrefs.Add(code6, new string[] { "studentarea/_default/CivilServant_Written?笔试?layui-icon-tabs",
                                   "studentarea/_default/CivilServant_Interview?面试?layui-icon-tabs" });
    hrefs.Add(code7, new string[] { "studentarea/_default/Other_Public?其他类-公共课程?layui-icon-tabs",
                                   "studentarea/_default/Other_Major?其他类-专业课程?layui-icon-tabs" });
    hrefs.Add(code8, new string[] { "studentarea/_default/EducationPromotion_Junior_Public?专科-公共课程?layui-icon-tabs",
                                   "studentarea/_default/EducationPromotion_Junior_Major?专科-专业课程?layui-icon-tabs" });
    hrefs.Add(code9, new string[] { "studentarea/_default/EducationPromotion_Undergraduate_Public?本科-公共课程?layui-icon-tabs",
                                   "studentarea/_default/EducationPromotion_Undergraduate_Major?本科-专业课程?layui-icon-tabs" });
    hrefs.Add(code10, new string[] {"studentarea/_default/EducationPromotion_Graduate_Public?研究生-公共课程?layui-icon-tabs",
                                    "studentarea/_default/EducationPromotion_Graduate_Major?研究生-专业课程?layui-icon-tabs" });
    var res = new System.Text.StringBuilder();
}
```

然后通过当前登录用户的角色 ID 动态显示对应的快捷方式：

```html
<div class="layui-carousel layadmin-carousel layadmin-shortcut">
    <div carousel-item>
        <ul class="layui-row layui-col-space10">
            @{
                foreach (var uc in userCode)
                {
                    foreach (var item in hrefs[uc.RoleCode])
                    {
                        string[] s = item.Split("?");
                        res.Append($@"<li class='layui-col-xs3'>");
                        res.Append($@"<a lay-href='{s[0]}'>");
                        res.Append($@"<i class='layui-icon {s[2]}'></i>");
                        res.Append($@"<cite>{s[1]}</cite></a></li>");
                    }
                }
            }
            @Html.Raw(res.ToString())
        </ul>
    </div>
</div>
```

## 六、设置修改页面角色的显示

当有一个管理员角色时，当他创建用户或者审批用户时，不需要将 “超级管理员”和“管理员” 这两个角色显示出来，因为他只能创建用户一种角色，所以在显示页面的时候就不要显示这个角色。

有显示到这个角色的页面就是修改用户的页面，和审批用户的页面，它们的数据来源是：

在 Areas/Controllers/\_FrameworkUserApiController.cs 中，找到 GetFrameworkRoles 方法，修改以下代码：

```cs
if (rv != null && rv.Value is string && rv.Value != null)
{
    users = System.Text.Json.JsonSerializer.Deserialize<List<ComboSelectListItem>>(rv.Value.ToString());
}
else if (rv != null && rv.Value is List<ComboSelectListItem> c)
{
    if (Wtm.LoginUserInfo.ITCode != "admin")  // 管理员角色不能被显示出来
    {
        c.Remove(c.Single(x => x.Text == "超级管理员"));
        c.Remove(c.Single(x => x.Text == "管理员"));
    }
    users = c;
}
```

## 七、用户列表不显示admin

在 FrameworkUserListVM.cs 中，在 GetSearchQuery 方法中，添加一句 Where 条件即可：

```cs
public override IOrderedQueryable<FrameworkUser_View> GetSearchQuery()
{
    var query = DC.Set<FrameworkUser>()

        .CheckContain(Searcher.ITCode, x=>x.ITCode)
        .CheckContain(Searcher.Name, x=>x.Name)
        .CheckEqual(Searcher.IsValid, x=>x.IsValid)
        .Where(x => x.ITCode != "admin")
        .Select(x => new FrameworkUser_View
                {
                    ID = x.ID,

                    FrameworkUser_ITCode = x.ITCode,
                    FrameworkUser_Name = x.Name,
                    FrameworkUser_Gender = x.Gender,
                    FrameworkUser_CellPhone = x.CellPhone,
                    FrameworkUser_Role = DC.Set<FrameworkUserRole>().Where(y => y.UserCode == x.ITCode)
                        .Join(DC.Set<FrameworkRole>(), ur => ur.RoleCode, role => role.RoleCode, (ur, role) => role).Select(y0=>y0.RoleName).ToSepratedString(null,","),
                    FrameworkUser_Group = DC.Set<FrameworkUserGroup>().Where(y => y.UserCode == x.ITCode)
                        .Join(DC.Set<FrameworkGroup>(), ug => ug.GroupCode, group => group.GroupCode, (ug, group) => group ).Select(y0=>y0.GroupName).ToSepratedString(null,","),
                    FrameworkUser_IsValid = x.IsValid,
                    FrameworkUser_Photo = x.PhotoId,
                })
        .OrderBy(x => x.ID);
    return query;
}
```

## 八、导入用户信息

在 FrameworkUser 类中添加了一个不保存在数据库中的属性 Role，表示角色，因为从前端导出来的数据是可以按角色分好的，所以在本系统中导入的时候指定好角色会很方便，

```c#
[NotMapped]
public string Role { get; set; } // 用于导入时，写入角色
```

然后在对应的 FrameworkUserImportVM 中，修改模板，修改 BatchSaveData 方法：

```c#
public override bool BatchSaveData()
{
    SetEntityList();
    bool ok = true;  // 正确导入标志
    for (var i = 0; i < EntityList.Count; i++)
    {
        var item = EntityList[i];
        var user = DC.Set<FrameworkUser>().SingleOrDefault(x => x.ITCode == item.ITCode);
        if (user != null)  // 数据库中有当前用户
        {
            ok = false;
            ErrorListVM.EntityList.Add(new ErrorMessage { Message = "用户的账号重复！", Index = (i + 2) });  // 加2是因为下标从0开始且有一行表头
            continue;
        }
        item.IsValid = true;
        item.Password = Utils.GetMD5String(item.Password);
        var role = DC.Set<FrameworkRole>().SingleOrDefault(x => x.RoleName == item.Role);
        if (role == null)  // 数据库中没有当前角色
        {
            ok = false;
            ErrorListVM.EntityList.Add(new ErrorMessage { Message = "用户的角色输入错误！", Index = (i+2) });  // 加2是因为下标从0开始且有一行表头
            continue;
        }
        FrameworkUserRole fur = new FrameworkUserRole
        {
            UserCode = item.ITCode,
            RoleCode = role.RoleCode
        };
        DC.Set<FrameworkUserRole>().Add(fur);
    }
    if (ok)
        return base.BatchSaveData();
    return false;
}
```

## 九、设置用户列表搜索框

由于每个用户都会有角色，所以在用户的主页面添加一个角色的下拉框用于搜索。

先在对应的 FrameworkUserSearcher 里添加两个属性：

```c#
[Display(Name = "_Model._FrameworkUser._Role")]
public string Role { get; set; }  // 用作下拉框绑定的字段
public List<string> RoleList { get; set; }  // 下拉框的值的来源

protected override void InitVM()
{
    RoleList = DC.Set<FrameworkRole>().Where(x => x.RoleName != "超级管理员").Select(x => x.RoleName).ToList();  // 初始化赋值，不显示超级管理员的角色
    // 二级管理员只能搜索用户角色
    var roleCode = DC.Set<FrameworkUserRole>().Single(x => x.UserCode == Wtm.LoginUserInfo.ITCode).RoleCode;
    var roleName = DC.Set<FrameworkRole>().Single(x => x.RoleCode == roleCode).RoleName;
    if (roleName == "二级管理员")
    {
        RoleList.Remove("一级管理员");
        RoleList.Remove("二级管理员");
    }
}
```

然后再前端添加一个下拉框：

```html
<wt:combobox field="Searcher.Role" items="Searcher.RoleList" empty-text="@Localizer["Sys.All"]"  />
```

最后在 FrameworkUserListVM 中修改搜索条件：

```c#
public override IOrderedQueryable<FrameworkUser_View> GetSearchQuery()
{
    var query = DC.Set<FrameworkUser>()

        .CheckContain(Searcher.ITCode, x => x.ITCode)
        .CheckContain(Searcher.Name, x => x.Name)
        .CheckEqual(Searcher.IsValid, x => x.IsValid)
        .Where(x => x.ITCode != "admin")
        .Select(x => new FrameworkUser_View
                {
                    ID = x.ID,

                    FrameworkUser_ITCode = x.ITCode,
                    FrameworkUser_Name = x.Name,
                    FrameworkUser_Gender = x.Gender,
                    FrameworkUser_CellPhone = x.CellPhone,
                    FrameworkUser_Role = DC.Set<FrameworkUserRole>().Where(y => y.UserCode == x.ITCode)
                        .Join(DC.Set<FrameworkRole>(), ur => ur.RoleCode, role => role.RoleCode, (ur, role) => role).Select(y0 => y0.RoleName).ToSepratedString(null, ","),
                    FrameworkUser_Group = DC.Set<FrameworkUserGroup>().Where(y => y.UserCode == x.ITCode)
                        .Join(DC.Set<FrameworkGroup>(), ug => ug.GroupCode, group => group.GroupCode, (ug, group) => group).Select(y0 => y0.GroupName).ToSepratedString(null, ","),
                    FrameworkUser_IsValid = x.IsValid,
                    FrameworkUser_Photo = x.PhotoId,

                })
        .OrderBy(x => x.ID);
    // 用户列表中，对于二级管理员，不显示管理员，只显示全部用户
    var roleCode = DC.Set<FrameworkUserRole>().Single(x => x.UserCode == Wtm.LoginUserInfo.ITCode).RoleCode;
    var roleName = DC.Set<FrameworkRole>().Single(x => x.RoleCode == roleCode).RoleName;
    if (roleName == "二级管理员")
    {
        var temp = query.ToList();
        query = temp.Where(x => x.FrameworkUser_Role != "二级管理员" && x.FrameworkUser_Role != "一级管理员").AsQueryable().OrderBy(x => x.ID);
    }
    if (Searcher.Role == "") return query;  // 没有搜索角色时直接返回
    var t = query.ToList();
    var res = t.Where(x => x.FrameworkUser_Role == Searcher.Role).AsQueryable().OrderBy(x => x.ID);
    return res;
}
```

因为直接在第一句代码中添加条件的话，EF翻译不成功，会报错，所以先使用 ToList() 终结方法，然后再重新翻译一句SQL，达到效果。

# 更新

![63ae9e7a823bb874917858b8a9f63cd](https://gitee.com/LowProfile666/image-bed/raw/master/img/202401220833932.png)

## 新建模块与题目类型关系

使用一张中间表QuestionType，来记录每个模块中题目所有的类型（考核科目）。

```cs
[Table("QuestionType")]
public class QuestionType : TopBasePoco
{
    [Display(Name = "模块名称")]
    public String ModelName { get; set; }
    [Display(Name = "类型名称")]
    public String TypeName { get; set; }
}
```

然后在DataContext中添加这张表：

```cs
 public DbSet<QuestionType> QuestionTypes { get; set; }
```

然后要在数据库中建好对应的这张表。

然后启动项目调试模式，右上角代码生成器，生成对应的代码。

在Areas/StudentArea/Controllers下新建一个\_PrimaryCareController，这个和自动生成的Controller有点区别，就是自动生成的Controller用于增删改查等等，自己创建在Areas/StudentArea的Controller主要用于定义一些服务前端的接口，比如：

```cs
[Route("/PrimaryExam")]
public class _PrimaryExamController : BaseController
{
    [HttpGet("GetQuestion")]
    public List<Question> GetQuestion([FromBody] string type)
    {
        List<Question> res = new List<Question>();
        var typeId = DC.Set<DicField>().Single(x => x.DicFieldName == type).ID;
        res = DC.Set<Question>().Where(x => x.QuestionTypeId == typeId).ToList();
        return res;
    }
}
```



## 新建初级护师题库

### 先新建Model

在Model层里的QuestionBank文件夹 下，新建一个文件夹PrimaryCareExam和NurseExam，将原来的Chapter、Section、QUestion全部放在NurseExam文件夹下，然后新建的初级护师的model就放在PrimaryCareExam文件夹下。

新建三个model，对应初级护师的章、节、题目，真题年份直接使用之前有的字典就可以了。具体代码可以从之前的model里拷贝过来，注意要将 `Table()` 注解的里的值改为数据库中表的名字。

题目的类型不再使用字典，而是直接使用字符串的形式。

```c#

```



### 创建数据库表

然后在数据库中创建对应的表PrimaryCare_Chapters、PrimaryCare_Sections、PrimaryCare_Questions，也可以直接从之前的表中直接复制过来，记得需要改一下PrimaryCare_Questions表涉及到的外键信息。

### 生成代码

创建好model后，需要现在DataContext文件中添加对应的属性，然后启用项目的调试模式，在右上角点击代码生成器，然后分别选择新建的三个模型，生成对应的代码，然后在Areas/QuestionBank/Controllers下新建一个文件夹PrimaryCareExam，将生成的对应的三个Controller都放这下面。

### 编写刷题页面

在StudentArea/Views/\_Default下新建一个文件夹PrimaryCare，用来放初级护师相关的刷题页面，注意：这里改了页面，需要在\_DefaultController中对应的方法里，修改一下返回的页面的位置：

```cs
[ActionDescription("初级护师-真题练习", IsPage = true)]
public ActionResult PrimaryCareExam_Real()
{
    var vm = Wtm.CreateVM<NurseExaminationSystem.ViewModel.QuestionBank.PrimaryCare_QuestionVMs.PrimaryCare_QuestionVM>();
    // return PartialView(vm);
    return PartialView("/Areas/StudentArea/Views/_Default/PrimaryCare/PrimaryCareExam_Real.cshtml", vm);
}

[ActionDescription("初级护师-章节练习", IsPage = true)]
public ActionResult PrimaryCareExam_Chapter()
{
    var vm = Wtm.CreateVM<NurseExaminationSystem.ViewModel.QuestionBank.PrimaryCare_QuestionVMs.PrimaryCare_QuestionVM>();
    // return PartialView(vm);
    return PartialView("/Areas/StudentArea/Views/_Default/PrimaryCare/PrimaryCareExam_Chapter.cshtml", vm);
}
```

### 将类型改为下拉框

默认生成的代码，页面上，题目类型这一个是一个文本输入框，因为他是一个字符串类型，但是应该是一个下拉框的样子供用户选择，所以要改为下拉框。

#### index.html

主页要改的地方是搜索条件里的题目类型，首先将控件改为 combobox，

```c#
// Index.cshtml
<wt:combobox field="Searcher.Type" items="Searcher.AllTypes"/>
```

然后去对应的 Searcher 中定义相关的属性，用来显示：

```c#
// PrimaryCare_QuestionSearcher.cs
[Display(Name = "题目类型")]
public string Type { get; set; }
public List<ComboSelectListItem> AllTypes { get; set; }
```

并且要在 InitVM 方法中进行初始化：

```c#
protected override void InitVM()
{
    AllTypes = DC.Set<QuestionType>().Where(x => x.ModelName == "中级护师").GetSelectListItems(Wtm, y => y.TypeName);
}
```

#### Creat.cshtml

创建题目的时候需要选择类型，首先先改前台页面：

```c#
<wt:combobox field="Entity.Type" items="AllTypes" />
```

然后需要到对应的 PrimaryCare_QuestionVM 中去添加一个 AllTypes 属性：

```c#
public List<ComboSelectListItem> AllTypes { get; set; }
```

同样要在 InitVM 方法中初始化它：

```c#
protected override void InitVM()
{
    AllTypes = DC.Set<QuestionType>().Where(x => x.ModelName == "初级护师").GetSelectListItems(Wtm, y => y.TypeName);
}
```

然后这样在添加的时候，选择的类型会直接传值ID，而不是名称，所以需要在对应的Controller中的Create方法中进行一些小的修改：

```c#
public ActionResult Create(PrimaryCare_QuestionVM vm)
{
    if (Searcher.Type != "" && Searcher.Type != null)
        vm.Entity.Type = DC.Set<QuestionType>().Single(x => x.ID.ToString() == vm.Entity.Type).TypeName;
    // ……
}
```

还有在按条件搜索的时候，前台传过来的值也是ID，所以也需要转一下，因为是按照题目的类型进行搜索，而题目的类型是一个字符串，其他的代码都不需要变：

```c#
public override IOrderedQueryable<PrimaryCare_Question_View> GetSearchQuery()
{
    if (Searcher.Type != "" && Searcher.Type != null)
        Searcher.Type = DC.Set<QuestionType>().Single(x => x.ID.ToString() == Searcher.Type).TypeName;
    // ……
}
```

另外需要注意的地方是，数据库中对应的字段的字符集要是utf8的，不然的话不能存中午。

#### Edit.cshtml

前台：

```c#
<wt:combobox field="Entity.Type" items="AllTypes" />
```

需要改的地方是，在点击了修改按钮的时候，页面并没有默认的把原来的题目类型显示出来，我想那是因为框架的问题，因为之前将Type转为了一个中文字符串，而不是ID值，所以他不会自动改，所以在点击修改的时候要将Type改回来，改成ID值，在提交修改的时候又要将他改回中文字符串，暂时还不知道怎么解决：

```c#
public ActionResult Edit(string id)
{
    var vm = Wtm.CreateVM<PrimaryCare_QuestionVM>(id);
    if (Searcher.Type != "" && Searcher.Type != null)
        vm.Entity.Type = DC.Set<QuestionType>().Single(x => x.TypeName == vm.Entity.Type).ID.ToString();
    return PartialView(vm);
}

public ActionResult Edit(PrimaryCare_QuestionVM vm)
{
    if (Searcher.Type != "" && Searcher.Type != null)
        vm.Entity.Type = DC.Set<QuestionType>().Single(x => x.ID.ToString() == vm.Entity.Type).TypeName;
}
```

## 中级护师

### 创建model

在 NurseExaminationSystem.Model\QuestionBank\MiddleCareExam 文件夹下创建中级护师的章、节、题目三个model，分别复制之前的文件，然后改掉文件名、命名控件、章节信息的联系字段等，这时题目的类型只需要一个字符串就好了。

+ MiddleCare_Chapter
+ MiddleCare_Question
+ MiddleCare_Section

model创建好了后，记得要去DataContext文件中添加，否则不能使用代码生成器

```c#
public DbSet<MiddleCare_Chapter> MiddleCare_Chapters { get; set; }
public DbSet<MiddleCare_Section> MiddleCare_Sections { get; set; }
public DbSet<MiddleCare_Question> MiddleCare_Questions { get; set; }
```

### 创建数据库表

创建三张对应的数据库，表名要和model代码上Table注解中的一致：

+ midllecare_chapters
+ middlecare_sections
+ middlecare_questions

可以直接从初级护师的三张表复制过来，只复制结构即可，然后将question表中的章节外键改一下就好。

### 生成代码

用调式模式运行代码，使用代码生成器。

将生成的Controller文件放在 Areas\QuestionBank\Controllers\MiddleCareExam 文件夹下。

将生成的VM文件夹放在 NurseExaminationSystem.ViewModel\QuestionBank\MiddleCareExam 文件夹下。

生成的页面文件已经放在了 Areas\QuestionBank\Views 对应的文件夹中，不需要动。

### 修改生成代码

#### 搜索框

将题目管理页面的搜索框设为一行两个搜索条件、默认不展开

```c#
<wt:searchpanel vm="@Model" reset-btn="true" expanded="false">
<wt:row items-per-row="ItemsPerRowEnum.Two">
```

#### 章节联动

前台：

```c#
<wt:combobox field="Searcher.ChapterId" items="Searcher.AllChapters" empty-text="@Localizer["Sys.All"]" trigger-url="/QuestionBank/Question/GetSections" link-field="Searcher.SectionId" />
    <wt:combobox field="Searcher.SectionId" empty-text="@Localizer["Sys.All"]" />
```

`trigger-url="/QuestionBank/Question/GetSections"` 指定联动后的数据从哪里获取，`link-field="Searcher.SectionId"` 表示要联动的哪个控件，节的 `items="Searcher.AllSections"` 属性可以不写，这样初始化就没有值，只有等选择了章之后，才会给节下拉框赋值。

`/QuestionBank/Question/GetSections` 这是一个方法，写在 QuestionController 中的方法：

```c#
public ActionResult GetSections(List<string> id)
{
    if (id.Count == 0) return JsonMore(null);
    var rv = DC.Set<Section>().CheckIDs(id, x => x.ChapterIDId).GetSelectListItems(Wtm, x => x.Name);
    return JsonMore(rv);
}
```

返回值类型一定用 `ActionResult` 和通过 `JsonMore` 转换。

#### 题目类型

题目类型的默认的是以文本框的方式显示，我们需要下拉框，

+ Index.cshtml 中的搜索框的题目类型条件需要改，

  ```c#
  <wt:combobox field="Searcher.Type"  items="Searcher.AllTypes"/>
  ```

  还需要在 MiddleCare_QuestionSearcher 中添加一个属性 AllTypes，用来显示所有的类型，

  ```c#
  public List<ComboSelectListItem> AllTypes { get; set; }
  ```

  并且在 InitVM  方法中初始化这个属性：

  ```c#
  AllTypes = DC.Set<QuestionType>().Where(x => x.ModelName == "中级护师").GetSelectListItems(Wtm, y => y.TypeName);
  ```

+ Create.cshtml 的题目类型也需要改

  ```c#
  <wt:combobox field="Entity.Type" items="AllTypes"/>
  ```

  然后也要在对应的 MiddleCare_QuestionVM 中添加并在InitVM方法中初始化属性：

  ```c#
  public List<ComboSelectListItem> AllTypes { get; set; }
  ```

  ```c#
  AllTypes = DC.Set<QuestionType>().Where(x => x.ModelName == "中级护师").GetSelectListItems(Wtm, y => y.TypeName);
  ```

+ Edit.cshtml 修改页面中需要改的部分就和Create中的一样

+ BatchEdit.cshtml 批量修改页面也差不多

  ```c#
  <wt:combobox field="LinkedVM.Type" items="LinkedVM.AllTypes"/>
  ```

  需要在这个LinkedVM（就是MiddleCare_QuestionBatchVM中的一个类）创建并在InitVM中初始化属性：

  ```c#
  public List<ComboSelectListItem> AllTypes { get; set; }
  ```

  ```c#
  AllTypes = DC.Set<QuestionType>().Where(x => x.ModelName == "中级护师").GetSelectListItems(Wtm, y => y.TypeName);
  ```

#### 批量修改

在批量修改的时候，也需要判断传过来的Type是不是空：

```c#
if (vm.LinkedVM.Type != "" && vm.LinkedVM.Type != null)
    vm.LinkedVM.Type = DC.Set<QuestionType>().Single(x => x.ID.ToString() == vm.LinkedVM.Type).TypeName;
```



#### 字段显示

详细页面和主页列表显示中会将“题目类型”的数据显示出ID，真题年份的名字会显示成“字典配置key”，需修改。

##### 内容显示ID

在创建的时候，它会把所选类型的ID传到后端的创建方法，所以要在MiddleCare_QuestionController中的Create方法中进行修改，如果类型不是空的话，就是ID值，就把这个ID值拿去数据库中找到类型名，替换即可：

```c#
public ActionResult Create(MiddleCare_QuestionVM vm)
{
    if (vm.Entity.Type != "" && vm.Entity.Type != null)
        vm.Entity.Type = DC.Set<QuestionType>().Where(x => x.ModelName == "中级护师").Single(x => x.ID.ToString() == vm.Entity.Type).TypeName;
    // ……
}
```

在修改的时候也是需要执行上面的操作，不然它保存到数据库中的就是一串ID值:

```c#
if (vm.Entity.Type != "" && vm.Entity.Type != null)
                vm.Entity.Type = DC.Set<QuestionType>().Where(x => x.ModelName == "中级护师").Single(x => x.TypeName == vm.Entity.Type).ID.ToString();
```



此外，按类型搜索的时候，传给后台的也是一个ID值，所以我们在搜索的时候也要进行一下转换，在MiddleCare_QuestionListVM中的IOrderedQueryable方法里：

```c#
public override IOrderedQueryable<MiddleCare_Question_View> GetSearchQuery()
{
    if (Searcher.Type != "" && Searcher.Type != null)
        Searcher.Type = DC.Set<QuestionType>().Single(x => x.ID.ToString() == Searcher.Type).TypeName;
    // ……
}
```

添加 null 的判断是为了批量修改时不出错，批量修改时，如果没有选择类型，则类型会为 null，而不是 ""。

所在在执行批量修改的时候也要改一下类型，因为它传过去的还是ID，点击批量修改的提交按钮，根据浏览器的开发者工具可以看到传递的参数名字和数据，在MiddleCare_QuestionController中的DoBatchEdit中：

```c#
public ActionResult DoBatchEdit(MiddleCare_QuestionBatchVM vm, IFormCollection nouse)
{
    if (vm.LinkedVM.Type != "" && vm.LinkedVM.Type != null)
        vm.LinkedVM.Type = DC.Set<QuestionType>().Single(x => x.ID.ToString() == vm.LinkedVM.Type).TypeName;
    // ……
}
```

##### 标题显示默认

主页列表的显示问题，在对应的ListVM中，修改View类的显示信息即可：

```c#
public class MiddleCare_Question_View : MiddleCare_Question{
    [Display(Name = "真题年度")]
    public String DicFieldName_view { get; set; }
    [Display(Name = "章")]
    public String Name_view { get; set; }
    [Display(Name = "节")]
    // 这是默认显示的方式：[Display(Name = "_Model._Section._Name")]
    public String Name_view2 { get; set; }
}
```

详细页面的显示问题，修改前台页面即可：

```c#
<wt:display field="Entity.Year.DicFieldName" label-text="真题年度"/>
<wt:display field="Entity.Chapter.Name" label-text="章"/>
<wt:display field="Entity.Section.Name" label-text="节"/>
```

#### 修改页面显示不出题型

这是因为`<wt:combobox field="Entity.Type" items="AllTypes" />` 需要Entity.Type是一个ID值时，才能从数据库中查到数据并显示出来，但是我们上面对执行修改的操作进行了更改，导致Entity.Type是类型名而不是ID，所以他不会自动带出来。

所以要在点击修改的时候，将类型名转为ID值。

```c#
if (vm.Entity.Type != "" && vm.Entity.Type != null)
    vm.Entity.Type = DC.Set<QuestionType>().Where(x => x.ModelName == "中级护师").Single(x => x.TypeName == vm.Entity.Type).ID.ToString();
```



### 编写API

在 StudenArea/Controller 下新建一个MiddleCareController，在这里面写刷题需要的API。

```c#
[Route("/MiddleCare/")]
public class _MiddleCareController:BaseController
{
    [HttpGet("GetRealQuestion")]
    public List<MiddleCare_Question> GetList([FromBody] string year, [FromBody] string type)
    {
        List<MiddleCare_Question> res = new List<MiddleCare_Question>();
        res = DC.Set<MiddleCare_Question>().Where(x => x.Year.DicFieldName == year && x.Type == type).ToList();
        return res;
    }

    [HttpGet("GetChapterQuestion")]
    public List<MiddleCare_Question> GetList2([FromBody] string chapter, [FromBody] string section)
    {
        List<MiddleCare_Question> res = new List<MiddleCare_Question>();
        res = DC.Set<MiddleCare_Question>().Where(x => x.Chapter.Name == chapter && x.Section.Name == section).ToList();
        return res;
    }

    [HttpGet("GetChapterInfo")]
    public Dictionary<string, List<string>> GetList3()
    {
        Dictionary<string, List<string>> res = new Dictionary<string, List<string>>();
        var ChapterList = DC.Set<MiddleCare_Chapter>().ToList();
        foreach (var item in ChapterList)
        {
            List<string> list = new List<string>();
            var sectionList = DC.Set<MiddleCare_Section>().Where(x => x.ChapterIDId == item.ID).Select(x => x.Name).ToList();
            res.Add(item.Name, sectionList);
        }
        return res;
    }
}
```

+ 获取章节信息：/MiddleCare/GetChapterInfo
+ 获取章节题目：/MiddleCare/GetChapterQuestion
+ 获取真题：/MiddleCare/GetRealQuestion

### 编写刷题页面与逻辑

中级护师分为真题练习和章节练习，所以要有两个页面文件，同时在\_DefaultController中就要添加两个对应的方法：

```c#
[ActionDescription("中级护师-真题练习", IsPage = true)]
public ActionResult MiddleCareExam_Real()
{
    var vm = Wtm.CreateVM<NurseExaminationSystem.ViewModel.QuestionBank.MiddleCare_QuestionVMs.MiddleCare_QuestionVM>();
    return PartialView("/Areas/StudentArea/Views/_Default/MiddleCareExam/MiddleCareExam_Real.cshtml", vm);
}
[ActionDescription("中级护师-章节练习", IsPage = true)]
public ActionResult MiddleCareExam_Chapter()
{
    var vm = Wtm.CreateVM<NurseExaminationSystem.ViewModel.QuestionBank.MiddleCare_QuestionVMs.MiddleCare_QuestionVM>();
    return PartialView("/Areas/StudentArea/Views/_Default/MiddleCareExam/MiddleCareExam_Chapter.cshtml", vm);
}
```

在  StudentArea\Views\_Default\MiddleCareExam 文件夹下新建两个页面文件：

+ MiddleCareExam_Chapter.cshtml：章节练习
+ MiddleCareExam_Real.cshtml：真题练习

还要在 wwwroot\myjs\MiddleCare 文件夹下新建一个 middlerCare.js 写对应的逻辑。

## 其他类

### 创建model



### 创建数据库表

### 生成代码

### 修改生成代码

### 编写API

### 编写刷题页面与逻辑

## 学历提升

### 创建model

### 创建数据库表

### 生成代码

### 修改生成代码

### 编写API

### 编写刷题页面与逻辑

## 考公考编

### 创建model

### 创建数据库表

### 生成代码

### 修改生成代码

### 编写API

### 编写刷题页面与逻辑



## 更新页面的写法

在 wwwroot 下新建两个文件夹：mycss、myjs 用来存放我自己写的css文件和js文件。

将所有页面都需要使用的js函数提取到一个commence.js文件中，然后在对应的文件中创建对应的js文件，一个模块的真题和章节两部分的js函数写在一个文件中即可。

### html

所有刷题页面的布局

![image-20231210174014916](https://gitee.com/LowProfile666/image-bed/raw/master/img/202401221155154.png)

下拉框区域：

+ 一级下拉框
+ 二级下拉框

题号区域：

+ 总题数 + 当前题号
+ 跳转区域
+ 倒计时区域

题目区域

+ 题目
+ 五个选项

总结区域

+ 

解析区域

+ 

按钮区域

+ 上一题 + 提交 + 下一题

所有元素的样式通过使用类选择器来配合css文件。

### css

整个项目所有的刷题页面所有的元素就几种：

+ 按钮（上下题、提交、查看解析、跳转
+ 下拉框（章节、年份、类型）
+ 题号区域（显示题号）
+ 输入框（跳转题号）
+ 倒计时区域（倒计时）
+ 题目区域（题目、选项）
+ 总结区域（做题总结）
+ 解析区域（解析）





















# 问题

+ [x] 专业实务和实践能力这两种类型是静态的，不是动态的。
+ [x] 初级护师的批量删除、修改、导出有问题，会报错，暂时先隐藏这三功能，估计是因为Type类型的问题。还有搜索框的UI问题。
+ [x] 题型管理中，模块名称应变为下拉框。
+ [x] 倒计时有问题。（已取消）
+ [x] 没有题目报错页面。

设置页面的时候，要把对应的Controller加上。

+ [x] 快捷方式路径

+ [x] 护士的题目无法正常显示

+ [x] 章节联动 

+ [x] 每个角色的页面权限

+ [x] 每个页面记得改名字，以模块开头

+ [ ] 错误页面，没有章节、没有类型、没有题目

+ [x] 更改了管理员角色，需要更改用户列表的显示

+ [x] 真题年度的页面不需要新建等操作按钮（考虑也换成一张表）

+ [x] 单题解析

+ [ ] 上传主观题

  将主观题新建表，导入主观题的时候用一个页面导入，可以选择所属的科目。

  材料分析题：

  + 材料
  + 问题1
  + 问题2
  + 问题3
  + 问题4
  + 问题5
  + 解析

  ![image-20240320110537202](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403201106323.png)

  ~~两张表~~一张表。

  简答题：

  + 题目
  + 解析
  + 类型：简答/辨析

  ![image-20240320110632562](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403201106339.png)

  

  辨析题：

  + 题目
  + 解析
  + 类型：简答/辨析

  ![image-20240320110615091](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403201106424.png)

  写作题：

  + 题目
  + 材料
  + 要求
  + 解析

  ![image-20240320110448894](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403201106298.png)

+ [x] 真题年度页面--修改页面--字典集文本框应该改成不可修改

+ [ ] ?用户列表设置为不显示当前用户

+ [ ] 布置作业

  新建作业模型，管理作业

  + 发布作业，选择题目（获取题目的ID，去题库中读取题目）或新建题目（选择分类，存到题库，保留ID），
  + 一个作业包括：
    + 作业名字
    + 发布时间
    + 结束时间？
    + 包含的题目ID

  新建一个作业页面，发布作业后，作业列表显示在当前页面，每次读取数据库获取作业列表，点击作业后，开一个页面或窗口，渲染作业中包含的题目ID渲染题目。

+ [ ] 做题统计

# 更新2

以中级护师模块为例。

## 材料分析题

新建材料分析题库表：

![image-20240322201250015](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403222012153.png)

为了防止一个材料分析题可能有多个小题的情况，设置了 5 个问题字段。然后创建模型：

```cs
namespace NurseExaminationSystem.Model
{
    [Table("Material_Questions")]
    [Display(Name = "材料分析题")]
    public class Material_Question : BasePoco
    {
        [Display(Name = "所属科目")]
        public string Belong { get; set; }
        [Display(Name = "题目类型")]
        public string Type { get; set; }
        [Display(Name = "真题年度")]
        [Comment("真题年度")]
        [RefDicName(Name = "YearDic")]
        public DicField Year { get; set; }
        [Display(Name = "真题年度")]
        [Comment("真题年度")]
        public Guid? YearId { get; set; }
        [Display(Name = "章")]
        [Comment("章")]
        public Chapter Chapter { get; set; }
        [Display(Name = "章")]
        [Comment("章")]
        public int? ChapterId { get; set; }
        [Display(Name = "节")]
        [Comment("节")]
        public Section Section { get; set; }
        [Display(Name = "节")]
        [Comment("节")]
        public int? SectionId { get; set; }
        [Display(Name = "材料")]
        [Comment("材料")]
        public string Material { get; set; }
        [Display(Name = "题目1")]
        [Comment("题目1")]
        public string Question1 { get; set; }

        [Display(Name = "题目2")]
        [Comment("题目2")]
        public string Question2 { get; set; }
        [Display(Name = "题目3")]
        [Comment("题目3")]
        public string Question3 { get; set; }
        [Display(Name = "题目4")]
        [Comment("题目4")]
        public string Question4 { get; set; }
        [Display(Name = "题目5")]
        [Comment("题目5")]
        public string Question5 { get; set; }

        [Display(Name = "正确答案")]
        [Comment("正确答案")]
        [Required(ErrorMessage = "Validate.{0}required")]
        public string Answer { get; set; }

        [Display(Name = "解析")]
        [Comment("解析")]
        public string Parse { get; set; }
        [Key]
        [Display(Name = "_Model._Question._ID")]
        [Required(ErrorMessage = "Validate.{0}required")]
        [Column("id")]
        public new int ID { get; set; }
        [Display(Name = "题目图片")]
        public FileAttachment Photo { get; set; }
        [Display(Name = "题目图片")]
        public Guid? PhotoId { get; set; }
    }
}
```

然后在 DataContext 中加入：

```cs
public DbSet<Material_Question> Material_Questions { get; set; }
```

然后就可以使用系统的代码生成器，生成代码，然后修改代码。

主要修改一下页面的下拉选择框的值和导入的模板。

新建页面：

```html
<wt:row items-per-row="ItemsPerRowEnum.Three">
<wt:combobox field="Entity.Belong" items="AllBelongs" trigger-url="/QuestionBank/Public/GetQuestionTypes"
                link-field="Entity.Type" />
<wt:combobox field="Entity.YearId" items="AllYears"  />
<wt:combobox field="Entity.Type"/>
</wt:row>
<wt:textarea field="Entity.Material" empty-text="输入题目材料"/>
<wt:textbox field="Entity.Question1" empty-text="输入题目1"/>
<wt:textbox field="Entity.Question2" empty-text="输入题目2"/>
<wt:textbox field="Entity.Question3" empty-text="输入题目3"/>
<wt:textbox field="Entity.Question4" empty-text="输入题目4"/>
<wt:textbox field="Entity.Question5" empty-text="输入题目5"/>
<wt:textarea field="Entity.Answer" empty-text="输入正确答案"/>
<wt:textarea field="Entity.Parse" empty-text="输入题目解析" />
```

其中的 /QuestionBank/Public/GetQuestionTypes 方法是在 QuesionBank/Controllers 下新建的 PublicController 中的方法：

```cs
[Area("QuestionBank")]
[ActionDescription("主观题的公共Controller")]
public class PublicController : BaseController
{
    static string Model;

    [ActionDescription("获取题目类型")]
    public ActionResult GetQuestionTypes(string id)
    {
        Model = id;
        var rv = DC.Set<QuestionType>().CheckEqual(id, x => x.ModelName).GetSelectListItems(Wtm, x => x.TypeName).Distinct();
        return JsonMore(rv);
    }
}
```

还有 AllBelongs 数据来自 Material_QuestionVM 中：

```cs
public List<string> AllBelongs { get; set; }
```

```cs
protected override void InitVM()
{
    AllYears = DC.Set<DicField>().GetSelectListItems(Wtm, y => y.DicFieldName);
    AllBelongs = MyUtils.GetAllModelNames();
}
```

这个 MyUtils 类是我自己写的工具类，也是在 ViewModel 中：

```cs
public static class MyUtils 
{
    public static List<string> GetAllModelNames()
    {
        var res = new List<string>();
        res.Add("护士");
        res.Add("初级护师");
        res.Add("中级护师");
        res.Add("其他类-专业课程");
        res.Add("其他类-公共课程");
        res.Add("学历提升-专科-公共课程");
        res.Add("学历提升-专科-专业课程");
        res.Add("学历提升-本科-专业课程");
        res.Add("学历提升-本科-公共课程");
        res.Add("学历提升-研究生-专业课程");
        res.Add("学历提升-研究生-公共课程");
        res.Add("考公考编");
        return res;
    }
}
```

导入题目的模板，要将题目的所属科目设置为下拉选值：

```cs
protected override void InitVM()
{
    Year_Excel.DataType = ColumnDataType.ComboBox;
    Year_Excel.ListItems = DC.Set<DicField>().GetSelectListItems(Wtm, y => y.DicFieldName);
    Belong_Excel.DataType = ColumnDataType.ComboBox;
    Belong_Excel.ListItems = MyUtils.GetAllModelNames().Select(x => new ComboSelectListItem
                                                               {
                                                                   Text = x,
                                                                   Value = x
                                                               });
}
```

由于新增了题库表，那么原来获取真题的方法就需要修改一下，通过不同的题目类型去不同的题库表中读取数据：

```cs
[ActionDescription("获取真题")]
[HttpGet("GetRealQuestion")]
public List<object> GetList([FromBody] string year, [FromBody] string type)
{
    var res = new List<object>();
    if (type == "材料分析")
        res.AddRange(DC.Set<Material_Question>().Where(x => x.Year.DicFieldName == year && x.Type == type).ToList());
    else if (type == "简答" || type == "辨析")
        res.AddRange(DC.Set<Analysis_Question>().Where(x => x.Year.DicFieldName == year && x.Type == type).ToList());
    else if (type == "写作")
        res.AddRange(DC.Set<Writing_Question>().Where(x => x.Year.DicFieldName == year && x.Type == type).ToList());
    else
        res.AddRange(DC.Set<MiddleCare_Question>().Where(x => x.Year.DicFieldName == year && x.Type == type).ToList());
    return res.Cast<object>().ToList();
}
```

在首页新增一个搜索条件：

```html
<wt:row items-per-row="ItemsPerRowEnum.Three">
	<wt:combobox field="Searcher.Belong" items="Searcher.AllBelongs" />
</wt:row>
```

然后要在 Searcher 中定义对应的属性：

```cs
public string Belong { get; set; }
public List<string> AllBelongs { get; set; }
protected override void InitVM()
{
    AllBelongs = MyUtils.GetAllModelNames();
}
```

然后要在对应得 ListVm 中添加搜索条件：

```cs
            var query = DC.Set<Analysis_Question>()
                .CheckContain(Searcher.Belong, x => x.Belong)
```















