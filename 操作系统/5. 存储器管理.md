# 5. 存储器管理

## 5.1 存储器的层次结构

存储层次

+ CPU寄存器
+ 主存：高速缓存、主存储器、磁盘缓存
+ 辅存：固定磁盘、可移动介质

<font color=red>层次越高，访问速度越快，价格也越高，存储容量也最小。</font>

![image-20231001141043940](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310011410004.png)

寄存器和主存掉电后，存储的信息不再存在；辅存的信息长期保存。

### 5.1.1 寄存器

寄存器访问速度最快，完全能与CPU协调工作，但价格却十分昂贵，因此容量不可能做得很大。

寄存器的长度一般以字(word)为单位。寄存器的数目，对于当前的微机系统和大中型机，可能有几十个甚至上百个；而嵌入式计算机系统一般仅有几个到几十个。

寄存器通常用于加速存储器的访问速度，如用寄存器存放操作数，或用作地址寄存器加快地址转换速度等。

### 5.1.2 主存储器

主存储器(简称内存或主存)是计算机系统中一个主要部件，用于保存进程运行时的程序和数据，也称可执行存储器，材质以DRAM为主。

由于主存储器的访问速度远低于CPU执行指令的速度，为缓和这一矛盾，在计算机系统中引入了寄存器和高速缓存。

### 5.1.3 高速缓存

高速缓存是现代计算机结构中的一个重要部件，其容量大于或远大于寄存器，而比内存约小两到三个数量级左右，从几十KB到几MB，访问速度快于主存储器。

根据程序执行的局部性原理(即程序在执行时将呈现出局部性规律，在一较短的时间内，程序的执行仅局限于某个部分)，将主存中一些经常访问的信息存放在高速缓存中，减少访问主存储器的次数，可大幅度提高程序执行速度。

### 5.1.4 磁盘缓存

由于目前磁盘的I/O速度远低于对主存的访问速度，因此将频繁使用的一部分磁盘数据和信息，暂时存放在磁盘缓存中，可减少访问磁盘的次数。

总结：

+ 可执行存储器：寄存器和主存储器。
+ 主存储器：内存或主存。
+ 寄存器：访问速度最快，与CPU协调工作，价格贵。
+ 高速缓存：速度介于寄存器和存储器之间。
  + 备份主存主常用数据，减少对主存储器的访问次数；
  + 缓和内存与处理机之间的矛盾。
+ 磁盘缓存：
  + 暂时存放频繁使用的一部分磁盘数据和信息；
  + 缓和主存和I/O设备在速度上的不匹配；
  + 利用主存的部分空间，主存可看成辅存的高速缓存。

## 5.2 程序的装入和链接

在多道程序环境下，要使程序运行，必须先为之创建进程。

而创建进程的第一件事，便是将程序和数据装入内存。

程序的运行步骤：

+ 编译：由编译程序(Compiler)对源程序进行编译，形成若干个目标模块
+ 链接：由链接程序(Linker)将目标模块和它们所需要的库函数链接在一起，形成一个完整的装入模块
+ 装入：由装入程序(Loader)将装入模块装入内存

**相关概念**

逻辑地址：目标代码的相对编址

物理地址：目标代码的绝对编址

地址空间：目标代码用逻辑地址编址所限定的区域

存储空间：内存若干存储单元用物理地址编址所限定的区域

地址重定位：当程序被装入内存时，程序的逻辑地址被转换成内存的物理地址的过程

### 5.2.1 物理地址和逻辑地址

<font color=blue>物理地址（绝对地址）</font>：物理内存的地址，内存以字节为单位编址。

+ 物理地址空间：所有物理地址的集合

<font color=red>逻辑地址（虚拟地址、相对地址）</font>：由CPU产生的地址，即程序编译后使用的相对于0字节的地址。

+ 逻辑地址空间：由程序所生成的所有逻辑地址的集合

![image-20231001142029842](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310011420891.png)

### 5.2.2 重定位的方式

静态重定位：目标代码装入内存时，一次性进行地址转换。

动态重定位：目标代码装入内存时，先不进行地址转换（即原代码装入），在执行时，再实施地址转换。

### 5.2.3 内存保护

目的：

+ 保护OS不被用户访问
+ 保护用户进程不会相互影响

实现：硬件

+ 基地址寄存器：保存最小的合法物理内存地址（基地址）
+ 界限寄存器：保存合法的地址范围大小（界限地址）
+ 内存空间保护的实现：判断“基地址≤物理地址＜（基地址+界限地址）”是否成立。

### 5.2.4 程序的装入

<font color=blue>绝对装入方式</font>

编译时产生的地址使用绝对地址（由编译器或程序员完成）。程序或数据被修改时，需要重新编译程序。

<font color=blue>可重定位装入方式</font>

编译后的目标模块使用相对地址。在装入时，由装入程序完成重定位（静态重定位）。要求连续空间，全部装入内存且位置不可移动。

+ 逻辑地址转换为物理地址的过程，称为重定位，也称为地址交换。

<font color=blue>动态运行时装入方式</font>

编译后的目标模块使用相对地址。装入内存时并不地址转换，在真正执行时，完成动态重定位。

### 5.2.5 程序的链接

**静态链接**

在程序运行前，将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。

对相对地址进行修改；变换外部调用符号。

**装入时动态链接**

在装入内存时，采用边装入边链接的链接方式。

便于修改和更新。

便于实现对目标模块的共享。

**运行时动态链接**

将某些目标模块的链接推迟到执行时才执行。即在执行过程中，若发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将它装入内存，并把它链接到调用者模块上。

加快装入过程，节省大量的内存空间。

### 5.2.6 静态链接方式（Static Linking）

特点：

+ 一次链接，n次运行
+ 得到完整的可装入模块，不可再拆
+ 不灵活：不管有用与否的模块都将链接到装入模块，同时导致内存利用率较低
+ 不利于模块的修改和升级

### 5.2.7 装入时动态链接（Load-time Dynamic Linking）

用户源程序经编译后所得的目标模块，是在装入内存时边装入边链接的，即在装入一个目标模块时，若发生一个外部模块调用事件，将引起装入程序去找出相应的外部目标模块，并将它装入内存，还要按照图所示的方式来修改目标模块中的相对地址。

![image-20231001142840588](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310011428621.png)

### 5.2.8 运行时动态链接(Run-time Dynamic Linking)

装入时动态链接是将所有可能要运行到的模块都全部链接在一起并装入内存，显然这是低效的，因为往往会有些目标模块根本就不运行。比较典型的例子是作为错误处理用的目标模块，如果程序在整个运行过程中都不出现错误，则显然就不会用到该模块。

运行时动态链接方式是对装入时链接方式的一种改进。这种链接方式是将对某些模块的链接推迟到程序执行时才进行链接，亦即，在程序执行过程中，当发现一个被调用模块尚未装入内存时，才立即由OS去找到该模块并将之装入内存，把它链接到调用者模块上。凡在本次执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。

优点：

+ 便于共享：多个进程可共用一个DLL模块，节省了内存。
+ 为部分装入提供了条件(运行时动态链接)：一个进程可由若干DLL模块构成，按需装入。
+ 便于模块的修改和升级：只要被修改模块的接口不变，则该模块的修改不会引发其它模块的重新编译。
+ 改善了程序的可移植性：可面向不同的应用环境开发同一功能模块的不同版本，根据当前的环境载入匹配的模块版本。

缺点：

+ 增加了程序执行时的链接开销。(每次运行都需链接)
+ 模块数量众多，增加了模块的管理开销。

## 5.3 对换与覆盖

