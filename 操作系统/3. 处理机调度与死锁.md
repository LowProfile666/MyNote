# 3. 处理机调度与死锁

## 3.1 处理机调度概述

### 3.1.1 处理机调度层次

+ 高级调度：长程调度/作业调度

  把后备作业调入内存，只调入一次，调出一次

+ 中级调度：中程调度/内存调度

  将进程调至外存，条件适合再调入内存，在内、外存对换区进行进程对换

+ 低级调度：短程调度/进程调度/处理机调度

  从就绪队列选取进程分配给处理机

  最基本的调度，频率非常高（相当于一个时间片完成）

**高级调度**

调度对象：<font color=red>作业</font>

根据某种算法，选中在外存后备队列中的作业，调入内存，并为其创建进程和分配必要的资源，再将新创建的进程排在就绪队列上等待调度。

主要用于多道批处理系统中。

**中级调度**

即<font color=red>对换</font>功能：

将暂不运行的进程，调至外存等待；将处于外存上的急需运行的进程，调入内存运行。

**低级调度**

调度对象：<font color=red>进程</font>

根据某种调度算法，决定就绪队列中的哪个进程应获得处理机。应用在于多道批处理、分时和实时OS。

### 3.1.2 进程调度的任务和方式

进程调度的任务：

+ 保存处理机的现场信息
+ 按某种算法选取进程
+ 把处理器分配给进程

进程调度机制（调度程序分为三部分）

+ 排队器：用于将就绪进程插入相应的就绪队列
+ 分派器：用于将选定的进程移出就绪队列
+ 上下文切换器：进行新旧进程之间的上下文切换

![image-20230929093610597](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309290937047.png)

进程调度的方式：非抢占方式、抢占方式。

<font color=red>非抢占方式</font>：一旦把处理机分配给某进程后，便让该进程一直执行，直至该进程完成或发生某事件而被阻塞时，才再把处理机分配给其他进程，决不允许某进程抢占已经分配出去的处理机。

<font color=red>抢占方式</font>：允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。(现代OS广泛采用)

+ 优先权原则：允许优先权高的新到进程抢占当前进程的处理机
+ 短作业优先原则：短作业可以抢占当前较长作业的处理机
+ 时间片原则：各进程按时间片运行，当一个时间片用完后，便停止该进程的执行而重新进行调度

### 3.1.3 处理机调度算法的目标

共同目标：资源利用率 -->  系统效率

批处理系统的目标：平均周转时间(Turnaround Time)短、系统吞吐量(Throughout)高、处理机利用率(CPU Utilization)高

分时系统的目标：响应时间快、均衡性

实时系统的目标：截止时间的保证、可预测性

$CPU利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$

### 3.1.4 评价指标

周转时间：从作业提交给系统开始，到作业完成为止的这段时间间隔。

+ <font color=red>平均周转时间</font>：$T=\frac{1}{n}(\sum^n_{i=1}T_i)$
+ <font color=red>带权周转时间</font>：权值为作业周转时间T与系统为之服务时间TS之比。
+ 平均带权周转时间：$W=\frac{1}{n}(\sum^n_{i=1}\frac{T_i}{T_{S_i}})$

响应时间：从用户提交请求开始，直到系统首次显示出处理结果为止的一段时间。

<font color=blue>等待时间（进程调度）</font>：进程在就绪队列中等待调度的所有时间之和。

## 3.2 调度算法

### 3.2.1 作业调度算法

先来先服务调度算法（FCFS）、短作业优先调度算法（SJF）、优先级调度算法（PSA）、高响应比优先级调度算法（HRRN）。

### 3.2.2 进程调度算法

先来先服务调度算法（FCFS）、短作业优先调度算法（SJF）、优先级调度算法（PSA）、高响应比优先级调度算法（HRRN）、多级队列调度算法(MQ)、多级反馈队列调度算法(MFQ)、基于公平原则的调度算法(FS)、时间片轮转调度算法(RR)。

### 3.2.3 FCFS

先来先服务，First Come First Served，FCFS。

算法内容：调度<font color=red>作业/就绪</font>队列中最先入队者，等待操作完成或阻塞。

算法原则：按作业/进程到达顺序服务（执行）。

调度方式：非抢占式调度

适用场景：作业/进程调度

优点：<font color=red>有利于CPU繁忙型作业，充分利用CPU资源</font>

缺点：不利于I/O繁忙型作业，操作耗时

【FCFS举例】

情况1：假设作业到达顺序如下：J1、J2、J3，分别的运行时间为：24、3、3，则该调度的甘特图（Gantt）为：

![image-20230929161121551](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291611580.png)

那么

+ 平均等待时间 = (0 + 24 + 27)/3 = 17
+ 平均周转时间 = (24 + 27 + 30)/3 = 27
+ 平均带权周转时间 = (24/24 + 27/3 + 30/3)/3 = 6.7

情况2：假设作业到达顺序如下：J2、J3、J1，则该调度的甘特图（Gantt）为：

![image-20230929161536539](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291615564.png)

那么

+ 平均等待时间 = (6 + 0 + 3)/3 = 3
+ 平均周转时间 = (30+ 3 + 6)/3 = 13
+ 平均带权周转时间 = (30/24 + 3/3 + 6/3)/3 = 1.4

此结果产生是由于短进程先于长进程到达。

### 3.2.4 SJF

短作业优先，Shortest Job First，SJF。

算法内容：所需服务时间最短的<font color=red>作业/进程</font>优先服务（执行）

算法原则：追求最少的平均（带权）周转时间

调度方式：非抢占式

适用场景：作业/进程调度

优点：<font color=red>平均等待/周转时间最少</font>

缺点：长作业周转时间会增加、估计时间不准确，不能保证紧迫任务及时处理。

对于进程调度，SJF 有两种模式：

+ 非抢占式
+ 抢占式——抢占发生在有比当前进程剩余时间片更短的进程到达时，也称为最短剩余时间优先调度(SRTN) 

【举例】非抢占式 SJF

![image-20230929162112952](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291621986.png)

![image-20230929162132346](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291621376.png)

那么

+ 平均等待时间 = (0 + 6 + 3 + 7)/4 = 4
+ 平均周转时间=(7+10+4+11)/4= 8
+ 平均带权周转时间 = (7/7 + 10/4 +4/1+ 11/4)/4 = 2.5

【举例】抢占式 SJF

![](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291626775.png)

![image-20230929162438697](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291626261.png)

那么

+ 平均等待时间 = (9 + 1 + 0 +2)/4 = 3
+ 平均周转时间 = (16+ 5 +1+ 6)/4 = 7

### 3.2.5 PSA

优先级调度，Priority-Scheduling Algorithm，PSA。

算法内容：又叫优先权调度，按<font color=red>作业/进程</font>的优先级（紧迫程度）进行调度

算法原则：优先级最高（最紧迫）的作业/进程先调度

调度方式：抢占/非抢占式（并不能获得及时执行）

适用场景：作业/进程调度

优先级设置原则：

+ 静态/动态优先级
  + 静态：创建进程时确定优先数(整数)，在进程的整个运行期间保持不变
  + 动态：创建进程时先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变
+ 系统 > 用户；交互型 > 非交互型；I/O型 > 计算型
+ 低优先级进程可能会产生“饥饿”

<font color=red>高响应比优先调度算法是一种优先级调度算法</font>，用于作业调度。	

【举例】非抢占式

![image-20230929163609117](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291636151.png)

![image-20230929163622829](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291636853.png)

那么

+ 平均等待时间 = (6 + 0 + 16+18+1)/5 =8.2
+ 平均周转时间 = (16 + 1 + 18+19+6)/5 = 12

#### HRRN

高响应比优先调度算法，Highest Response Ratio Next，HRRN，是PSA的特例。

算法内容：结合FCFS和SJF，综合考虑等待时间和服务时间计算响应比，高的优先调度

算法原则：综合考虑作业/进程的等待时间和服务时间

调度方式：非抢占式

适用场景：作业/进程调度

响应比计算：

+ 响应比 = （等待时间 + 服务时间）/ 服务时间
+ 只有当前进程放弃执行权（完成/阻塞）时，重新计算所有进程响应比
+ <font color=red>长作业等待越久响应比越高，更容易获得处理机</font>

HRRN 既考虑作业的等待时间，又考虑作业的运行时间

+ 如等待时间相同，运行时间越短，类似于SJF
+ 如运行时间相同，取决于等待时间，类似于FCFS
+ 长作业可随其等待时间的增加而提高响应比，从而得到调度

<font color=blue>优先级</font>：$优先级=\frac{等待时间+要求服务时间}{要求服务时间}$

<font color=blue>响应比</font>：$R_p=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}$

### 3.2.6 RR

时间片轮转，Round-Robin，RR。

算法内容：按<font color=red>进程</font>到达就绪队列的顺序，轮流分配一个<font color=red>时间片</font>去执行，时间用完则剥夺

算法原则：公平、轮流为每个进程服务，进程在一定时间内能得到响应

调度方式：抢占式，由<font color=red>时钟中断</font>确定时间到

适用场景：进程调度

优点：<font color=red>公平、响应快，适用于分时系统</font>

缺点：时间片太大，相当于FCFS；太小，处理机切换频繁，开销增大

+ 时间片：小单位的CPU时间，通常为10~100毫秒
+ 时间片决定因素：系统响应时间、就绪队列进程数量、系统处理能力

执行原理：为每个进程分配不超过一个时间片的CPU。时间片用完后，该进程将被抢占并插入就绪队列末尾，循环执行。

假定就绪队列中有n个进程、时间片为q, 则每个进程每次得到1/n的、不超过q单位的成块CPU时间，没有任何一个进程的等待时间会超过(n-1) q单位

【举例】时间片为20

![image-20230929165128290](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291651333.png)

![image-20230929165142058](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291651100.png)

那么

+ 平均等待时间：(57+20+64+80)/4 = 55.25
+ 平均响应时间: (0+20+37+57)/4= 28.5
+ 通常，RR的平均周转时间比SJF长，但响应时间要优于SJF.

### 3.2.7 MQ

多级队列调度，Multileveled Queue，MQ。

就绪队列从一个分为多个，每个队列有自己的调度算法，调度须在队列间进行。

+ 固定优先级调度，即前台运行完后再运行后台，有可能产生饥饿。
+ 给定时间片调度，即每个队列得到一定的CPU时间，进程在给定时间内执行；如80%的时间执行前台的RR调度，20%的时间执行后台的FCFS调度。

### 3.2.8 MFQ

多级反馈队列调度，Multileveled Feedback Queue，MFQ。

算法内容：设置多个优先级排序的就绪队列，优先级从高到低，时间片从小到大，前面队列不为空，不执行后续队列进程。新进程采用队列降级法

+ 进入第一级队列，按FCFS分时间片，没有执行完，移到第二级，第三级……

算法原则：集前几种算法优点

调度方式：抢占式

适用场景：进程调度

### 3.2.9 基于公平原则的调度算法

主要考虑调度的公平性。

<font color=blue>公平分享</font>调度算法，Fare-Share，FS。

+ 调度的公平性主要<font color=blue>针对用户</font>而言
+ 所有用户能获得相同的处理机时间或时间比例

<font color=red>保证调度算法（Guarantee）</font>

+ <font color=red>性能保证</font>，而非优先运行
+ 如保证处理机分配的公平性（处理机时间为1/n）

## 3.3 实时调度

实时调度是针对实时任务的调度。实时任务，都联系着一个截止时间。

根据实时任务性质分为

+ 硬实时HRT任务
+ 软实时SRT任务

根据调度方式分为

+ 非抢占式调度算法：响应时间为数秒至数十秒，可用于要求不太严格的实时控制系统
+ 抢占式调度算法：响应时间为数秒至数百毫秒，可用于有一定要求的实时控制系统
  + 基于时钟中断的抢占式优先级调度
  + 立即抢占的优先级调度

### 3.3.1 实时调度的基本条件

<span style="background-color:#00a4ff;">1、提供必要的信息</span>

就绪时间、开始截止时间和完成截止时间、处理时间、资源要求、优先级。

<span style="background-color:#00a4ff;">2、系统处理能力强</span>

单处理机系统、多处理机系统都满足。

<span style="background-color:#00a4ff;">3. 采用抢占式调度机制</span>

<span style="background-color:#00a4ff;">4. 采用快速切换机制</span>

对中断具有快速响应能力，快速的任务分派能力。

### 3.3.2 EDF

最早截止时间优先调度，Earliest Deadline First，EDF。

EDF根据任务的截止时间确定优先级，截止时间越早，优先级越高。

既可用于抢占式调度，也可用于非抢占式调度

+ 非抢占式调度用于非周期实时任务
+ 抢占式调度用于周期实时任务

【举例】两个周期性实时任务A和B，任务A要求每20 ms执行一次，执行时间为10 ms，任务B要求每50 ms执行一次，执行时间为25 ms。

![image-20230929195434993](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291954050.png)

### 3.3.3 LLF

最低松弛度优先调度，LLF。

根据任务的紧急程度（<font color=red>松弛度</font>）确定任务优先级

+ 紧急程度越高（松弛度越低），优先级越高
+ $松弛度=必须完成时间－其本身的运行时间－当前时间$

主要用在抢占式调度方式中。

【举例】两个周期性实时任务A和B，任务A要求每20 ms执行一次，执行时间为10 ms，任务B要求每50 ms执行一次，执行时间为25 ms。

![image-20230929195658856](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291956900.png)

![image-20230929195706343](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291957389.png)

### 3.3.4 优先级倒置现象

采用优先级调度和抢占方式，可能产生<font color=red>优先级倒置</font>。

现象：高优先级进程被低优先级进程延迟或阻塞。

**解决办法**：

+ 制定一些规定，如规定低优先级进程执行后，其所占用的处理机不允许被抢占；
+ 建立动态优先级继承。

## 3.4 Linux进程调度

默认调度算法：完全公平调度CFS算法。

基于调度器类：允许不同的可动态添加的调度算法并存，每个类都有一个特定的优先级。

总调度器：根据调度器类的优先顺序，依次对调度器类中的进程进行调度。

调度器类：使用所选的调度器类算法（调度策略）进行内部的调度。

调度器类的默认优先级顺序为：Stop_Task＞Real_Time＞Fair＞Idle_Task

<font color=red>普通</font>进程调度：

+ 采用SCHED_NORMAL调度策略。
+ 分配优先级、挑选进程并允许、计算使其运行多久
+ CPU运行时间与友好值（-20~+19）有关，数值越低优先级越高。

<font color=red>实时</font>进程调度：

+ <font color=blue>实时调度的进程比普通进程具有更高的优先级。</font>
+ SCHED_FIFO：进程若处于可执行的状态，就会一直执行，直到它自己被阻塞或者主动放弃CPU。
+ SCHED_RR：与SCHED_FIFO大致相同，只是进程在耗尽其时间片后，不能再执行，而是需要接受CPU的调度。