# 3. 处理机调度与死锁

## 3.1 处理机调度概述

### 3.1.1 处理机调度层次

+ 高级调度：长程调度/作业调度

  把后备作业调入内存，只调入一次，调出一次

+ 中级调度：中程调度/内存调度

  将进程调至外存，条件适合再调入内存，在内、外存对换区进行进程对换

+ 低级调度：短程调度/进程调度/处理机调度

  从就绪队列选取进程分配给处理机

  最基本的调度，频率非常高（相当于一个时间片完成）

**高级调度**

调度对象：<font color=red>作业</font>

根据某种算法，选中在外存后备队列中的作业，调入内存，并为其创建进程和分配必要的资源，再将新创建的进程排在就绪队列上等待调度。

主要用于多道批处理系统中。

**中级调度**

即<font color=red>对换</font>功能：

将暂不运行的进程，调至外存等待；将处于外存上的急需运行的进程，调入内存运行。

**低级调度**

调度对象：<font color=red>进程</font>

根据某种调度算法，决定就绪队列中的哪个进程应获得处理机。应用在于多道批处理、分时和实时OS。

### 3.1.2 进程调度的任务和方式

进程调度的任务：

+ 保存处理机的现场信息
+ 按某种算法选取进程
+ 把处理器分配给进程

进程调度机制（调度程序分为三部分）

+ 排队器：用于将就绪进程插入相应的就绪队列
+ 分派器：用于将选定的进程移出就绪队列
+ 上下文切换器：进行新旧进程之间的上下文切换

![image-20230929093610597](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309290937047.png)

进程调度的方式：非抢占方式、抢占方式。

<font color=red>非抢占方式</font>：一旦把处理机分配给某进程后，便让该进程一直执行，直至该进程完成或发生某事件而被阻塞时，才再把处理机分配给其他进程，决不允许某进程抢占已经分配出去的处理机。

<font color=red>抢占方式</font>：允许调度程序根据某种原则，去暂停某个正在执行的进程，将已分配给该进程的处理机重新分配给另一进程。(<font color=red>现代OS广泛采用</font>)

+ 优先权原则：允许优先权高的新到进程抢占当前进程的处理机
+ 短作业优先原则：短作业可以抢占当前较长作业的处理机
+ 时间片原则：各进程按时间片运行，当一个时间片用完后，便停止该进程的执行而重新进行调度

### 3.1.3 处理机调度算法的目标

共同目标：资源利用率、系统效率

批处理系统的目标：平均周转时间(Turnaround Time)短、系统吞吐量(Throughout)高、处理机利用率(CPU Utilization)高

分时系统的目标：响应时间快、均衡性

实时系统的目标：截止时间的保证、可预测性

$CPU利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$

### 3.1.4 评价指标

周转时间：从作业提交给系统开始，到作业完成为止的这段时间间隔。

+ <font color=red>平均周转时间</font>：$T=\frac{1}{n}(\sum^n_{i=1}T_i)$
+ <font color=red>带权周转时间</font>：权值为作业周转时间T与系统为之服务时间TS之比。$W=\frac{1}{n}(\sum^n_{i=1}\frac{T_i}{T_{S_i}})$
+ 平均带权周转时间

响应时间：从用户提交请求开始，直到系统首次显示出处理结果为止的一段时间。

<font color=blue>等待时间（进程调度）</font>：进程在就绪队列中等待调度的所有时间之和。

## 3.2 调度算法

### 3.2.1 作业调度算法

先来先服务调度算法（FCFS）、短作业优先调度算法（SJF）、优先级调度算法（PSA）、高响应比优先级调度算法（HRRN）。

### 3.2.2 进程调度算法

先来先服务调度算法（FCFS）、短作业优先调度算法（SJF）、优先级调度算法（PSA）、高响应比优先级调度算法（HRRN）、多级队列调度算法(MQ)、多级反馈队列调度算法(MFQ)、基于公平原则的调度算法(FS)、时间片轮转调度算法(RR)。

### 3.2.3 FCFS

先来先服务，First Come First Served，FCFS。

算法内容：调度<font color=red>作业/就绪</font>队列中最先入队者，等待操作完成或阻塞。

算法原则：按作业/进程到达顺序服务（执行）。

调度方式：非抢占式调度

适用场景：作业/进程调度

优点：<font color=red>有利于CPU繁忙型作业，充分利用CPU资源</font>

缺点：不利于I/O繁忙型作业，操作耗时

【FCFS举例】

情况1：假设作业到达顺序如下：J1、J2、J3，分别的运行时间为：24、3、3，则该调度的甘特图（Gantt）为：

![image-20230929161121551](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291611580.png)

那么

+ 平均等待时间 = (0 + 24 + 27)/3 = 17
+ 平均周转时间 = (24 + 27 + 30)/3 = 27
+ 平均带权周转时间 = (24/24 + 27/3 + 30/3)/3 = 6.7

情况2：假设作业到达顺序如下：J2、J3、J1，则该调度的甘特图（Gantt）为：

![image-20230929161536539](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291615564.png)

那么

+ 平均等待时间 = (6 + 0 + 3)/3 = 3
+ 平均周转时间 = (30+ 3 + 6)/3 = 13
+ 平均带权周转时间 = (30/24 + 3/3 + 6/3)/3 = 1.4

此结果产生是由于短进程先于长进程到达。

### 3.2.4 SJF

短作业优先，Shortest Job First，SJF。

算法内容：所需服务时间最短的<font color=red>作业/进程</font>优先服务（执行）

算法原则：追求最少的平均（带权）周转时间

调度方式：非抢占式

适用场景：作业/进程调度

优点：<font color=red>平均等待/周转时间最少</font>

缺点：长作业周转时间会增加、估计时间不准确，不能保证紧迫任务及时处理。

对于进程调度，SJF 有两种模式：

+ 非抢占式
+ 抢占式——抢占发生在有比当前进程剩余时间片更短的进程到达时，也称为最短剩余时间优先调度(SRTN) 

【举例】非抢占式 SJF

![image-20230929162112952](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291621986.png)

![image-20230929162132346](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291621376.png)

那么

+ 平均等待时间 = (0 + 6 + 3 + 7)/4 = 4
+ 平均周转时间=(7+10+4+11)/4= 8
+ 平均带权周转时间 = (7/7 + 10/4 +4/1+ 11/4)/4 = 2.5

【举例】抢占式 SJF

![](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291626775.png)

![image-20230929162438697](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291626261.png)

那么

+ 平均等待时间 = (9 + 1 + 0 +2)/4 = 3
+ 平均周转时间 = (16+ 5 +1+ 6)/4 = 7

### 3.2.5 PSA/PR

优先级调度，Priority-Scheduling Algorithm，PSA。

算法内容：又叫优先权调度，按<font color=red>作业/进程</font>的优先级（紧迫程度）进行调度

算法原则：优先级最高（最紧迫）的作业/进程先调度

调度方式：抢占/非抢占式（并不能获得及时执行）

适用场景：作业/进程调度

优点：实现简单，灵活

缺点：饥饿——低优先级的进程可能永远得不到运行

解决办法：老化——视进程等待时间的延长提高其优先数

优先级设置原则：

+ 静态/动态优先级
  + 静态：创建进程时确定优先数(整数)，在进程的整个运行期间保持不变
  + 动态：创建进程时先赋予其一个优先级，然后其值随进程的推进或等待时间的增加而改变
+ 系统 > 用户；交互型 > 非交互型；I/O型 > 计算型
+ 低优先级进程可能会产生“饥饿”

<font color=red>高响应比优先调度算法是一种优先级调度算法</font>，用于作业调度。	

【举例】非抢占式

![image-20230929163609117](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291636151.png)

![image-20230929163622829](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291636853.png)

那么

+ 平均等待时间 = (6 + 0 + 16+18+1)/5 =8.2
+ 平均周转时间 = (16 + 1 + 18+19+6)/5 = 12

#### HRRN

高响应比优先调度算法，Highest Response Ratio Next，HRRN，是PSA的特例。

算法内容：结合FCFS和SJF，综合考虑等待时间和服务时间计算响应比，高的优先调度

算法原则：综合考虑作业/进程的等待时间和服务时间

调度方式：非抢占式

适用场景：作业/进程调度

响应比计算：

+ 响应比 = （等待时间 + 服务时间）/ 服务时间
+ 只有当前进程放弃执行权（完成/阻塞）时，重新计算所有进程响应比
+ <font color=red>长作业等待越久响应比越高，更容易获得处理机</font>

HRRN 既考虑作业的等待时间，又考虑作业的运行时间

+ 如等待时间相同，运行时间越短，类似于SJF
+ 如运行时间相同，取决于等待时间，类似于FCFS
+ 长作业可随其等待时间的增加而提高响应比，从而得到调度

<font color=blue>优先级</font>：$优先级=\frac{等待时间+要求服务时间}{要求服务时间}$

<font color=blue>响应比</font>：$R_p=\frac{等待时间+要求服务时间}{要求服务时间}=\frac{响应时间}{要求服务时间}$

### 3.2.6 RR

时间片轮转，Round-Robin，RR。

算法内容：按<font color=red>进程</font>到达就绪队列的顺序，轮流分配一个<font color=red>时间片</font>去执行，时间用完则剥夺

算法原则：公平、轮流为每个进程服务，进程在一定时间内能得到响应

调度方式：抢占式，由<font color=red>时钟中断</font>确定时间到

适用场景：进程调度

优点：<font color=red>公平、响应快，适用于分时系统</font>

缺点：时间片太大，相当于FCFS；太小，处理机切换频繁，开销增大

+ 时间片：小单位的CPU时间，通常为10~100毫秒
+ 时间片决定因素：系统响应时间、就绪队列进程数量、系统处理能力

执行原理：为每个进程分配不超过一个时间片的CPU。时间片用完后，该进程将被抢占并插入就绪队列末尾，循环执行。

假定就绪队列中有n个进程、时间片为q, 则每个进程每次得到1/n的、不超过q单位的成块CPU时间，没有任何一个进程的等待时间会超过(n-1) q单位。

【举例】时间片为20

![image-20230929165128290](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291651333.png)

![image-20230929165142058](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291651100.png)

那么

+ 平均等待时间：(57+20+64+80)/4 = 55.25
+ 平均响应时间: (0+20+37+57)/4= 28.5
+ 通常，RR的平均周转时间比SJF长，但响应时间要优于SJF.

**时间片大小的确定**

<font color=red>一般准则：</font>时间片 / 10 > 进程上下文切换的时间。

### 3.2.7 MQ

多级队列调度，Multileveled Queue，MQ。

就绪队列从一个分为多个，每个队列有自己的调度算法，调度须在队列间进行。

+ 固定优先级调度，即前台运行完后再运行后台，有可能产生饥饿。
+ 给定时间片调度，即每个队列得到一定的CPU时间，进程在给定时间内执行；如80%的时间执行前台的RR调度，20%的时间执行后台的FCFS调度。

### 3.2.8 MFQ

多级反馈队列调度，Multileveled Feedback Queue，MFQ。

算法内容：设置多个优先级排序的就绪队列，优先级从高到低，时间片从小到大，前面队列不为空，不执行后续队列进程。新进程采用队列降级法

+ 进入第一级队列，按FCFS分时间片，没有执行完，移到第二级，第三级……

算法原则：集前几种算法优点

调度方式：抢占式

适用场景：进程调度

### 3.2.9 基于公平原则的调度算法

主要考虑调度的公平性。

<font color=blue>公平分享</font>调度算法，Fare-Share，FS。

+ 调度的公平性主要<font color=blue>针对用户</font>而言
+ 所有用户能获得相同的处理机时间或时间比例

<font color=red>保证调度算法（Guarantee）</font>

+ <font color=red>性能保证</font>，而非优先运行
+ 如保证处理机分配的公平性（处理机时间为1/n）

## 3.3 实时调度

实时调度是针对实时任务的调度。实时任务，都联系着一个截止时间。

根据实时任务性质分为

+ 硬实时HRT任务
+ 软实时SRT任务

根据调度方式分为

+ 非抢占式调度算法：响应时间为数秒至数十秒，可用于要求不太严格的实时控制系统
+ 抢占式调度算法：响应时间为数秒至数百毫秒，可用于有一定要求的实时控制系统
  + 基于时钟中断的抢占式优先级调度
  + 立即抢占的优先级调度

### 3.3.1 实时调度的基本条件

<span style="background-color:#00a4ff; color:yellow">1、提供必要的信息</span>

就绪时间、开始截止时间和完成截止时间、处理时间、资源要求、优先级。

<span style="background-color:#00a4ff; color:yellow">2、系统处理能力强</span>

单处理机系统、多处理机系统都满足。

<span style="background-color:#00a4ff; color:yellow">3、采用抢占式调度机制</span>

<span style="background-color:#00a4ff; color:yellow">4、 采用快速切换机制</span>

对中断具有快速响应能力，快速的任务分派能力。

### 3.3.2 EDF

最早截止时间优先调度，Earliest Deadline First，EDF。

EDF根据任务的截止时间确定优先级，截止时间越早，优先级越高。

既可用于抢占式调度，也可用于非抢占式调度

+ 非抢占式调度用于非周期实时任务
+ 抢占式调度用于周期实时任务

【举例】两个周期性实时任务A和B，任务A要求每20 ms执行一次，执行时间为10 ms，任务B要求每50 ms执行一次，执行时间为25 ms。

![image-20230929195434993](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291954050.png)

### 3.3.3 LLF

最低松弛度优先调度，LLF。

根据任务的紧急程度（<font color=red>松弛度</font>）确定任务优先级

+ 紧急程度越高（松弛度越低），优先级越高
+ $松弛度=必须完成时间－其本身的运行时间－当前时间$

主要用在抢占式调度方式中。

【举例】两个周期性实时任务A和B，任务A要求每20 ms执行一次，执行时间为10 ms，任务B要求每50 ms执行一次，执行时间为25 ms。

![image-20230929195658856](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291956900.png)

![image-20230929195706343](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309291957389.png)

### 3.3.4 优先级倒置现象

采用优先级调度和抢占方式，可能产生<font color=red>优先级倒置</font>。

现象：高优先级进程被低优先级进程延迟或阻塞。

**解决办法**：

+ 制定一些规定，如规定低优先级进程执行后，其所占用的处理机不允许被抢占；
+ 建立动态优先级继承。

## 3.4 Linux进程调度

默认调度算法：完全公平调度CFS算法。

基于调度器类：允许不同的可动态添加的调度算法并存，每个类都有一个特定的优先级。

总调度器：根据调度器类的优先顺序，依次对调度器类中的进程进行调度。

调度器类：使用所选的调度器类算法（调度策略）进行内部的调度。

调度器类的默认优先级顺序为：Stop_Task＞Real_Time＞Fair＞Idle_Task

<font color=red>普通</font>进程调度：

+ 采用SCHED_NORMAL调度策略。
+ 分配优先级、挑选进程并允许、计算使其运行多久
+ CPU运行时间与友好值（-20~+19）有关，数值越低优先级越高。

<font color=red>实时</font>进程调度：

+ <font color=blue>实时调度的进程比普通进程具有更高的优先级。</font>
+ SCHED_FIFO：进程若处于可执行的状态，就会一直执行，直到它自己被阻塞或者主动放弃CPU。
+ SCHED_RR：与SCHED_FIFO大致相同，只是进程在耗尽其时间片后，不能再执行，而是需要接受CPU的调度。

## 3.5 死锁概述

### 3.5.1 死锁概念

<font color=red>死锁</font>（Deadlock）：指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，这些进程都将永远不能再向前推进。

### 3.5.2 资源问题

可重用性资源和可消耗性资源

+ 可重用性资源：一次只能分配给一个进程，不允许多个进程共享，遵循：请求资源、使用资源、释放资源（大部分资源）
+ 可消耗性资源：由进程动态创建和消耗（进程间通信的信息）

可抢占性和不可抢占性资源

+ 可抢占性资源：某进程在获得这类资源后，该资源可以再被其他进程或系统抢占，**CPU和主存区**
+ 不可抢占资源：当系统把这类资源分配个某进程后，再不能强行收回，只能在进程用完后自行释放，**打印机、磁带机**

### 3.5.3 死锁原因

<font color=blue>竞争不可抢占性资源</font>：系统中的不可抢占性资源，由于它们的数量不能满足诸进程运行的需要，会使进程在运行过程中，因争夺这些资源而陷入僵局。

<font color=red>竞争可消耗性资源</font>

<font color=red>进程推进顺序不当</font>

### 3.5.4 产生死锁的必要条件

<font color=red>互斥</font>：一段时间内某资源只能被一个进程占用。

<font color=red>请求和保持</font>：一个至少持有一个资源的进程等待获得额外的由其他进程所持有的资源。

<font color=red>不可抢占</font>：一个资源只有当持有它的进程完成任务后，自由的释放。

循环等待：等待资源的进程之间存在环

+ P0等待P1的资源，P1等待P2的资源，……，Pn-1等待Pn的资源，Pn等待P0的资源

### 3.5.5 处理死锁的方法

确保系统永远不会进入死锁状态：

+ 死锁预防：破坏死锁的四个必要条件中一个或几个
+ 死锁避免：在资源动态分配时，防止系统进入不安全状态

允许系统进入死锁状态，然后恢复系统

+ 死锁检测：事先不采取任何措施，允许死锁发生，但及时检测死锁发生
+ 死锁恢复：检测到死锁发生时，采取相应措施，将进程从死锁状态总解脱出来

忽略这个问题，假装系统中从未出现过死锁。这个方法被大部分操作系统采用，包括UNIX。

## 3.6 预防死锁

破坏死锁的四个必要条件中一个或几个

+ 互斥：共享资源必须的，不仅不能改变，还应加以保证
+ 请求和保持：必须保证进程申请资源的时候没有占有其他资源
+ 非抢占：如果一个进程的申请没有事先，它要释放所有占有的资源
+ 循环等待：对所有的资源类型排序进行线性排序，并赋予不同的序号，要求进程按照递增顺序申请资源

## 3.7 避免死锁

<font color=red>死锁避免算法</font>动态检查资源分配状态以确保不会出现循环等待的情况。

资源分配状态定义为可用的与已分配的资源数，和进程所需的最大资源量。

### 3.7.1 安全状态

当进程申请一个有效的资源的时候，系统必须确定分配后是安全的。

<font color=red>如果存在一个安全序列，则系统处于安全状态</font>

进程序列 <P1, P2, ..., Pn> 是安全的，如果每一个进程 Pi 所申请的可以被满足的资源数加上其他进程所持有的该资源数小于系统总数

+ 如果 Pi 需要的资源不能马上获得，那么 Pi 等待直到所有的 Pi-1 进程结束
+ 当 Pi-1 结束后，Pi 获得所需资源，执行、返回资源、结束
+ 当 Pi 结束后，Pi+1 获得资源，执行……

**基本事实**

+ 如果一个系统在安全状态，就没有死锁；否则，可能死锁。

==死锁避免：确保系统永远不会进入不安全状态。==

### 3.7.2 资源分配图

**系统模型**

资源类型 R1、R2、……、Rm：CPU周期、内存空间、I/O设备

每一种资源Ri有Wi种实例

每一个进程通过如下方法来使用资源：申请、使用、释放

#### 组成

一个顶点的集合V和边的集合E

V被分为两个部分

+ P={P1，P2，……，Pn}，含有系统中全部的进程
+ R={R1，R2，……，Rn}，含有系统中全部的资源

请求边：有向边Pi --> Rj

分配边：有向边Rj --> Pi

无死锁的资源分配图：

![image-20231001103914254](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310011039383.png)

有死锁的资源分配图：

![image-20231001104029855](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310011040963.png)

**基本事实**

+ 如果图没有环，那么不会有死锁
+ 如果图有环，那么
  + 如果每一种资源类型只有一个实例，那么死锁发生
  + 如果一种资源类型有多个实例，那么可能死锁

## 3.8 死锁的检测与解除

当系统为进程分配资源时，若未采取任何限制性措施，则系统必须提供检测和解除死锁的手段。为此，系统必须：

+ 保存有关资源的请求和分配信息
+ 提供一种算法，以利用这些信息来检测系统是否已进入死锁状态

### 3.8.1 资源分配图的简化

在资源分配图中，找出一个既不阻塞又非独立的进程节点Pi。在顺利的情况下，Pi可获得所需资源而继续运行，直至运行完毕，再释放其所占有的全部资源，这相当于消去Pi所有的请求边和分配边，使之成为孤立的节点

P1释放资源后，便可使P2获得资源而继续运行，直到P2完成后又释放出它所占有的全部资源；

在进行一系列的简化后，若能消去图中所有的边，使所有进程都成为孤立节点，则称该图是可完全简化的；若不能通过任何进程使该图完全简化，则称该图不可完全简化。

### 3.8.2 死锁定理

<font color=red>所有的简化顺序，都将得到相同的不可简化图。</font>

S为死锁状态的充分条件是：当且仅当S状态的资源分配图是不可完全简化的。该充分条件称为<font color=blue>死锁定理</font>。

### 3.8.3 死锁的解除

常用解除死锁的两种方法

+ 抢占资源：从一个或多个进程中抢占足够数量的资源给死锁进程
+ 终止或撤销进程：终止系统中一个或多个死锁进程，直到打破循环环路，使死锁状态消除为止
  + 终止所有死锁进程（最简单方法）
  + 逐个终止进程（稍温和方法）

