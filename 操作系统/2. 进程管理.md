# 进程管理

## 一、进程描述与进程控制

### 1.1 前趋图和程序执行

程序顺序执行：一个较大的程序通常都由若干个程序段组成。程序在执行时，必须按照某种先后次序逐个执行。

<font color=red>前趋图</font>：有向无循环图，用于描述进程之间执行的先后顺序。节点表示进程或程序段，有向边表示前趋关系。

**多道程序设计**：同一时刻内存中存放了多个作业，处理器交替运行不同的作业。提高了系统的效率，尤其是资源利用率。

程序并发执行：采用多道程序技术，将多个程序同时装入内存，使之并发运行。

+ 特征：间断性、失去封闭性、不可再现性

结论：程序的并发执行使得程序的执行情况不可预见，其结果不再唯一，成为一个动态的过程。而程序是一个静态的概念，不再能切实反映程序执行的各种特征，（独立性、并发性、动态性）。

### 1.2 进程的描述

定义：进程是一个具有独立功能的程序，关于某个数据集合的一次运行活动，是系统进行**资源分配**和**调度**的一个独立单位。

要点：

+ 进程是<font color=red>程序</font>的<font color=red>一次执行</font>过程
+ 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。
+ 进程是程序在一个<font color=red>数据集合</font>上运行的一次过程，它是系统进行资源分配和调度的一个独立单位。

<font color=blue>进程控制块</font>（Process Control Block，<font color=blue>PCB</font>）：专门的数据结构，与进程一一对应。

**进程的组成**

+ PCB（Process Control Block ）：灵魂，进程存在的唯一标志
+ *实体*：代码 + 数据
  + 程序：描述了进程要完成的功能，是进程执行时不可修改的部分。
  + 数据：进程执行时用到的数据（用户输入的数据、常量、静态变量）。
+ 工作区：参数传递、系统调用时使用的动态区域（堆栈区）。

**进程的特征**

+ 动态性：最基本的特征，生命期
+ 并发性：一段时间内同时运行
+ 独立性：进程实体是一个能独立运行的基本单位，是系统中独立获得资源和独立调度的基本单位
+ 异步性：按各自独立的、不可预知的速度向前推进
+ 结构性、制约性、共享性等

**进程和程序的区别**

+ 生命周期：进程是程序的一个实例，是程序的一次执行过程。<font color=red>进程是活动的，程序是静态的，是代码的集合。</font>
+ 结构：程序是进程的代码部分。对应关系不同：可1 : 1，1 : N，N : 1
+ 位置：进程在内存中，程序在外存中。

**进程控制块PCB**

PCB是进程的一部分，是操作系统为每个进程定义的一个<font color=red>记录型数据结构</font>，是进程存在的唯一标志，常驻内存。

PCB中记录了用于<font color=red>描述进程的当前状态</font>以及<font color=red>OS控制进程运行所需</font>的全部信息。

PCB的作用是使一个在多道程序环境下不能独立运行的程序，成为一个能与其它进程并发执行的进程。

**PCB的信息**

+ 进程标识符
  + 内部标识符PID：一个唯一的正整数标识符
  + 外部标识符UID：它由创建者提供，由用户(进程)在访问该进程时使用。
  + 父进程标识符PPID
+ 处理机状态
  + 当处理机被中断时，所有这些信息都必须保存在PCB中，以便在该进程重新执行时，能从断点继续执行。
+ 进程调度信息
  + 进程状态：当前是运行、就绪还是阻塞
  + 进程优先级：优先级高的进程先被调度
  + 调度所需的其它信息：比如，已等待CPU的时间
  + 事件：进程等待发生的事件，即阻塞原因
+ 进程控制信息
  + 代码和数据的地址：内存或外存地(首)址
  + 进程同步和通信机制：如消息队列指针、信号量等
  + 资源清单：列出了所需资源及已经分配到的资源
  + 链接指针：指向本进程PCB所在队列中的下一个进程的PCB

**PCB的组织管理**

+ 线性方式
+ 链接方式
+ 索引方式

**PCB管理方式**

操作系统对PCB的管理：PCB表常驻内存，集中统一管理；PCB中部分常驻内存（proc），部分（user）存于辅存。

### 1.3 进程的状态与控制

就绪状态：已分配到除CPU以外的所有必要资源，只缺CPU；处于就绪状态的进程可能有多个，在就绪队列中排队

<font color=red>执行状态</font>：已获得CPU，正在执行的状态

+ 单处理机：一个进程处于执行状态
+ 多处理机：多个进程处于执行状态

阻塞状态：正在执行的进程由于发生某事件而暂时无法继续执行的状态

三种状态的转换：

![image-20230928161207037](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309281614877.png)

**创建状态和终止状态**

创建状态：申请一个空白PCB；填写PCB；分配资源；设置就绪状态插入就绪队列

终止状态：等待OS善后；收回PCB。

五种状态的相互转换：

![image-20230928161412800](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309281614842.png)

**挂起状态**

暂停正在执行的进程，或暂不调度正处于就绪状态的进程，使其处于静止的一种状态。（从内存调至交换区）

导致挂起状态的原因：

+ 终端用户的请求
+ 父进程请求
+ 负荷调节的需要
+ 操作系统的需要

七种状态的相互转换：

![image-20230928161617622](https://gitee.com/LowProfile666/image-bed/raw/master/img/202309281616674.png)

### 1.4 进程控制

进程控制的任务：进程控制是对系统中所有进程从产生、存在到消亡的全过程实行有效的管理和控制。进程控制一般是由操作系统的内核来实现，内核在执行操作时，往往是通过执行各种原语操作来实现的。

进程控制的机构：OS的内核中的原语(Primitive) 。

**内核、原语、进程图**

<font color=red>内核</font>：加在硬件上的第一层软件，通过执行各种原语操作来实现各种控制和管理功能，具有创建、撤消、进程通信、资源管理的功能。基本功能：

+ 支撑功能：中断处理、时钟管理、原语操作
+ 资源管理功能：进程管理、进程通信、存贮管理、设备管理

<font color=blue>原语</font>：由若干条机器指令构成的可完成特定功能的程序段，它是一个 “原子操作(atomic operation)” 过程，作为一个整体而不可分割－－要么全都完成，要么全都不做（类似数据库中的“事务”）。原语主要是通过屏蔽各种中断和固化技术保证其原子性的。

原语分类

+ 进程控制原语
+ 进程通信原语
+ 进程管理原语
+ 其他方面的原语

<font color=blue>进程图</font>：用于描述一个进程的家族关系的有向树。结点代表进程。一棵树表示一个家族，根结点为该家族的祖先(Ancestor)。

OS加载到内存后首先创建一个根进程，再由这个根进程通过系统调用创建一系列子进程和子孙进程，从而形成一颗进程树。子进程能继承父进程得到的系统资源。创建子进程时，有两种执行可能：

+ 父子并发执行
+ 父进程等待，直到某个或全部子进程运行结束

进程管理最基本的功能，一般由OS内核中的原语实现，包括：

+ 进程创建

  + <font color=blue>通过执行fork()原语创建进程，执行create( )原语创建线程</font>
  + 过程：申请空白PCB；分配所需资源；初始化PCB；插入就绪队列。

+ 进程终止

  引起进程终止的事件

  + 正常结束（主动）
  + 异常结束（主动）
  + 异常结束（被动）
  + 外界干预

+ 进程阻塞与唤醒

  引起进程阻塞的事件

  + 请求系统服务、启动某种操作、新数据尚未到达、无新工作可做

  阻塞可认为是进程自身的一种主动行为：通过调用阻塞原语block，将自己阻塞，放弃CPU的使用。

  进程唤醒是一种被动行为——由别人唤醒：其他进程调用唤醒原语wakeup，将等待该事件的进程唤醒。

+ 进程挂起与激活

  挂起功能（suspend）：自身挂起、挂起具有指定标识符的进程、将其进程及其全部或部分“子孙”挂起。

  激活功能（activate）：使处于静止状态的进程变为活动。

  挂起过程：<font color=blue>检查要被挂起进程的状态，若处于活动就绪态就修改为挂起就绪态，若处于活动阻塞态，则修改为挂起阻塞态。被挂起的进程要<font color=red>交换到磁盘交换区</font></font>。

  当系统资源尤其是内存资源充裕或进程请求激活指定进程时，系统或有关进程会调用激活（解挂）原语把指定进程激活。

  激活过程：<font color=blue>把进程调入内存，然后修改它的状态，挂起阻塞态改为阻塞态，挂起就绪态改为就绪态，并分别插入相应队列中。</font>

### 1.5 进程通信

进程通信是指进程之间的信息交换。

+ 低级进程通信：进程的同步和互斥
  + 效率低，通信对用户不透明
+ 高级进程通信：
  + 使用方便，高效地传送大量数据

#### 1.5.1 进程通信的类型

共享存储器系统

+ 基于共享数据结构的通信方式（效率低）
+ 基于共享存储区的通信方式（高级）

管道通信

+ 管道：用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，又名pipe文件。
+ 管道机制的协调能力：互斥、同步、对方是否存在

消息传递系统

+ 直接通信方式
+ 间接通信方式（通过邮箱）

客户机-服务器系统

+ 套接字（Socket）
+ 远程过程调用（RPC）和远程方法调用（RMI，Java）

#### 1.5.2 消息传递通信的实现方式

直接通信方式

+ 发送原语：send(receiver, message)
+ 接收原语：receive(sender, message)

间接通信方式：通过信箱来完成

+ 发送原语：send(mailbox, message)
+ 接收原语：receive(mailbox, message)
+ 信箱类型：私用、公共、共享邮箱

#### 1.5.3 Linux进程通信方式

管道、信号、消息队列、共享内存、信号量、套接字。

### 1.6 线程的基本概念

60年代中期：提出进程概念

80年代中期：提出线程概念

提出线程的目的：

+ 减少程序在并发执行时所付出的时空开销
+ 使OS具有更好的并发性
+ 适用于SMP结构的计算机系统

<font color=blue>进程</font>是拥有资源的基本单位（传统进程称为重型进程）；<font color=red>线程</font>作为调度和分派的基本单位（又称为轻型进程）。线程依附于进程存在。

#### 1.6.1 进程和线程的比较

<font color=red>调度</font>的基本单位：

+ 在传统的OS中，拥有资源、独立调度和分派的基本单位都是进程。
+ 在引入线程的OS中，线程作为调度和分派的基本单位，进程作为资源拥有的基本单位。
+ 在同一进程中，线程的切换不会引起进程切换，在由一个进程中的线程切换到另一个进程中的线程时，将会引起进程切换。

并发性：

+ 在引入线程的OS中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间，也可以并发执行。

拥有资源：

+ 进程是系统中拥有资源的一个基本单位，它可以拥有资源
+ 线程本身不拥有系统资源，仅有一点保证独立运行的资源
+ 允许多个线程共享其隶属进程所拥有的资源

<font color=red>独立性</font>

+ 同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。

系统开销：

+ 在创建或撤销进程时，OS所付出的开销将显著大于创建或撤销线程时的开销
+ 线程切换的代价远低于进程切换的代价
+ 同一进程中的多个线程之间的同步和通信也比进程的简单

支持多处理系统

#### 1.6.2 线程的状态和线程控制块

线程状态

+ 执行态、就绪态、阻塞态
+ 线程状态转换与进程状态转换一样

<font color=red>线程控制块</font>（thread control block，TCB）

+ 包含了：线程标识符、一组寄存器、线程运行状态、优先级、线程专有存储区、信号屏蔽、堆栈指针

### 1.7 线程的实现

实现方式：

+ 内核支持线程KST：利用系统调用
+ 用户级线程ULT：借助中间系统
+ 组合方式

#### 1.7.1 内核支持线程KST

在内核空间实现。

优点：

+ 在多处理机系统中，内核可同时调度同一进程的多个线程
+ 线程的切换比较快，开销小
+ 内核本身可采用多线程技术，提高执行速度和效率

缺点：

+ 对用户线程切换，开销较大

#### 1.7.2 用户级线程ULT

在用户空间实现。

优点：

+ 线程切换不需要转换到内核空间
+ 调度算法可以是进程专用
+ 线程的实现与OS平台无关

缺点：

+ 系统调用的阻塞问题
+ 多线程应用不能利用多处理机进行多重处理的优点

#### 1.7.3 ULT和KST组合方式

多对一模型、一对一模型、多对多模型

**多对一模型**

<font color=red>多个用户级线程映射到一个内核线程。</font>

多个线程不能并行运行在多个处理器上。

线程管理在用户态执行，因此是高效的，但一个线程的阻塞系统调用会导致整个进程的阻塞。

用于不支持内核线程的系统中。

**一对一模型**

<font color=red>每个用户级线程映射到一个内核线程。</font>

比多对一模型有更好的并发性。

允许多个线程并行运行在多个处理器上。

创建一个ULT需要创建一个KST，效率较差。

**多对多模型**

<font color=red>多个用户级线程映射为相等或小于数目的内核线程</font>

允许操作系统创建足够多的KST。