# 第一章 计算机系统概述

## 1.1 计算机的发展

![image-20230514112949006](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%8F%91%E5%B1%95.png)

**什么是计算机系统**

计算机系统 = 硬件 + 软件

+ 软件分为：系统软件和应用软件

**硬件的发展 **

第一台电子数字计算机：ENIAC（1946）

| **阶段**          | **基本电子逻辑器件**         | **存储**                         | **特点**                          |
| ----------------- | ---------------------------- | -------------------------------- | --------------------------------- |
| 第一代(1946-1957) | 电子管                       | 存储器采用水银延迟线(外存: 纸带) | 机器语言和汇编语言(低级语言)      |
| 第二代(1958-1964) | 晶体管                       | 存储器采用磁芯和磁鼓(外存: 磁盘) | 提出了操作系统的概念,出现高级语言 |
| 第三代(1964-1971) | 集成电路(中, 小规模继承电路) | 第一次采用半导体                 | 出现操作系统                      |
| 第四代(1972-至今) | 大, 超大规模继承电路         | 半导体                           | 出现微型计算机(**微机**)          |

**摩尔定律：**集成电路上可容纳的晶体管数目，约每隔18个月便会增加一倍，整体性能也将提升一倍。揭示了信息技术进步的速度。

**目前的发展趋势**

两极分化：

+ 微型计算机：向更微型化、网络化、高性能、多用途方向发展。
+ 巨型计算机：向更巨型化、超高速、并行处理、智能化方向发展。

## 1.2.1 计算机硬件的基本组成

![image-20230514182243730](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A1%AC%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png)

ENIAC是由程序员手动接线来控制计算，而后冯诺依曼提出了“存储程序”原理，第一台采用冯诺依曼结构的计算机是EDCAV（Electronic Discrete Variable Automatic Computer）。

==存储程序==的概念是指<span style="color:red">将指令以二进制代码的形式事先输入计算机的主存储器</span>，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。

早期冯诺依曼机：

![image-20230514180704498](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E6%97%A9%E6%9C%9F%E5%86%AF%E8%AF%BA%E4%BC%8A%E6%9B%BC%E6%9C%BA.png)

在计算机系统中， ==软件和硬件在逻辑上是等效的==。

冯诺依曼计算机的特点：

+ 计算机由五大部件组成
+ 指令和数据以同等地位存于存储器，可按地址寻访
+ 指令和数据用二进制表示
+ 指令由操作码和地址码组成
+ 存储程序
+ ==以运算器为中心==

现代计算机的结构：

![image-20230514181409216](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%93%E6%9E%84.png)

现代计算机：==以存储器为中心==。

## 1.2.2 各个硬件的工作原理

![image-20230514212555429](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E5%90%84%E7%A1%AC%E4%BB%B6%E9%83%A8%E4%BB%B6.png)

### **主存储器的基本组成**

![image-20230514205018839](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png)

+ 存储体：用来存放数据
+ MAR（Memory Address Register）：存储地址寄存器
+ MDR（Memory Data Register）：存储数据寄存器

注：现在的计算机通常把MAR、MDR也集成在CPU内。

**存储体**

数据在存储体内按地址存储。存储体被分为一个一个的存储单元，每个地址对应一个存储单元。

==存储单元==：每个存储单元存放遗传二进制代码。

==存储字（word）==：存储单元中二进制代码的组合。

==存储字长==：存储单元中二进制的位数。

存储元：即存储二进制的电子元件，每个存储元可存 1bit。

MAR位数反映存储单元的个数（最多支持多少个）。比如：MAR = 4位 $\longrightarrow$ 总共有 2^4^ 个存储单元

MDR位数 = 存储字长 = 每个存储单元的大小。比如：MDR = 16位 $\longrightarrow$ 每个存储单元可存放 16bit，一个字（word）= 16bit。

### **运算器的基本组成**

运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）。

![image-20230514205521621](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E8%BF%90%E7%AE%97%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png)

ACC（Accumulator）：累加器，用于存放操作数，或运算结果。

MQ（Multiple-Quotient Register）：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。

X：通用的操作数寄存器，用于存放操作数。

==ALU==（Arithmetic and Logic Unit）：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算。

### 控制器的基本组成

![image-20230514210452364](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90.png)

==CU==（Control Unit）：控制单元，分析指令，给出控制信号。

IR（Instruction Register）：指令寄存器，存放当前执行的指令。

PC（Program Counter）：程序计数器，存放下一条指令地址，有自动加1功能。

完成一条指令有三个步骤：

+ 取指令：PC
+ 分析指令：IR
+ 执行指令：CU

### 计算机的工作工程

![image-20230514213042679](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%B7%A5%E7%A8%8B.png)

## 1.2.3 计算机系统的层次结构

![image-20230514215944073](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png)

计算机系统的层次结构：

![image-20230514214804934](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%843.png)

==下层是上层的基础，上层是下层的扩展==。

三种级别的语言：

+ 机器语言：二进制代码。
+ 汇编语言：助记符。通过汇编程序（汇编器）转为机器语言。
+ 高级语言：通过编译程序（编译器）转为汇编语言，或有的高级语言直接通过编译程序（编译器）转为机器语言，有的通过解释程序（解释器）转为机器语言。

注：编译、汇编、解释程序，可统称为“翻译程序”。

## 1.3 计算机的性能指标

![image-20230514224011362](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87.png)

### 存储器的性能指标

<span style="color:red">总容量 = 存储单元个数 $\times$ 存储字长 (bit) </span> 。

【例题】MAR为32位，MDR为8位，那么总容量 = 2^32 \* 8bit = 4 GB。

+ MAR位数反映存储单元的个数（最多支持多少个）。比如：MAR = 4位 $\longrightarrow$ 总共有 2^4^ 个存储单元
+ MDR位数 = 存储字长 = 每个存储单元的大小。比如：MDR = 16位 $\longrightarrow$ 每个存储单元可存放 16bit，一个字（word）= 16bit。

### CPU的性能指标

<span style="color:red">CPU主频（时钟频率）</span>：CPU内数字脉冲信号振荡的频率。

CPU主频（时钟频率）=  $\frac{1}{cpu时钟周期}$ ，单位：赫兹，Hz

+ CPU时钟周期：每个脉冲信号的时间，单位 ：微秒，纳秒。
+ CPU主频为 10Hz 表示 每秒钟有10个脉冲信号。

<span style="color:red">CPI</span>（Clock  cycle Per Instruction）：执行一条指令所需的时钟周期数。

+ 不同的指令，CPI不同。甚至相同的指令，CPI也可能有变化。

<span style="color:red">执行一条指令的耗时</span> = CPI $\times$ CPU时钟周期。

【例题】某CPU主频为1000Hz，某程序包含100条指令，平均来看指令的CPI=3，该程序在该CPU上执行需要多久？

【答】$100\times 3 \times \frac{1}{1000} = 0.3s$ 。

<span style="color:red">CPU执行时间</span>（整个程序的耗时）=  CPU时钟周期数/主频 = （指令条数 $\times $ CPI）/ 主频。

<span style="color:red">IPS</span>（Instruction Per Second）：每秒执行多少条指令。$IPS=\frac{主频}{平均CPI}$ 。

+ 还有KIPS，MIPS

<span style="color:red">FLOPS</span>（Floating-point Operations Per Second）：每秒执行多少次浮点运算。

+ 还有KFLOPS，MFLOPS，GFLOPS，TFLOPS

注：此处 K、M、G、T 为数量单位，K = Kilo = 千 = 10^3^，M = Million = 百万 = 10^6^，G = Giga = 十亿 = 10^9^，T = Tera = 万亿 = 10^12^

### 系统整体的性能指标

**数据通路带宽**：数据总线一次所能并行传送的信息的位数（各硬件部件通过数据总线传输数据）。

**吞吐量**：指系统在单位时间内处理请求的数量。

+ 它取决于信息能多块地输入内存，CPU能多块地取指令、数据能多块地从内存取出或存入，以及所得结果能多块地从内存送给一台外部设备。这些步骤中的每一步都关系到主存，因此，系统吞吐量主要取决于主存的存取周期。

**响应时间**：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的结果的等待时间。

+ 通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I/O操作、操作系统开销等时间）。

<span style="color:red">基准程序</span>是用来测量计算机处理速度的一种实用程序，以便于被测量的计算机性能可以与运行相同程序的其他计算机性能进行比较。

---

# 第二章 数据的表示和运算

## 2.1.1 进位计数制

![image-20230516150811545](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E8%BF%9B%E4%BD%8D%E8%AE%A1%E6%95%B0%E5%80%BC.png)

### 十进制计数法

古印度人发明的阿拉伯数字：0，1，2，3，4，5，6，7，8，9。（符号反映权重）

十进制计数法是基于“乘法”思想的计数方法，有 0~9 共 10 个符号，==逢十进一==。

比如一个十进制数：975 = 9 \* 100 + 7 \* 10 + 5 \* 1 
											 	 = 9 \* 10^2^ + 7 \* 10^1^ + 5 \* 10^0^ 。

一个十进制小数：975.36 =  9 \* 100 + 7 \* 10 + 5 \* 1 + 3 \* 0.1 + 6 \* 0.01 
												    = 9 \* 10^2^ + 7 \* 10^1^ + 5 \* 10^0^ + 3 \* 10^-1^ + 6 \* 10^-2^ 。

可以发现，975.36 的每个符号所在的位置也在反映权重，这种位置反映的权重称为==位权==。

### r 进制计数法

r 进制：

$K_nK_{n-1}...K_2K_1K_0K_{-1}K_{-2}...K_{-m}$ 
	= $K_n \times r^n+K_{n-1} \times r^{n-1} + ... +K_2 \times r^2+K_1 \times K_1 \times r^1+K_0 \times r^0+K_{-1} \times r^{-1} +K_{-2}\times r^{-2}+...+K_{-m}\times r^{-m}$ 

==基码==：每个数码位所用到的不同符号的个数，r 进制的基数为 r。

### 进制转换

**任意进制转为十进制**：按位权展开相加即可。

比如 r 进制： $K_nK_{n-1}...K_2K_1K_0K_{-1}K_{-2}...K_{-m}$ 
	= $K_n \times r^n+K_{n-1} \times r^{n-1} + ... +K_2 \times r^2+K_1 \times K_1 \times r^1+K_0 \times r^0+K_{-1} \times r^{-1} +K_{-2}\times r^{-2}+...+K_{-m}\times r^{-m}$ 

**二进制转为八进制**：3 位二进制位为一组，每组转换成对应的八进制符号。

**二进制转为十六进制**：4 位二进制位一组，每组转换成对应的十六进制符号。

**八进制转为二进制**：每位八进制转为 3 位二进制。

**十六进制转为二进制**：每位十六进制数转为 4 位二进制。

**十进制转为 r 进制**：

+ 整数部分：除基取余法
+ 小数部分：乘基取整法
+ 拼凑法

### 真值和机器数

**真值**：符合人类习惯的数字。

**机器数 **：数字实际存到机器里的形式，正负号需要被数字化。

## 2.1.2 BCD码

BCD：Binary-Coded Decimal，用二进制编码的十进制。

![image-20230516154410008](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84BCD%E7%A0%81.png)

### 8421码

有权码。

8421码的映射关系：

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 |

比如要用8421码表示十进制数 985 为：100110000101。

**8421码的加法**

如果两个数相加，得到的结果不在8421码的映射表中（0000~1001），那么需要向结果上加一个 6 ，然后得到正确结果。

比如：

``` 
十进制：  5    +   8   = 13
8421码：0101  +  1000 = 1101（这个结果不在映射表里，所以需要再加 6）
1101 + 0110 = 0001 0011
十进制：		 1	  3
此时得到的结果就是正确的。
```

### 余 3 码

无权码。

余 3 码：8421码 + (0011)~2~ 。

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0011 | 0100 | 0101 | 0110 | 0111 | 1000 | 1001 | 1010 | 1011 | 1100 |

### 2421码

有权码。

2421码：改变权值定义。

| 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| 0000 | 0001 | 0010 | 0011 | 0100 | 1011 | 1100 | 1101 | 1110 | 1111 |

规定：在 5 和 5 之后的所有数，首位必须是 1。

## 2.1.3 无符号整数的表示和运算

![image-20230516161210626](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97.png)

**无符号整数**，即“自然数”：0，1，2，3，4……

C语言中的无符号整数 ：

```c
unsigned int a = 1;    // 无符号整数（整型，占4B）
unsigned short b = 1;  // 无符号整数（短整型，占2B） 
```

### 无符号整数的表示

机器字长限定了每次能进行多少bit的运算，也限制了计算机内部通用寄存器总共有多少bit。

以机器字长为 8 bit为例。

无符号整数：

+ 没有符号位。全部二进制位都是数值位，第 i 位的位权是 2^i-1^ 。
+ n bit 无符号整数表示范围为 0~2^n-1^ 。超出则会溢出，意味着计算机无法一次处理这么多。
+ 可以表示的最小的数为 全0，可以表示的最大的数为 全1。

### 无符号整数的运算

加法：从最低位开始，按位相加，并往更高位进位。

减法：

1. “被减数”不变，“减数”全部位按位取反，末位 +1，减法变加法。
2. 从最低位开始，按位相加，并往更高位进位。

![image-20230516160809780](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%95%B0%E7%9A%84%E5%87%8F%E6%B3%95.png)

## 2.1.4 带符号整数的表示和运算——原反补

![image-20230516171013634](C:/Users/20620/AppData/Roaming/Typora/typora-user-images/image-20230516171013634.png)

带符号整数，即“整数”，-2，-3，0，1，2，3……

C语言中的带符号整数：

```c
short a = 1;  // 带符号整数（短整型，占2B）
int b = -2;   // 带符号整数（整型，占4B）
```

### 带符号整数的表示

还是以机器字长为 8 bit为例。

#### 原码表示

![image-20230516163113939](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E5%B8%A6%E7%AC%A6%E5%8F%B7%E6%95%B4%E6%95%B0%E9%A2%9D%E5%8E%9F%E7%A0%81%E8%A1%A8%E7%A4%BA.png)

+ 符号位 “0/1” 对应 “正/负”，剩余的数值位表示真值的绝对值。
+ 若机器字长 n+1 位，带符号整数的原码表示范围为：$-(2^n-1)\leq x\leq 2^n-1$ 。
+ ==真值 0 有两种形式==：+0 和 -0，[+0]原 = 0,0000000，[-0]原 = 1,0000000。

常见的书面写法：x = -19	[x]~原~ = 1, 0010011

若未指明机器字长，也可以写为：[x]~原~ = 1, 10011

**原码的缺点：**<span style="color:red">符号位不能参与运算</span>，需要设计复杂的硬件电路才能处理。

#### 补码表示

用补码表示真值——==符号位可以参与运算==。

**原码—>反码—>补码的转换**

+ 原码更便于人类理解
+ 补码更便于计算机运算
+ 反码是原码转补码的中间状态

正数：三码合一，原码、反码、补码都是一样的。

负数：

1. 原码—>反码：符号位不变，数值位取反
2. 反码—>补码：末位 +1

**原码、补码快速转换技巧**

负数：

+ 在原码上，==从右往左找到第一个 1 ，这个 1 的左边的所有 ”数值位“ 按位取反==，得到补码
+ 补码 — 取反 +1—> 原码

### 带符号整数的运算

加法：从最低位开始，按位相加（符号位参与运算），并往更高位进位。

补码的数值位不能解读为”位权“。

减法：

1. “被减数”不变，“减数”全部位按位取反，末位 +1，减法变加法。
2. 从最低位开始，按位相加，并往更高位进位。

补码的减法就是：$[A]_补-[B]_补=[A]_补+[-B]_补$ 

## 2.1.5 原反补码的特性对比

各码的基本特性

| n + 1 bit        | 合法表示范围               | 最大的数                 | 最小的数                    | 真值 0 的表示                                          |
| ---------------- | -------------------------- | ------------------------ | --------------------------- | ------------------------------------------------------ |
| 带符号整数：原码 | $-(2^n-1) \le x \le 2^n-1$ | **0**,111...111 = 2^n^-1 | **1**,111...111 = -(2^n^-1) | [+0]~原~=**0**,000...000<br />[-0]~原~=**1**,000...000 |
| 带符号整数：反码 | $-(2^n-1) \le x \le 2^n-1$ | **0**,111...111 = 2^n^-1 | **1**,000...000 = -(2^n^-1) | [+0]~反~=**0**,000...000<br />[-0]~反~=**1**,111...111 |
| 带符号整数：补码 | $-2^n \le x \le 2^n-1$     | **0**,111...111 = 2^n^-1 | **1**,000...000 = 2^n^      | [0]~补~=**0**,000...000<br />真值 0 只有一种补码       |
| 无符号整数       | $0 \le x \le 2^{n+1}-1$    | 1111...111 = 2^n+1^-1    | 0000...000 = 0              | 0000...000                                             |

+ 原码和反码的合法表示范围完全相同，都有两种方法表示真值0。
+ 补码的合法表示范围比原码多一个负数，只有一种方法表示真值0。

## 2.1.6 移码

**移码**：补码的基础上将<span style="color:red">符号位取反</span>。注意：==移码只能用于表示整数==。表示范围与补码相同，真值 0 只有一种表示方式：[0]~移~=10000000。

移码表示的整数很方便用硬件电路对比大小。

## 2.1.7 定点小数

### 定点小数的表示

带符号整数，又可以叫定点整数，默认小数点是在最后一位。定点整数的编码表示：原码、反码、补码、移码。

定点小数的小数点默认在符号位的后面，定点小数的编码表示：原码、反码、补码。

**原码表示**

![image-20230517205905164](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E5%AE%9A%E7%82%B9%E5%B0%8F%E6%95%B0%E5%8E%9F%E7%A0%81%E8%A1%A8%E7%A4%BA.png)

常写为：[x]~原~ = **1**.1100000 。

定点整数的符号位后，一般用逗号分隔，定点小数的符号位后，一般用点号分隔。

定点小数的原码、反码、补码之间相互转换和定点整数的规则一样。

### 定点小数的运算

对两个定点小数A、B进行加法/减法时，需要先转换为补码。再用补码进行加减运算，和整数的补码加减运算规则一样。

注意：位数扩展时，扩展位置在最后。定点整数是在前面扩展。

## 2.2.0 奇偶校验码

**奇校验码：**整个校验码（有效信息位和校验位）中 “1” 的个数为奇数。

**偶校验码：**整个校验码（有效信息位和校验位）中 “1” 的个数为偶数。

![image-20230517211043321](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E7%A0%81.png)

【例题】给出两个编码 1001101 和 1010111 的奇校验码和偶校验码。

```
设最高位为校验位，余 7 位是信息位，则对应的奇偶校验码为：
因为 1001101 本身有 4 位 1，所以奇校验码需要在最高位补 1，偶校验码需要在最高位补 0；
	1010111 本身有 5 位 1，所以奇校验码需要在最高位补 0，偶校验码需要在最高位补 1。
			1001101		1010111
-----------------------------------------
奇校验：	1 1001101	0 101011
偶校验：	0 1001101	1 101011
```

如果有传输信息时有偶数个比特位发生了错误，奇偶校验码是检测不出来的。

## 2.2.1 电路的基本原理、加法器设计

![image-20230517214702529](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E7%94%B5%E8%B7%AF%E5%9C%B0%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png)

## 2.2.2 并行进位加法器

## 2.2.3 补码加减运算器

## 2.2.4 标志位的生成

![image-20230521225052264](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E7%94%9F%E6%88%90.png)

OF（Overflow Flag）：溢出标志。溢出时为 1 ，否则置 0。

SF（Sign Flag）：符号标志。结果为负时置 1，否则置 0。

ZF（Zero Flag）零标志。运算结果为 0 时 ZF 位置 1，否则置 0。

CF（Carry Flag）进位/借位标志，进位/借位时置 1，否则置 0。

## 2.2.5 定点数的移位运算

![image-20230522105038534](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97.png)

### 算数移位

![image-20230522103725525](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E7%AE%97%E6%95%B0%E7%A7%BB%E4%BD%8D.png)

通过改变各个数码位和小数点的相对位置，从而改变各数码位的位权。可用移位运算实现乘法、除法。

==原码==的算术移位——符号位保持不变，仅对数值位进行移位。

+ 右移：高位补 0，低位舍弃。若舍弃的位 = 0，则相当于 ÷ 2；若舍弃的位 $\ne$ 0，则会丢失精度。
+ 左移：低位补 0，高位舍弃。若舍弃的位 = 0，则相当于 × 2；若舍弃的位 $\ne$ 0，则会出现<span style="color:red">严重误差</span>。



==反码==的算术移位——<span style="color:red">正数</span>的反码与原码相同，因此对正数反码的移位运算也和原码相同。

+ 右移：高位补 0，低位舍弃
+ 左移：低位补 0，高位舍弃

==反码==的算术移位——<span style="color:red">负数</span>反码的移位运算规则如下：

+ 右移：高位补 1，低位舍弃
+ 左移：低位补 1，高位舍弃



==补码==的算术移位——<span style="color:red">正数</span>的补码与原码相同，因此对正数补码的移位运算也和原码相同。

+ 右移：高位补 0，低位舍弃
+ 左移：低位补 0，高位舍弃

==补码==的算术移位——<span style="color:red">负数</span>补码 = 反码末位 +1 ，导致反码最右边几个连续的 1 都因进位而变为 0 ，直到进位碰到第一个 0 为止。

+ 规律：负数补码中，最右边的 1 及其右边同原码。最右边的 1 的左边同反码。
+ 右移（同反码）：高位补 1，低位舍弃
+ 左移（同原码）：低位补 0，高位舍弃

|      |       码制       |       添补代码       |
| :--: | :--------------: | :------------------: |
| 正数 | 原码、反码、补码 |          0           |
| 负数 |       原码       |          0           |
| 负数 |       补码       | 左移添0<br />右移添1 |
| 负数 |       反码       |          1           |

左移相当于 $\times$ 2；右移相当于 $\div $ 2。

由于位数有限，因此有时候无法用算数移位精确地等效乘除法。

### 逻辑移位

逻辑移位可用看作是对 “无符号数” 的算数移位。

+ 逻辑右移：高位补 0，低位舍弃。
+ 逻辑左移：低位补 0，高位舍弃。

### 循环移位

![image-20230522104348381](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E8%AE%A1%E7%BB%84%E5%BE%AA%E7%8E%AF%E7%A7%BB%E4%BD%8D.png)

图中 CF 表示进位位。

## 2.2.6. 定点数的乘法运算

**原码一位乘法**：机器字长 n+1，数值部分占 n 位。

符号位通过==异或==确定；数值部分通过被乘数和乘数绝对值的 n 轮加法、移位完成。根据当前乘数中参与运算的位确定 ACC 加什么

+ 若当前运算位 = 1，则 ACC + [|x|]原
+ 若 = 0，则 ACC + 0。

每轮加法后 ACC、MQ 的内容统一==逻辑右移==。

Tips：

+ 乘数的符号位不参与运算，可以省略
+ 原码一位乘可以只用单符号位
+ 答题时最终结果最好写为原码机器数

**补码一位乘法（Booth算法）**

符号位、数值位都是由被乘数和乘数进行 n 轮加法、移位，==最后再多来一次加法==。每次加法根据当前 MQ 中的最低位、辅助位来确定加什么：

+ 辅助位 - MQ 中最低位 = 1 时，ACC + [x]补
+ 辅助位 - MQ 中最低位 = 0 时，ACC + 0
+ 辅助位 - MQ 中最低位 = -1 时，ACC + [-x]补

符号位参与运算。

|                         原码一位乘法                         |                         补码一位乘法                         |
| :----------------------------------------------------------: | :----------------------------------------------------------: |
| 符号位通过异或确定，数值位由被乘数和乘数的绝对值进行 n 轮加法、移位 | 符号位、数值位都是由被乘数和乘数进行 n 轮加法、移位，最后再多来一次加法 |
|                 每次加法可能 + 0、+[\|x\|]原                 |              每次加法可能 + 0、+[x]补、+[-x]补               |
|                    每次移位是 “逻辑右移”                     |                 每次移位是 “补码的算数右移”                  |
|                    乘数的符号位不参与运算                    |                     乘数的符号位参与运算                     |

## 2.2.7 定点数的除法

### 原码除法

**恢复余数法**

实现方法：上商 0/1，得到余数，余数末位补 0。

**加减交替法（不恢复余数法）**

符号位与数值位分开处理。

### 补码除法

