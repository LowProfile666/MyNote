# 栈和队列

## 栈

先进后出。

只能操作栈顶。

使用数组模拟栈，结构：

+ 栈本身的数组 stack[] ：用来存储数据
+ 栈顶指针 top ：用来指向/操作栈顶。

Java模板：

```java
// 结构以及初始化
int[] stack = new int[100001];
int top = 0;

// 压栈
public void push(int x) {
    stack[top++] = x;
}

// 弹栈
public void pop() {
    top--;
}

// 拿到栈顶元素
public int peek() {
    return stack[--top];
}

// 判断栈满
public boolean isFull() {
    return stack.length == top;
}

// 判断栈空
public boolean isEmpty() {
    return top == 0;
}
```

## 单调栈

单调栈的常见使用场景：给定一个序列，找出序列中每个数的左边离它最近且比它小/大的数，如果没有则是 -1。

比如：

给定序列：3 4 2 7 5

维护一个栈 stack

+ 遍历到 3 时，先去 stack 中查找有没有少于它的数，没有，所以答案是 -1，然后把 3 放进 stack 中；
+ 遍历到 4 时，先去 stack 中查找有没有少于它的数，有，则答案是 3，且将 4 添加到 stack 中；
+ 遍历到 2 时，先去 stack 中查找有没有少于它的数，没有，则答案是 -1，且将 2 添加到 stack 中；
  这时候需要注意，栈顶元素是 4，是一个比 2 大的元素，且 stack 是按顺序来添加元素的，说明 4 的下标是小于 2 的，也就是说，对于后面剩的元素来说，4 离它们比 2 离它们更远，且 4 还比 2 大，所以 4 永远也使用不到，所以可以将它出栈；同理，3 也可以将其出栈，最终 stack 中只有 2；
+ 遍历到 7 时，先去 stack 中查找有没有少于它的数，有，则答案是 2，且将 7 添加到 stack 中；
+ 遍历到 5 时，先去 stack 中查找有没有少于它的数，有，则答案是 2，且将 7 出栈，将 5 进栈。

单调栈的实现步骤：

+ 维护一个栈
+ 放入目前最优的数据
+ 更新最优的数据

Java模板

```java
int[] nums = ...;
int[] stack = new int[nums.length];
int top = 0;

for (int i = 0; i < nums.length; i++) {
	while (top > 0 && check(stack[top], nums[i]))    
        top--;
    stack[top++] = nums[i];
}
```



## 队列

先进先出。

队头出队，队尾进队。

结构：

+ 队列本身的数组 queue[] ：用来保存数据
+ 队头指针 front ：用来标识队头
+ 队尾指针 rear ：用来标识队尾

Java模板：

```java
// 结构及初始化
int[] queue = new int[100001];
int front = 0;
int rear = 0;

// 入队
public void inqueue(int x) {
    queue[rear++] = x;
}

// 出队
public void dequeue() {
    front++;
}

// 拿到队头元素
public int peek() {
    return queue[front];
}

// 判断队空
public boolean isEmpty() {
    return front == rear;
}

// 判断队满
public boolean isFull() {
    return rear == queue.length;
}
```

## 单调队列

单调栈的常见使用场景：找出滑动窗口中的最大值/最小值。

和单调栈思路一样，维护一个队列，队列中保存的是更小/更大的元素的下标，如果当前遍历到的元素比队头元素更符合要求，则将队头元素出队。

比如：

给定一个序列：1 3 -1 -3 5 3 6 7，固定滑动窗口的大小为 3。

维护一个队列，队列初始为空

+ 遍历到 1 时，此时滑动窗口为空，直接将 1 的下标 0 加入队列；
+ 遍历到 3 时，此时滑动窗口为 {0}，直接将 3 的下标 1 加入队列；
+ 遍历到 -1 时，此时滑动窗口为 {0, 1}，队头元素所指向的数据大于当前的 -1，所以将队头元素出队，因为它们处在同一个滑动窗口内，有 -1 在，1 就永远没有出头之日；同理，将 3 的下标也出队，最后将 -1 的下标 2 入队；
+ 遍历到 -3 时，此时滑动窗口为 {2}，-1 大于 -3，所以将 -1 的下标出队，将 -3 的下标 3 入队；
+ 遍历到 5 时，此时滑动窗口为 {3}，直接将 5 的下标 4 入队；
+ 遍历到 3 时，此时滑动窗口为 {3, 4}，5 大于 3，所以将 5 的下标出队，将 3 的下标 5 入队；
+ 遍历到 6 时，此时滑动窗口为 {3, 5}，将 6 的下标 6 入队，由于此时的队头元素 3 是属于到当前数的下标 6 已经包含了 4 个元素，所以要将队头元素出队。
+ 遍历到 7 时，此时滑动窗口为 {5, 6}，将 7 的下标 7 入队。

在以上例子中，单调队列的队头元素一直都是滑动窗口中最小值的下标。

Java模板：

```java
int[] nums = ....;
int[] queue = new int[nums.length];
int f = 0, r = 0;
int k = 3;  // 滑动窗口的大小

for (int i = 0; i < nums.length; i++) {
   	while (f < r && check_out(queue[f])) f ++ ;  // 判断队头是否滑出窗口
    while (f < r && check(queue[r], i)) r -- ;
    queue[r++] = i;
}
```



## 循环队列

