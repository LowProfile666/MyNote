# 算法

> 算法是解决待定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

## 1.定义

<span style="color:red">算法（Algorithm）是解决待定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。</span>

算法是描述解决问题的方法。

## 2. 特性

算法有五个基本特性：<span style="color:red">输入、输出、有穷性、确定性和可行性</span>。

**输入输出**

算法有 <span style="color:blue">0 个或多个输入</span> ，至少 <span style="color:blue">一个或多个输出</span> 。

**有穷性**

<span style="color:blue">指算法在执行有限的步骤之后，自动结束而不会出现无限循环，并且每一个步骤在可接受的时间内完成</span>。

**确定性**

<span style="color:blue">算法的每一步骤都具有确定的含义，不会出现二义性</span>。

算法的每个步骤都被精确定义而无歧义。

**可行性**

<span style="color:blue">算法的每一步都必须是可行的，也就是说，每一步都能够通过执行有限次数完成</span>。

可行性意味着算法可以转换为程序上机运行，并得到正确的结果。

## 3. 设计的要求

好的算法应该具有：正确性、可读性、健壮性、高效率和低存储量的特征。

**正确性**

<span style="color:blue">算法的正确性是指算法至少应该具有输入、输出和加工处理无歧义性，能正确反映问题的需求，能够得到问题的正确答案</span>。

算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。因为我们几乎不可能逐一验证所有的输入都得到正确的结果。

**可读性**

<span style="color:blue">算法设计的另一目的是为了便于阅读、理解和交流</span>。

可读性高有助于人们理解算法，便于调试和修改。

**健壮性**

<span style="color:blue">当输入数据不合法时，算法也能做出相关处理，而不是产生异常或莫名奇妙的结果</span>。

**时间效率高和存储量低**

<span style="color:blue">设计算法应该尽量满足时间效率高和存储量低的需求</span>。

时间效率指的是算法的执行时间。

存储量需求指的是算法在执行过程中需要的最大存储空间，主要指算法程序运行时所占用的内存或外部硬盘存储空间。

## 4. 算法效率的度量方法

关于上面提到的效率，我们如何来度量一个算法的执行时间呢？

**事后统计法**

<span style="color:blue">这种方法主要是通过设计好的测试程序和数据，利用计算机计时器对不同算法编制的程序的运行时间进行比较，从而确定算法效率的高低</span>。

缺陷：

+ 必须一局算法事先编制好程序，通常需要花费大龄的时间和精力。
+ 时间的比较依赖计算机硬件和软件等环境因素，有时会掩盖算法本身的优劣。
+ 算法的测试数据设计困难。

基于以上缺陷，一般不用该方法。

**事前分析估算方法**

<span style="color:blue">在计算机程序编制前，依据统计方法对算法进行估算</span>。

抛开计算机硬件、软件有关的因素，<span style="color:blue">一个程序的运行时间，依赖于算法的好坏和问题的输入规模</span>。所谓的问题输入规模指的是输入量的多少。

## 5. 函数的渐近增长

有两个算法 A 和 B，假设输入规模都是 n ，算法 A 要做 2n+3 次操作，算法 B 要做 3n+1 次操作，比较哪个更快？

答案是不一定的：

|  次数   | 算法A（2n+3） | 算法A’（2n） | 算法B（3n+1） | 算法B‘（3n） |
| :-----: | :-----------: | :----------: | :-----------: | :----------: |
|  n = 1  |       5       |      2       |       4       |      3       |
|  n = 2  |       7       |      4       |       7       |      6       |
|  n = 3  |       9       |      6       |      10       |      9       |
| n = 10  |      23       |      20      |      31       |      30      |
| n = 100 |      203      |     200      |      301      |     300      |

显然，随着 n 的增加，算法 A 的效率比 B 越来越好，

+ n = 1 时：A 效率不如 B。
+ n = 2 时：A 效率等于 B。
+ n > 2 时：A 效率优于 B。

于是得出结论：算法 A 总体上要好过算法 B 。

此时给出定义：输入规模 n 在没有限制的情况下，只要超过一个数值 N，这个函数就总是大于另一个函数，我们称函数都是渐近增长的。

<span style="color:red">给定两个函数 $f(n)$ 和 $g(n)$，如果存在一个整数 $N$，使得对于所有的 $n > N$ ，$f(n) $总是大于 $g(n)$ ，那么，我们说 $f(n)$ 的增长渐近快于 $g(n)$ </span>。

<span style="color:blue">判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项（最高阶项）的阶数</span>。

## 6. 时间复杂度

<span style="color:red">在进行算法分析时，语句总的执行次数 $T(n)$ 是关于问题规模 n 的函数，进而分析 $T(n)$ 随 $n$ 的变化情况并确定 $T(n)$ 的数量级。算法的时间复杂度，也就是算法的时间量度，记作 $T(n) = O(f(n))$ 。它表示随问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，称作算法的渐近时间复杂度，简称为时间复杂度。。其中 $f(n)$ 是问题规模 $n$ 的某个函数。 </span>

这样用大写 $O()$ 来体现时间复杂度的记法，我们称之为<span style="color:blue">大O记法</span>。

+ O(1) ：常数阶
+ O(n) ：线性阶
+ O(n^2^) ：平方阶
+ ……

一般情况下，随着 n 的增大，T(n) 增长最慢的算法为最优算法。

**推导大O阶方法**

1. 用常数 1 取代运行时间中的所有加法常数
2. 在修改后的运行次数函数中，只保留最高阶项
3. 如果最高阶项存在且其系数不是 1，则去除与这个项目相乘的系数

得到的结果就是大 O 阶。

**常数阶**

与问题的大小（n的大小）无关，执行时间恒定的算法，我们称之为具有 O(1) 的时间复杂度，又叫常数阶。

比如以下代码的时间复杂度为 O(1)：

```c
int sum = 0, n = 100;
sum = (1 + n) * n / 2;
printf("%d", sum);
```

以下代码的时间复杂度也为 O(1)：

```c
int sum = 0, n = 100;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
sum = (1 + n) * n / 2;
printf("%d", sum);
```

<span style="color:blue">注意：不管这个常数是多少，我们都记作 O(1) ，不能是 O(3)、O(12) 等其他任何数字</span>。

**线性阶**

要确定某个算法的阶次，我们常常需要确定某个特定语句或某个语句集执行的次数。

<span style="color:blue">分析算法的复杂度，关键就是要分析循环结构的运行情况</span>。

以下代码的时间复杂度为 O(n)：

```c
for (int i = 0; i < n; i++) {
	/* 时间复杂度为 O(1) 的语句集 */
}
```

**对数阶**

以下代码的时间复杂度为 O(logn)：

```c
int count = 1;
while (count < n) {
    count *= 2;
    /* 时间复杂度为 O(1) 的语句集 */
}
```

由于每次 count 乘以 2 后，就距离 n 更近了一步，也就是说，有多少个 2 相乘后大于 n 就会退出循环。由 2^x^ = n 得到 x = log~2~n ，所以这个程序的时间复杂度为 O(logn)。

**平方阶**

以下代码的时间复杂度为 O(n^2^)：

```c
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        /* 时间复杂度为 O(1) 的语句集 */
    }
}
```

内层循环的时间复杂度为 O(n) ，而外层循环则是将内层的循环执行了 n 次，所以时间复杂度使 O(n)。

循环的时间复杂度等于循环体的复杂度乘以该循环运行的次数。

常用时间复杂度所耗费的时间从小到大是：

<span style="color:red">O(1) < O(logn) < O(n) < O(nlogn) < O(n^2^) < O(n^3^) < O(2^n^) < O(n!) < O(n^n^)</span>

**最坏情况与平均情况**

​	通常，除非特别指定，我们提到的运行时间都是最坏情况的运行时间。

<span style="color:blue">平均运行时间是所有情况中最有意义的，因为它是期望的运行时间。</span>

对算法的分析，

+ 计算所有情况的平均值，这种时间复杂度的计算方法称为平均时间复杂度。
+ 计算最下情况下的时间复杂度，这种方法称为最坏时间复杂度。

## 7. 算法空间复杂度



