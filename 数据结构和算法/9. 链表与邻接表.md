# 链表与邻接表

主要是用数组模拟链表，也叫静态链表。

## 单链表

主要学习邻接表，用来存储树和图。

用数组模拟单链表：

![image-20231009081317886](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310090815005.png)

结构：

+ 值域数组 val[] ：用来保存每个节点的值，坐标就代表着节点的位置
+ 指针域数组 nex[] ：用来保存每个节点的下一个节点位置，坐标就代表着节点的位置
+ 头节点 head：就是头节点的下标
+ 当前节点 cur：就是数组空间当前被用到的位置下标

为什么有 cur 这个指针？

因为我们是用数组来模拟链表，所以插入节点时其实就是给数组元素赋值，所以我们需要一个指针来指向数组的空间。

常用操作Java模板：

```java
// 结构
int[] val = new int[100001];  // 链表的值
int[] nex = new int[100001];  // 链表的指针
int head = -1;  // 头节点
int cur = 0;  // 新插入节点是在数组中的位置

// 头插法
public void headInsert(int x) {
    val[cur] = x;  // 保存值
    nex[cur] = head;  // 指向原头节点
    head = cur++;  // 更新头节点，并更新下次插入节点的位置
}

// 在第k个位置插入
public void kInsert(int k, int x) {
    val[cur] = x;  // 保存值
    nex[cur] = nex[k];  // 指向第k个节点的下一个
    nex[k] = cur++;  // 第k个节点指向当前节点，并更新下次插入节点的位置
}

// 删除节点
public static void delete(int k) {
    if (k == 0)  // 删除头节点
        head = nex[head];
    else 
        nex[k-1] = nex[nex[k-1]];
}
```

[\826. 单链表](https://www.acwing.com/problem/content/description/828/)

> 实现一个单链表，链表初始为空，支持三种操作：
>
> 1. 向链表头插入一个数；
> 2. 删除第 k 个插入的数后面的数；
> 3. 在第 k 个插入的数后插入一个数。
>
> 现在要对该链表进行 M 次操作，进行完所有操作后，从头到尾输出整个链表。
>
> **注意**:题目中第 k 个插入的数并不是指当前链表的第 k 个数。例如操作过程中一共插入了 n 个数，则按照插入的时间顺序，这 n 个数依次为：第 1 个插入的数，第 2 个插入的数，…第 n 个插入的数。

```java
import java.util.Scanner;

public class Main{
    static int[] val = new int[100001];
    static int[] nex = new int[100001];
    static int head = -1;
    static int cur = 0;
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        int m = sc.nextInt();
        
        while (m-- != 0) {
            char op = sc.next().charAt(0);
            int k, x;
            
            if (op == 'H') {
                x = Integer.parseInt(sc.next());
                headInsert(x);
            } else if (op == 'D') {
                k = Integer.parseInt(sc.next());
                delete(k);
            } else {
                k = Integer.parseInt(sc.next());
                x = Integer.parseInt(sc.next());
                kInsert(k, x);
            }
        }
        
        for (int i = head; i != -1; i = nex[i])
            System.out.print(val[i] + " ");
    }
    public static void headInsert(int x) {
        val[cur] = x;
        nex[cur] = head;
        head = cur++;
    }
    
    public static void kInsert(int k, int x) {
        val[cur] = x;
        nex[cur] = nex[k-1];
        nex[k-1] = cur++;
    }
    
    public static void delete(int k) {
        if (k == 0) 
            head = nex[head];
        else 
            nex[k-1] = nex[nex[k-1]];
    }
}
```



## 双链表

主要用来优化一些问题。