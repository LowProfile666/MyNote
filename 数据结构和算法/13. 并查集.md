# 并查集

使用近乎 O(1) 的时间复杂度来完成两个操作：

+ 将两个集合合并，
+ 询问两个元素是否在一个集合当中。

基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。

可以通过找父亲的方式找到当前节点所在的集合。那么可以将根节点的父节点设为它自己，这样就可以通过这句代码来确定是否是根节点:

```java
if (p[x] == x)
```

对于一个集合中的所有节点都要找它所在集合的根节点的操作来说，有一个优化方式：路径压缩。

![image-20231015123452672](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310151234699.png)

可以使用回溯同时完成路径压缩操作和找到集合编号（根节点编号）的操作：

```java
public int find(int x) {
    if (p[x] != x)	p[x] = find(p[x]);
    return p[x];
}
```

将两个集合合并：就是将一个集合的根节点的父节点修改为另一个集合的根节点即可。

![image-20231015124211155](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310151242187.png)

代码就是：

```java
int px = find(x);
int py = find(y);
p[px] = py;
```

Java模板：

```java
int[] p = new int[N];  // 存父节点 -> 每个点的祖宗节点

// 初始化p，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) p[i] = i;

// 返回x的祖宗节点，集合的根节点
public int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
```

[\836. 合并集合](https://www.acwing.com/problem/content/838/)

> 一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。
>
> 现在要进行 m 个操作，操作共有两种：
>
> 1. `M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
> 2. `Q a b`，询问编号为 a 和 b 的两个数是否在同一个集合中；

```java
import java.util.*;

public class Main{
    static int N = 100010, n, m;
    static int[] p;  // 存父节点
    
    public static void main(String[] agrs) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        
        p = new int[n+1];
        for (int i = 1; i <= n; i++)
            p[i] = i;
        
        while (m-- != 0) {
            char op = sc.next().charAt(0);
            int a = Integer.parseInt(sc.next());
            int b = Integer.parseInt(sc.next());
            
            int pa = find(a), pb = find(b);
            
            if (op == 'M')  p[pa] = pb;
            else    System.out.println(pa == pb ? "Yes" : "No");
        }
    }
    
    public static int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
}
```

变形：在以上的基础，维护每个集合的元素个数。

[\837. 连通块中点的数量](https://www.acwing.com/problem/content/839/)

> 给定一个包含 n 个点（编号为 1∼n）的无向图，初始时图中没有边。
>
> 现在要进行 m 个操作，操作共有三种：
>
> 1. `C a b`，在点 a 和点 b 之间连一条边，a 和 b 可能相等；
> 2. `Q1 a b`，询问点 a 和点 b 是否在同一个连通块中，a 和 b 可能相等；
> 3. `Q2 a`，询问点 a 所在连通块中点的数量；

这题和上题相比只需要多开一个计数数组，记录每个集合中的节点个数，初始都为 1。

```java
import java.util.*;

public class Main{
    static int[] p, size;
    static int N = 100010;
    
    public static void main(String[] agrs) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        
        p = new int[n+1];
        size = new int[n+1];
        
        for (int i = 1; i <= n; i++)    {p[i] = i; size[i] = 1;}
        
        while (m-- != 0) {
            String op = sc.next();
            if ("C".equals(op)) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                int pa = find(a), pb = find(b);
                if (pa != pb) {  // 如果是两个相同的集合就不用操作了
                    p[pa] = pb;
                    size[pb] += size[pa];
                }
            } else if ("Q1".equals(op)) {
                int a = sc.nextInt();
                int b = sc.nextInt();
                int pa = find(a), pb = find(b);
                System.out.println(pa == pb ? "Yes" : "No");
            } else {
                int a = sc.nextInt();
                System.out.println(size[find(a)]);
            }
        }
    }
    
    public static int find(int x) {
        if (p[x] != x)  p[x] = find(p[x]);
        return p[x];
    }
}
```



变形：维护每个节点到根节点的距离

[\240. 食物链](https://www.acwing.com/problem/content/242/)
