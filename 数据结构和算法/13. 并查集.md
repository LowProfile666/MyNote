# 并查集

使用近乎 O(1) 的时间复杂度来完成两个操作：

+ 将两个集合合并，
+ 询问两个元素是否在一个集合当中。

基本原理：每个集合用一棵树来表示，树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点。

可以通过找父亲的方式找到当前节点所在的集合。那么可以将根节点的父节点设为它自己，这样就可以通过这句代码来确定是否是根节点:

```java
if (p[x] == x)
```

对于一个集合中的所有节点都要找它所在集合的根节点的操作来说，有一个优化方式：路径压缩。

![image-20231015123452672](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310151234699.png)

可以使用回溯同时完成路径压缩操作和找到集合编号（根节点编号）的操作：

```java
public int find(int x) {
    if (p[x] != x)	p[x] = find(p[x]);
    return p[x];
}
```

将两个集合合并：就是将一个集合的根节点的父节点修改为另一个集合的根节点即可。

![image-20231015124211155](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310151242187.png)

代码就是：

```java
int px = find(x);
int py = find(y);
p[px] = py;
```

Java模板：

```java
int[] p = new int[n];  // 存父节点 -> 每个点的祖宗节点

// 返回x的祖宗节点，集合的根节点
public int find(int x) {
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

// 初始化p，假定节点编号是1~n
for (int i = 1; i <= n; i ++ ) p[i] = i;

// 合并a和b所在的两个集合：
p[find(a)] = find(b);
```

[\836. 合并集合](https://www.acwing.com/problem/content/838/)

> 一共有 n 个数，编号是 1∼n，最开始每个数各自在一个集合中。
>
> 现在要进行 m 个操作，操作共有两种：
>
> 1. `M a b`，将编号为 a 和 b 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
> 2. `Q a b`，询问编号为 a 和 b 的两个数是否在同一个集合中；

```java
import java.util.*;

public class Main{
    static int N = 100010, n, m;
    static int[] p;  // 存父节点
    
    public static void main(String[] agrs) {
        Scanner sc = new Scanner(System.in);
        n = sc.nextInt();
        m = sc.nextInt();
        
        p = new int[n+1];
        for (int i = 1; i <= n; i++)
            p[i] = i;
        
        while (m-- != 0) {
            char op = sc.next().charAt(0);
            int a = Integer.parseInt(sc.next());
            int b = Integer.parseInt(sc.next());
            
            int pa = find(a), pb = find(b);
            
            if (op == 'M')  p[pa] = pb;
            else    System.out.println(pa == pb ? "Yes" : "No");
        }
    }
    
    public static int find(int x) {
        if (p[x] != x) p[x] = find(p[x]);
        return p[x];
    }
}
```

