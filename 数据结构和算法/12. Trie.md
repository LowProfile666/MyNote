# Trie树

这是一种用来快速存储和查找字符串集合的数据结构：

![image-20231015110600455](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310151106563.png)

**插入字符串的过程**

当往树中插入一个字符串（比如abcd）的时候，会先找根节点有没有 a 这个儿子，没有就会新建一个 a 子节点，然后在 a 子节点上找有没有 b 这个儿子，没有也会新建一个 b 儿子，依次往下，直到存下 abcd 所有字符。

此时树中只存在一个字符串 abcd。当要再插入一个字符串 abce 的时候，会从根节点开始，判断根节点是否有 a 这个子节点，发现有，那么又去 a 节点继续找，判断 a 节点有没有 b 这个子节点，发现有，那么又去 b 节点继续找，判断 b 节点有没有 c 这个子节点，发现有，那么又去 c 节点继续找，判断 c 节点有没有 e 这个子节点，发现没有，那么创建一个 e 子节点。

**查询字符串的过程**

此时树中有两个字符串：abcd、abce

如果要查询一个字符串 abc ，先在 root 节点上查找有没有一个 a 子节点，有，然后再去这个 a 子节点下找到一个 b 子节点，再去 b 子节点下找到一个 c 子节点，此时字符串 abc 的所有字符都已经找到了，但是那其实是字符串 abcd、abce 的部分，树中并没有 abc 字符串，所以为了避免出错，插入字符串的时候要在字符串结束的位置添加一个结束标志，标识这是一个字符串的结尾。

**如何存储Trie树**

假设只存在小写字母，用一个二维数组`son[N][26]`来表示这棵树

+ N：表示节点的总个数，意味着每一行 `son[i]` 就是一个节点
+ 26：表示每个节点有的最多的儿子数，那么每个节点最多存在26个儿子
+ `son[N][26]`：则表示共 N 个节点，每个节点都可以有 26 个儿子

同时，这个数组的行号和列号也有含义：

+ 行号 i ：表示节点的编号为 i，表示 i 位置的这个节点
+ 列号 j ：表示子节点的字符为 `j+'a'`，因为列就是用来表示 26 个小写字母的 
+ `son[i][j]` ：就表示编号 i 这个节点的 j+'a' 儿子节点的编号/所属行号
+ `son[0][0] = 1` ：表示根节点的 'a' 子节点的行号是 1
+ `son[1][1] = 2` ：表示 1 节点 'a' 的 'b' 子节点的行号是 2

**如何确定每个节点的行号**

在插入节点的时候，使用一个变量来记录每个节点的行号即可。比如在插入 abcd 字符串时的第一个字符 a，`son[0][0] = idx`，使用 idx 来记录每个节点被插入时的编号。

比如，树中有两个字符串 abcd、ac，他们在数组中的存储如下：

![image-20231015114748552](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310151147593.png)

**如何给树中每个字符串末尾添加标志**

单开一个数组，来记录每个节点是否为结束位置，或者来记录以当前字符结尾的字符串有多少个。

Java代码模板：

```java

int[][] son = new int[N][26];  // 存储树
int[] cnt = new int[N];  // 标志每个字符是否是结尾字符，以及存储以每个字符结尾的字符串的个数
int idx = 1;  // 记录每个节点的位置，从1开始因为 0 是root根节点

// 插入字符串
public void insert(char[] x) {
    int p = 0;   // 表示当前节点位置，也就是行号，每次插入字符串都要从根节点开始
    for (int i = 0; i < x.length; i++) {
        int j = x[i] - 'a';
        if (son[p][j] == 0) son[p][j] = idx++;
        p = son[p][j];
    }
    cnt[p] ++;
}

// 查找一个字符串在集合中出现了多少次。
public void query(char[] x) {
    int p = 0;
    for (int i = 0; i < x.length; i++) {
        int j = x[i] - 'a';
        if (son[p][j] == 0) return 0;
        p = son[p][j];
    }
    return cnt[p];
}
```

[\835. Trie字符串统计](https://www.acwing.com/problem/content/description/837/)

> 维护一个字符串集合，支持两种操作：
>
> 1. `I x` 向集合中插入一个字符串 x；
> 2. `Q x` 询问一个字符串在集合中出现了多少次。
>
> 共有 N 个操作，所有输入的字符串总长度不超过 10^5^，字符串仅包含小写英文字母。

```java
import java.util.*;

public class Main{
    static int N = 100001, idx = 1;
    static int[][] son = new int[N][26];
    static int[] cnt = new int[N];
    
    public static void main(String[] agrs) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        
        while (n-- != 0) {
            char op = sc.next().charAt(0);
            char[] x = sc.next().toCharArray();
            if (op == 'I')
                insert(x);
            else
                System.out.println(query(x));
        }
    }
    
    public static void insert(char[] x) {
        int p = 0;
        for (int i = 0; i < x.length; i++) {
            int j = x[i] - 'a';
            if (son[p][j] == 0) son[p][j] = idx++;
            p = son[p][j];
        }
        cnt[p] ++;
    }
    
    public static int query(char[] x) {
        int p = 0;
        for (int i = 0; i < x.length; i++) {
            int j = x[i] - 'a';
            if (son[p][j] == 0) return 0;
            p = son[p][j];
        }
        return cnt[p];
    }
}
```

