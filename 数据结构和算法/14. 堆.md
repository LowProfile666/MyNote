# 堆

如何手写一个堆？

堆是维护数的一个集合。基本的操作有

+ 插入一个数
+ 求集合中的最小值
+ 删除最小值
+ 删除任意一个元素
+ 修改任意一个元素

堆是一颗完全二叉树。以小根堆为例：每个节点都是小于等于左右儿子的。

堆的存储：使用一维数组即可。用一维数组 heap[] 存储堆，用 size 变量表示堆中的元素个数，也是数组中的最后一个元素下标。

存储节点时，利用完全二叉树的性质，假设当前节点的编号为 x，那么它的左儿子编号为 2x，右儿子编号为 2x+1，所以建议 heap 从 1 开始存储，这样不用特判 0 的左右儿子。

![image-20231016082803461](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310160831965.png)

堆有两个基本方法，用这两个方法可以完成以上全部五个操作：

+ `up(x)`：将 x 位置的节点向上调整。用当前节点的值和父节点进行比较，比父节点还要小的话就和父节点交换。

  ```java
  // up 操作是将更小的数向上调整
  public void up(int i) {
     	while ((i / 2 != 0) && heap[i/2] > heap[i]) {
          swap(i/2, i);
          i /= 2;
      }
  }
  ```

+ `down(x)`：将 x 位置的节点向下调整。用当前节点的值和左右儿子节点进行比较，找出这三个节点中的最小值，然后与这个父节点进行交换。

  ```java
  // down 操作是将更大的数向下调整
  public void down(int i) {
      int j = i;  // j 用来保存三个节点中值最小的节点下标，初始为当前节点下标 i
      if (i * 2 <= size && heap[i*2] < heap[j])	j = i * 2;  // 当前点大于左儿子
      if (i * 2 + 1 <= size && heap[i*2+1] < heap[j])	j = i * 2 + 1;  // 当前点大于右儿子
      if (i != j) {
          swap(i, j);
          down(j);  
      }
  }
  ```

如何构建堆？从完全二叉树中的最后一个叶子节点的父节点开始构建。

构建堆（小根堆）的过程，其实就是让完全二叉树中每个节点达到小于等于左右孩子节点的状态，所以我们从最后一个叶子节点的父节点开始构建。假设最后一个叶子节点的下标是 n，那么它的父节点就是 n/2。

具体就是使用堆的 down 方法，让每个节点都与自己的孩子节点达到这种状态。所以我们可以遍历每个有孩子节点的父节点，通过调用 down 来构建以它为根的这颗树的堆，当遍历到二叉树的根节点时，就构建完毕。

![image-20231016123936066](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310161239115.png)

如上图的完全二叉树，要将它构建为堆，步骤：

+ 先找到 n/2 的节点，调用 down(n/2)
+ 然后找到 n/2-1 的节点，调用 down(n/2-1)

这样之后每个有孩子节点的节点的值，一定不大于它的孩子节点，堆顶就是堆里最小的值了。

```java
// 构建堆
for (int i = n / 2; i > 0; i--)	down(i);
```

实现五个操作：

+ 插入一个数：`heap[size] = x; up(size++);`
  插入一个数就是在数组的末尾添加一个数，然后使用 up 操作将他移动到正确的位置。
+ 求集合中的最小值：`heap[1]`
  小根堆的堆顶一定是堆中的最小值。
+ 删除最小值：`heap[1] = heap[--size]; down(1);`
  因为是一维数组的存储方式，真正的删除操作很麻烦，所以直接用数组末尾的元素覆盖掉堆顶元素，然后使用 down 将他降到正确的位置即可。
+ 删除任意一个元素：`heap[k] = heap[--size]; down(k); up(k);`
  删除任意一个元素时，由于不知道删除后的大小关系，所以直接使用 down 和 up 操作，两个操作中一定只会有效执行一个。
+ 修改任意一个元素：`heap[k] = x; down(k); up(k);`
  同上。

Java代码模板：

```java
int[] heap = new int[N];
int size = 1;

// 构建堆
for (int i = n / 2; i > 0; i--)	down(i);
size = n;

// swap
public void swap(int i, int j) {
    int t = heap[i];
    heap[i] = heap[j];
    heap[j] = t;
}

// down 操作是将更大的数向下调整
public void down(int i) {
    int j = i;  // j 用来保存三个节点中值最小的节点下标，初始为当前节点下标 i
    if (i * 2 <= size && heap[i*2] < heap[j])	j = i * 2;  // 当前点大于左儿子
    if (i * 2 + 1 <= size && heap[i*2+1] < heap[j])	j = i * 2 + 1;  // 当前点大于右儿子
    if (i != j) {
        swap(i, j);
        down(j);  
    }
    // 非递归
    // while (i * 2 <= size) {
    //     int j = i;
    //     if (heap[i*2] < heap[j])	j = i * 2;
    //     if (i*2+1 <= size && heap[i*2+1] < heap[j])	j = i * 2 + 1;
    //     if (i == j) break;
    //     swap(i, j);
    //     i = j;
    // }
}

// up 操作是将更小的数向上调整
public void up(int i) {
   	while ((i / 2 != 0) && heap[i/2] > heap[i]) {
        swap(i/2, i);
        i /= 2;
    }
}
```

[\838. 堆排序](https://www.acwing.com/problem/content/description/840/)

> 输入一个长度为 n 的整数数列，从小到大输出前 m 小的数。

```java
import java.io.*;

public class Main{
    static int[] heap = new int[100010]; 
    static int size = 1;
    
    public static void main(String[] agrs) throws Exception{
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        String[] nums = in.readLine().split(" ");
        int n = Integer.parseInt(nums[0]);
        int m = Integer.parseInt(nums[1]);
        
        nums = in.readLine().split(" ");
        for (int i = 1; i <= n; i++)    heap[i] = Integer.parseInt(nums[i-1]);
        size = n;
        
        for (int i = n / 2; i > 0; i--) down(i);
        
        while (m-- != 0) {
            out.write(heap[1] + " ");
            heap[1] = heap[size--];
            down(1);
        }
        
        out.flush();
    }
    
    public static void swap(int i, int j) {
        int t = heap[i];
        heap[i] = heap[j];
        heap[j] = t;
    }
    public static void down(int i) {
        int j = i;
        if (i * 2 <= size && heap[i*2] < heap[j])   j = i * 2;
        if (i * 2 + 1 <= size && heap[i*2+1] < heap[j]) j = i * 2 + 1;
        if (i != j) {
            swap(i, j);
            down(j);
        }
    }
}
```

