# 一、幂和对数

## 1、幂

**幂（power）**是一个数自乘若干次的形式。

幂不符合交换律和结合律。

$n ^ m$ 表示 $n$ 的 $m$ 次幂，也叫做 $n$ 的 $m$ 次方。

+ 当 $m$ 为正整数时，表示 $m$ 个 $n$ 相乘。
+ 当 $m$ 为小数时，$m$ 可以写成 $\frac{a}{b}$（其中a、b为整数） ，表示 $n^a$ 再开 $b$ 次方，即：<font size=5px>$n^m=n^{\frac{a}{b}}=\sqrt[b]{n^a}$</font>

在 $n ^ m$ 中，$n$ 称为底数，$m$ 称为指数。

在C语言中，用`pow(n,m)`函数来求 $n$ 的 $m$ 次幂。

## 2、对数

**对数**是对求幂的逆运算，这意味着一个数字的对数是必须产生另一个固定数字（基数）的指数。

当 $n$ 的 $m$ 次方等于 $T$（$n>0且n\ne1$），即 $T=n^m$ ，那么 $m$ 叫做 “以 $n$ 为底 $T$ 的对数” ，记作 $m=log_nT$ 。其中，$n$ 叫做对数的底数，$T$ 叫做真数。

+ 称以 10 为底的对数叫做 常用对数，并记为 $lgN$ 。
+ 称以 无理数$e(e=2.71828...)$ 为底的对数称为 自然对数，并记为 $lnN$ 。
+ 零没有对数。
+ 在实数范围内，负数没有对数；在虚数范围内，负数有对数。

对数基本公式：

+ $log_a(1)=0$
+ $log_a(a)=1$
+ $log_ab \times log_ba=1$
+ $-log_c\frac{a}{b}=log_c\frac{b}{a}$
+ $a^{log_ab}=b$

对数运算规则：

+ $log_a(MN)=log_aM+log_aN$
+ $log_a(\frac{M}{N})=log_aM-log_aN$
+ $log_a(\frac{1}{N})=-log_aN$
+ $log_a(N^m)=mlog_aN$

## 3、对数函数

函数 $y=log_ax$ 叫做对数函数，其中 $ x$ 是自变量，定义域为 $(0,+\infty)$ 。

基本性质：

+ 过定点 $(1,0)$ ，即 $x=1时，y=0$。
+ 当 $0<a<1$ 时，在 $(0, +\infty)$ 上是减函数；当 $a>1$ 时，在 $(0,+\infty)$ 上是增函数。

在C语言中，可以用`log(T)`来计算 $T$ 的自然对数（以 $e$ 为底），`log2(T)`来计算以2为底 $T$ 的对数，`log10(T)`来计算以10为底 $T$ 的 对数。

## 4、换底公式

**换底公式**是用对数运算公式，可将多异底对数式转化为同底对数式，结合其他的对数运算公式一起使用。

对于 $a,c\in(0,1)\cup(1,+\infty)且b\in(0,+\infty)$ ，有：<font size=5px>$log_ab=\frac{log_cb}{log_ca}$</font> 。

推导公式：<font size=5px>$log_ab=\frac{log_ab\times log_ca}{log_ca}=\frac{log_ca^{log_ab}}{log_ca}=\frac{log_cb}{log_ca}$</font>。

所以在C语言中，如果要求以 $a$ 为底 $b$ 的对数，可以用：`log2(b) / log(a)`。

## 5、题目练习

 [2 的幂](https://leetcode.cn/problems/power-of-two/description/)

**题目描述**

> 给你一个整数 `n`，请你判断该整数是否是 2 的幂次方。如果是，返回 `true` ；否则，返回 `false` 。
>
> 如果存在一个整数 `x` 使得 $n=2^x$ ，则认为 `n` 是 2 的幂次方。

**解题思路**

n如果是2的幂，那么存在一个数x使n为2的x次方，也就是说x是以2为底n的对数：$x=log_2n$，且x为整数，然后可以用2的x次方来与n比较，如果相同则返回true。

**C代码**

```c
bool isPowerOfTwo(int n){
    if(n <= 0) {
        return false;                          
    }
    int x = log2(n);
    return fabs(n - pow(2, x)) < 1e-8;  
}
```

**Java代码**

Java里没有`log2()`函数。

```java
class Solution {
    public boolean isPowerOfTwo(int n) {
        if(n <= 0)
            return false;
        int x = (int)(Math.log(n) / Math.log(2));
        return Math.abs(n - Math.pow(2, x)) < 1e-8;
    }
}
```

**相关题目**

| 序号 | 题目                                                         | 备注 |
| ---- | ------------------------------------------------------------ | ---- |
| 1    | [3的幂](https://leetcode.cn/problems/power-of-three/description/) |      |
| 2    | [4的幂](https://leetcode.cn/problems/power-of-four/description/) |      |

## 6、相关函数

> pow()函数

头文件：

```
#include <math.h>
```

函数原型：

```
double pow( double base, double exp );
```

函数功能：

```
函数返回以参数base 为底的exp 次幂。如果base为零或负和exp 小于等于零或非整数时,产生域错误。如果溢出，产生范围错误。 
```

> log()函数

头文件：

```
#include <math.h>
```

函数原型：

```
1、double log( double num );
2、double log2( double num );
3、double log10( double num );
```

函数功能：

```
1、返回参数num的自然对数。如果num为负,产生域错误；如果num 为零，产生范围错误。 
2、返回参数num以2为底的对数。如果num为负,产生域错误；如果num 为零，产生范围错误。
3、返回参数num以10为底的对数。如果num为负,产生域错误；如果num 为零，产生范围错误。
```

---

# 二、数列

## 1、等差数列

**等差数列**是指从第二项起，每一项与它的前一项的差等于同一个常数的一种数列，这个常数叫做等差数列的**公差**，常用A、P表示。公差常用字母$d$表示。

对于数列 $\{a_n\}$ ，若满足：<font size=5px> $a_{n+1}-a_n=d(n\in N,d\in R)$ </font>,则称该数列为等差数列。其中，公差$d$为一常数，$n$为正整数。

**通项公式**

等差数列通项公式通过定义式叠加而来。

如果一个等差数列的首项为 $a_1$，公差为 $d$ ，那么该等差数列第n项的表达式为：<font size=5px>$a_n=a_i+(n-i)d$ </font>。

**求和公式**

若一个等差数列的首项为 $a_1$ ，末项为 $a_n$ ，那么该等差数列和表达式为：<font size=5>$S=\frac{n(a_1+a_n)}{2}$ </font>，即（首项+末项）× 项数 ÷ 2。

**前n项和公式**

等差数列前N项求和，实际就是梯形公式的妙用：上底为 $a_1$ 首项，下底为 $a_1+(n-1)d$ ，高为 $n$ ，即：

<font size=5px>$\frac{[a_1+a_1+(n-1)d]h}{2}$ = $\frac{2a_1n+n(n-1)d}{2}$</font> ，也可以写成：<font size=5px>$S_n=n\times a_1+\frac{n \times (n-1)}{2} \times d$</font> 。

**等差中项**

等差中项即等差数列头尾两项的和的一半，但求等差中项不一定要知道头尾两项。

等差数列中，等差中项一般设为 $A_r$ ，当 $A_m,A_r,A_n$ 成等差数列时，$2A_r=A_m+A_n$， 所以 $A_r$ 为 $A_m,A_n$ 的等差中项，且为 $A_m,A_r,A_n$ 数列的平均值。可以推知：$n+m=2\times r$ ，且任意两项 $a_m,a_n$ 的关系为：$a_n=a_m+(n-m)d$ 。

## 2、等比数列

**等比数列**是指从第二项起，每一项与它的前一项的比值等于同一个常数的一种数列，常用G、P表示。这个常数叫做等比数列的公比，公比通常用字母 $q(q≠0)$ 表示 ，等比数列 $a1≠ 0$ 。其中 $\{a_n\}$ 中的每一项均不为0。注：$q=1$ 时，$\{a_n\}$ 为常数列。

**通项公式**

等比数列通项公式通过定义式叠乘而来：<font size=5>$a_n = a_1 \times q^{n-1}$</font> 。

**求和公式**

+ 当 $q\ne 1$ 时， <font size=5>$S_n=\frac{a_1(1-q^n)}{1-q}=\frac{a_1-a_nq}{1-q}$</font> 
+ 当 $q=1$ 时，<font size=5px>$S_n=na_1$</font>

**等比中项**

若 $a_qa_p={a_r}^2$ ，那么 $a_r$ 为 $a_p,a_q$ 等比中项。

## 3、斐波那契数列

**斐波那契数列**（Fibonacci sequence），又称黄金分割数列。这个数列从第3项开始，每一项都等于前两项之和。

**递推公式**

<font size=5>$f(n)=\left\{ \begin{array} \line{0} & (n=0) \\ 1 & (n=1) \\ f(n-1)+f(n-2) & (n>1) \end{array}\right.  $</font>

## 4、题目练习

| 序号 | 题目链接                                                     | 备注                                                     |
| ---- | ------------------------------------------------------------ | -------------------------------------------------------- |
| 1    | [斐波那契数](https://leetcode.cn/problems/fibonacci-number/description/) | 递归、循环                                               |
| 2    | [第 N 个泰波那契数](https://leetcode.cn/problems/n-th-tribonacci-number/description/) | 递归会超时                                               |
| 3    | [求1+2+…+n](https://leetcode.cn/problems/qiu-12n-lcof/description/) | 递归                                                     |
| 4    | [单调数列](https://leetcode.cn/problems/monotonic-array/description/) | 比较大小，记录数列两种状态                               |
| 5    | [解压缩编码列表](https://leetcode.cn/problems/decompress-run-length-encoded-list/description/) |                                                          |
| 6    | [II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/description/) | Java比C语言难实现:sweat:，卡在Java用list转数组不熟悉。   |
| 7    | [连续整数求和](https://leetcode.cn/problems/consecutive-numbers-sum/description/) | 困难题，和上一题一样，但是数据更大，用上一题解法会超时。 |
| 8    | [第几项 ](https://www.acwing.com/problem/content/4984/)      | AcWing周赛简单题                                         |

  [II. 和为s的连续正数序列](https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/description/)

该题第一次用Java卡住了，用C语言一遍做出了。因为Java用双层List转换成二维数组没成功，看了题解才知道。

**题目描述**

> 输入一个正整数 `target` ，输出所有和为 `target` 的连续正整数序列（至少含有两个数）。
>
> 序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。

**解题思路**

需要注意的是==连续==，所以可以直接暴力枚举。

**C代码**

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** findContinuousSequence(int target, int* returnSize, int** returnColumnSizes){
    int** ans = (int**)malloc(sizeof(int*) * 1000);
    *returnColumnSizes = (int*)malloc(sizeof(int) * 1000);
    int top = 0;  // 控制答案数组的第一维数组
    for (int i = 1; i < target; i++) {
        int sum = 0;
        int cnt = 0;  // 用cnt来控制答案数组第二维的大小
        for (int j = i; sum < target; j++) {
            cnt++;
            sum += j;
        }
        if (sum == target) {  // 这时是连续正整数序列
            ans[top] = (int*)malloc(sizeof(int) * cnt);
            int t = 0;
            for (int j = i; cnt; j++, cnt--) {
                ans[top][t++] = j;
            }
            (*returnColumnSizes)[top] = t;
            top++; 
        }
    }
    *returnSize = top;
    return ans;
}
```

**Java代码**

```java
class Solution {
    public int[][] findContinuousSequence(int target) {
        List<int[]> ans = new ArrayList<>();  // 这里最开始用的List<List<Integer>>，但是不会转成二维数组
        for (int i = 1; i < target; i++) {
            int sum = 0;
            int j;
            for (j = i; sum < target; j++) {
                sum += j;
            }
            if (sum == target) {
                int[] t = new int[j-i];
                for (int k = i, top = 0; k < j; k++) 
                    t[top++] = k;
                ans.add(t);
            }
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```

[连续整数求和](https://leetcode.cn/problems/consecutive-numbers-sum/description/)

**题目描述**

> 给定一个正整数 `n`，返回 *连续正整数满足所有数字之和为 `n` 的组数* 。 

**解题思路**

和上一道题类似，但是测试数据要大一些，所以用上一题能过的暴力枚举方法不能过这一道题，会超时。要用数学方法。

首先理解<span style="color:red">连续正整数</span>表示的是一个公差为1的等差数列，那么 $n$ 就是这个等差数列的和。

设这个等差数列首项为 $a_1$ ，项数为 $k$ ，根据通项公式可得尾项为 $a_1+k-1$ ，且前 $k$ 项和为 $n$ ，所以有以下关系：

+ $\frac{k(a_1+a_1+k-1)}{2}=n$ ，即 $k(2a_1+k-1)=2n$ ，说明 $2n$ 是 $k$ 的倍数，即 `2*n % k == 0` ----①。
+ 由上式继续变化：$2a_1+k-1=\frac{2n}{k}$ ，即 $2a_1=\frac{2n}{k}-k+1$ ，$\frac{2n}{k}-k+1$ 是 2 的倍数-----②
+ 由上式继续得到：$\frac{2n}{k}-k+1\geq2$  $\Longrightarrow$  $\frac{2n}{k}\geq k+1$ $\Longrightarrow$ $\frac{2n}{k}>k$ $\Longrightarrow$ $k <\sqrt{2n}$ 。 -----③

得到三个条件，条件③是限制 $k$ 的取值范围，条件①②是判断 $k$ 的值是否满足条件，所以只需要按照条件③来枚举 $k$ 的范围即可。

**Java代码**

```java
class Solution {
    public int consecutiveNumbersSum(int n) {
		int ans = 0;
        for (int k = 1; k*k < 2*n; k++) {
            if (2*n % k == 0 && (2*n/k - k + 1) % 2 == 0)
                ans++;
        }
        return ans;
    }
}
```

---

# 三、矩阵

## 1. 矩阵的定义

**矩阵**（Matrix）是一个按照长方阵列排列的复数或实数集合。由 $m \times n$ 个数 $a_{ij}$ 排成的 $m$ 行 $n$ 列的数表称为 $m$ 行 $n$ 列的矩阵，简称为 $m\times n$ 矩阵，记为：

![image-20230514140608057](https://gitee.com/LowProfile666/image-bed/raw/master/img/矩阵.png)

这 $m×n$ 个数称为矩阵 **A** 的元素，简称为元，数 $a_{ij}$ 位于矩阵 **A** 的第 $i$ 行第 $j$ 列，称为 **A** 矩阵的 $(i,j)$ 元，以数 $a_{ij}$ 为 $(i,j)$ 元的矩阵可记为 $(a_{ij})$ 或 $(a_{ij})_{m × n} $，$m×n$ 矩阵 **A** 也记作 **$A_{mn}$** 。

实矩阵：元素是实数。

复矩阵：元素是复数。

n 阶矩阵（n 阶方阵）：行数于列数都等于 n 的矩阵。

## 2. 矩阵的加减

以加法为例（减法规则和加法一样）。矩阵间对应的元素相加，形成一个新的矩阵：

![image-20230514141545968](https://gitee.com/LowProfile666/image-bed/raw/master/img/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8A%A0%E6%B3%95.png)

注意：

+ 只有同型矩阵之间才可以进行加法。
+ 满足结合律和交换律：$A+B=B+A$ 和 $(A+B)+C=A+(B+C)$ 。

## 3. 矩阵的数乘

一个数乘一个矩阵，用这个数乘以矩阵中的每个数，形成一个新的矩阵：

![image-20230514141946495](https://gitee.com/LowProfile666/image-bed/raw/master/img/矩阵的数乘.png)

满足以下规律：

+ $i(jA)=j(i)A$ 和 $i(jA)=(ij)A$
+ $(i+j)A=iA+jA$ 和 $i(A+B)=iA+iB$ 

矩阵的加减法和矩阵的数乘合称矩阵的**线性运算**。

## 4. 矩阵的转置

把矩阵 **A** 的**行和列互相交换**所产生的矩阵称为 **A** 的转置矩阵（$A^T$），这一过程称为矩阵的转置：

![image-20230514142629545](https://gitee.com/LowProfile666/image-bed/raw/master/img/矩阵的转置.png)

满足以下规律：

+ $(A^T)^T=A$
+ $(iA)^T=iA^T$
+ $(AB)^T=B^TA^T$

## 5. 矩阵的乘法

两个矩阵的乘法必须满足第一个矩阵的**行数**等于另一个矩阵的**列数**。

比如 ，矩阵 $A_{mn}$ 和矩阵 $B_{np}$ ，矩阵 **A** 的列数为 n ，矩阵 **B** 的行数为 n ，它俩相等，所以可以使用乘法，它们的乘积 **C** 是一个 $m \times p$ 的矩阵，记为 $C=AB$ ，矩阵 **C** 的每一个元素是：$C_{ij} = a_{i1}b_{1j}+a_{i2}b_{2j}+...+a_{in}b_{nj}=\sum_{r=1}^{n} a_{ir}b_{rj}$ ：

![image-20230514144009444](https://gitee.com/LowProfile666/image-bed/raw/master/img/矩阵的乘法.png)

满足以下规律：

+ $(AB)C=A(BC)$ 
+ $(A+B)C=AC+BC$ 
+ 不满足交换律。

## 6. 矩阵的翻转

水平翻转：将矩阵的每一行的元素进行逆序。

垂直翻转：将矩阵的每一列的元素进行逆序。

顺时针旋转90^0^：按顺时针的方向，将矩阵的第一行变成右边的第一列，第二行变成右边的第二列……

逆时针旋转90^o^：按逆时针的方向，将矩阵的第一行变成左边的第一列，第二行变成左边的第二列……

## 7. 题目练习

| 序号 |                           题目链接                           |                             备注                             |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  1   | [最富有客户的资产总量](https://leetcode.cn/problems/richest-customer-wealth/description/) |                             简单                             |
|  2   | [二进制矩阵中的特殊位置](https://leetcode.cn/problems/special-positions-in-a-binary-matrix/description/) |                      简单暴力，可以优化                      |
|  3   | [翻转图像](https://leetcode.cn/problems/flipping-an-image/description/) |               简单暴力，使用额外空间代码更简洁               |
|  4   | [旋转图像](https://leetcode.cn/problems/rotate-image/description/) |              中等模拟，不用额外空间的话就找规律              |
|  5   | [ 转置矩阵](https://leetcode.cn/problems/transpose-matrix/description/) |                           简单转置                           |
|  6   | [将一维数组转变成二维数组](https://leetcode.cn/problems/convert-1d-array-into-2d-array/description/) |                             简单                             |
|  7   | [判断矩阵经轮转后是否一致](https://leetcode.cn/problems/determine-whether-matrix-can-be-obtained-by-rotation/description/) |              简单，需要用到上面第4题的旋转方法               |
|  8   | [二维网格迁移](https://leetcode.cn/problems/shift-2d-grid/description/) | 简单题，用C语言二维数组简单，用Java的List\<List\<\>\>还是不太熟悉 |
|  9   | [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/description/) |            中等模拟题，需要注意边界问题与特殊情况            |

[旋转图像](https://leetcode.cn/problems/rotate-image/description/)

**题目描述**

> 给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。
>
> 你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

**解题思路**

1、找规律

最好是在草稿纸上把四个顶点的坐标写出来，找坐标间的规律，好好模拟一下，第 i 行 j 列的元素旋转后是倒数第 i 列 j 个位置，用代码表示出下标间的关系即可。

**Java代码**

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; i++) {   
            for (int j = 0; j < n-j; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n-j-1][i];
                matrix[n-j-1][i] = matrix[n-i-1][n-j-1];
                matrix[n-i-1][n-j-1] = matrix[j][n-i-1];
                matrix[j][n-i-1] = temp;
            }
        }   
    }
}
```

2、先将矩阵垂直翻转，再进行转置（对角线翻转）

**Java代码**

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 先垂直翻转
        for (int i = 0; i < n; i++) {
            int l = 0, r = n-1;       
            while (l < r) {
                int temp = matrix[l][i];
                matrix[l][i] = matrix[r][i];
                matrix[r][i] = temp;
                l++;
                r--;
            }
        }
        // 再转置
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}
```

---

# 四、组合数

先学习下排列数。

## 1. 排列数的概念定义

排列数指的是从 n 个不同元素中任取 $r(r≤n)$ 个元素排成一列（考虑元素先后出现次序）称此为一个**排列**，此种排列的总数即为**排列数**，即叫做从 n 个不同元素中取出 r 个元素的排列数。

排列数用 $A_{n}^{m}$ 或 $A(n,m)$ 表示，也可以用 $P_{n}^{m}$ 或 $P(n,m)$ 表示。

## 2. 排列数的计算公式

<font size=5px >$A_{n}^{m} =  \frac{n!}{(n-m)!}=n(n-1)(n-2)……(n-m+1)$ 。</font> 当 n = m 时，分母为 0! = 1。

## 3. 组合数的概念定义

从 n 个不同元素中，任取 $m(m≤n)$ 个元素并成一组，叫做从 n 个不同元素中取出 m 个元素的一个**组合**；从 n 个不同元素中取出$m(m≤n)$ 个元素的所有组合的个数，叫做从 n 个不同元素中取出 m 个元素的**组合数**。

组合数表示为 $C_{n}^{m}$ 或 $C(n,m)$ 。

## 4. 组合数的计算公式

<font size=5px >$C_{n}^{m} =  \frac{n!}{m!(n-m)!}=\frac{A_{n}^{m}}{m!},C_{n}^{0} = 1$ 。</font> 

## 5. 组合数的性质

**互补性质**：即从*n*个不同元素中取出*m*个元素的组合数 = 从*n*个不同元素中取出 (*n-m*) 个元素的组合数；用公式表为：

<font size=5px>$C_{n}^{m} =  \frac{n!}{m!(n-m)!}=C_{n}^{n-m}$</font> 

规定：

+ $C_{n}^{0}=1$ 
+ $C_{n}^{n}=1$ 
+ $C_{0}^{0}=1$ 

**组合恒等式**：若表示在 n 个物品中选取 m 个物品，则如存在下述公式：

<font size=5px>$C_{n}^{m}=C_{n}^{n-m}=C_{n-1}^{m-1}+C_{n-1}^{m}$</font>

## 6. 组合数的递推公式

<font size=5px>$C_{n}^{m}=C_{n-1}^{m-1}+C_{n-1}^{m}$</font>

理解：$C_{n}^{m}$ 表示从 n 个元素中取出 m 个元素，假设 m 个元素中任意一个元素为 特殊元素 ，所以从 n 个元素中取出 m 个元素这一过程可以表示为两个部分：

+ 包含该特殊元素：即 m 个被选元素中包含了这一特殊元素，相当于从 n-1 个元素中选出了 m-1 个元素的组合，即 $C_{n-1}^{m-1}$ 。
+ 不包含该特殊元素：即 m 个被选元素中不包含这一特殊元素，相当于从 n-1 个元素中选出了 n 个元素的组合，即 $C_{n-1}^{m}$ 。

【举例】：从 $1,2,3,4,5(n=5)$ 中取出 $2(m=2)$ 个数，即 $C_{5}^{2}$ ，有以下情况：

$(1,2)，(1,3)，(1,4)，(1,5)，(2,3)，(2,4)，(2,5)，(3,4)，(3,5)，(4,5)$

假设其中 1 是特殊元素，所有的组合可以分为两部分：

+ 包含 1 ：确定 1 是取出的 2（m）个元素之一，另一个元素则在剩下的 4（n-1）个数中取出 1（m-1）个即可，即 $C_{4}^{1}$ 。
+ 不包含 1 ：不考虑取出 1 的情况，从 剩下的 4（n-1）个数中取出 2（m）个数，即 $C_{4}^{2}$ 。

所以 $C_{5}^{2} = C_{4}^{1} + C_{4}^{2}$ 。

## 7. 题目练习

| 序号 |                           题目链接                           |                       备注                       |
| :--: | :----------------------------------------------------------: | :----------------------------------------------: |
|  1   | [杨辉三角](https://leetcode.cn/problems/pascals-triangle/description/) | 简单题，杨辉三角的递推公式类似于组合数的递推公式 |
|  2   | [杨辉三角 II](https://leetcode.cn/problems/pascals-triangle-ii/description/) |               简单题，上一题的变种               |

[杨辉三角](https://leetcode.cn/problems/pascals-triangle/description/)

**题目描述**

> 定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。
>
> 在「杨辉三角」中，每个数是它左上方和右上方的数的和。

**Java代码**

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < numRows; i++) {
            List<Integer> t = new ArrayList<>();
            t.add(1);
            for (int j = 1; j < i; j++) {
                int n1 = ans.get(i-1).get(j);
                int n2 = ans.get(i-1).get(j-1);
                t.add(n1+n2);
            }
            if (i != 0)
                t.add(1);
            ans.add(t);
        }
        return ans;
    }
}
```

---

# 五、计数法

## 1. 概念定义

**计数法**，顾名思义是利用变量来记录某个数值出现的次数的方法。

计数法一般有两种用法

+ 使用变量计数
+ 使用数组计数

【使用变量计数实例】：计算数组中某个数的出现次数。比如,以下代码功能为统计数组中 1 的个数。

```java
int cnt = 0;
int[] arr = {1, 2, 3, 1, 2, 3, 2, 2, 5, 6};
for (int i = 0; i < arr.length; i++) {
    if (arr[i] == 1)
        cnt++;
}
System.out.println(cnt);
```

【使用数组计数实例】：计算数组中所有数的出现次数。比如，以下代码功能为统计数组中每个数字（不大于10）出现的次数：

```java
int[] cnt = new int[10];
int[] arr = {1, 2, 2, 3, 5, 6, 4, 4, 6, 3, 2, 5, 7, 8};
for (int i = 0; i < arr.length; i++) {
    ++cnt[arr[i]];
}
for (int i = 0; i < 10; i++) {
    System.out.println(i + "的出现次数：" + cnt[i]);
}
```

在使用数组计数法时，一般适用于数据不大的情况下，因为要用统计的数据作计数数组的下标，然后在该位置的数组上记录出现次数，如果要统计的数据有特别大的，比如是 1000000 ，有时候题目有空间限制就开不了 1000000  这么大的数组出来，或者说开出来非常浪费空间，很不划算，所以数组计数一般使用于数据不大的情况下。

在用数组计数法的时候还需要注意一个事情，比如要计数的数据范围是 0 ~ 100，最大的数据为 100 ，但是需要开辟 101 大小的数组，因为如果开辟大小为 100 的数组的话，当记录到 100 这个数据时，会发生越界情况。

## 2. 题目练习

| 序号 |                           题目链接                           |                             备注                             |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  1   | [唯一元素的和](https://leetcode.cn/problems/sum-of-unique-elements/description/) |                      简单，使用计数数组                      |
|  2   | [字符串中的第一个唯一字符](https://leetcode.cn/problems/first-unique-character-in-a-string/description/) |                      简单，使用技术数组                      |
|  3   | [检查是否所有字符出现次数相同](https://leetcode.cn/problems/check-if-all-characters-have-equal-number-of-occurrences/description/) |                      简单，使用字符数组                      |
|  4   | [找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/description/) |             简单，使用字符数组，记得检查数据范围             |
|  5   | [好数对的数目](https://leetcode.cn/problems/number-of-good-pairs/description/) | 简单，两种计数方法都可以使用。变量计数要双层循环，数组计数一层循环 |
|  6   | [大餐计数](https://leetcode.cn/problems/count-good-meals/description/) |             中等，暴力循环会超时，使用计数数组，             |

[好数对的数目](https://leetcode.cn/problems/number-of-good-pairs/description/)

**题目描述**

> 给你一个整数数组 `nums` 。
>
> 如果一组数字 `(i,j)` 满足 `nums[i]` == `nums[j]` 且 `i` < `j` ，就可以认为这是一组 **好数对** 。
>
> 返回好数对的数目。

**解题思路**

1、暴力双循环+变量计数

两层循环控制 i，j 变量，判断是否满足条件，满足则计数加一，本题数据量不大，双循环不会超时。

**Java代码**

```java
class Solution {
    public int numIdenticalPairs(int[] nums) {
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = i+1; j < nums.length; j++) {
                if (nums[i] == nums[j])
                    ans++;
            }
        }
        return ans;
    }
}
```

2、单层循环+数组计数 

用一个计数数组，从前往后遍历给定数组的元素，记下每个数组元素的出现次数。从前往后遍历就保证了 i < j 的这个条件。

**Java代码**

```java
class Solution {
    public int numIdenticalPairs(int[] nums) {
        int ans = 0;
        int[] cnt = new int[101];
        for (int i = 0; i < nums.length; i++) {
            ans += cnt[nums[i]]++;
        }
        return ans;
    }
}
```

  [大餐计数](https://leetcode.cn/problems/count-good-meals/description/)

**题目描述**

> **大餐** 是指 **恰好包含两道不同餐品** 的一餐，其美味程度之和等于 2 的幂。
>
> 你可以搭配 **任意** 两道餐品做一顿大餐。
>
> 给你一个整数数组 `deliciousness` ，其中 `deliciousness[i]` 是第 `i` 道餐品的美味程度，返回你可以用数组中的餐品做出的不同 **大餐** 的数量。结果需要对 `10^9 + 7` 取余。
>
> 注意，只要餐品下标不同，就可以认为是不同的餐品，即便它们的美味程度相同。

**解题思路**

1、暴力双循环+暴力计数（超时）

拿到题的第一思路就是这个，双循环遍历不同的元素，判断加起来是否为 2 的幂，超时。

2、双重循环+计数数组

第一层循环遍历数组的每个元素。第二层循环用来枚举给定范围的所有的 2 的幂，来寻找能和当前元素相加为 2 的幂的另一个数，计数数组就是用来记录每个元素的出现次数，然后当第二层循环找到另一个数时，结果就加上这个数的出现次数。

**Java代码**

```java
class Solution {
    public int countPairs(int[] deliciousness) {
        int[] cnt = new int[1<<21+1];
        int ans = 0;
        for (int i = 0; i < deliciousness.length; i++) {
            for (int sum = 1; sum <= (1<<21); sum *= 2) {
                int other = sum - deliciousness[i];
                if (other < 0)
                    continue;
                ans += cnt[other];
                ans %= (int)(1e9+7);
            }
            ++cnt[deliciousness[i]];
        }
        return ans;
    }
}
```

第一次过这题是 2022.01.25 用C语言写的，忘记了看题解没有，反正这次如果没有看之前的提交估计做不出来……

**C语言代码**

```java
int countPairs(int* deliciousness, int deliciousnessSize){
    int count[(1<<21)+1];                   //计数数组
    memset(count,0,sizeof(count));          //初始化数组
    int ans,other;                          //ans是结果
    for(int i=0;i<deliciousnessSize;i++){   //遍历数组里的元素
        for(int sum=1;sum<=(1<<21);sum*=2){  //枚举每一种结果
            other=sum-deliciousness[i];     //可以枚举出other
            if(other<0) 
                continue;
            //other存在说明可以和当前的deliciousness[i]组成大餐，所以结果数要加上other的出现次数
            ans+=count[other];              
            ans%=1000000007;            
        }
        ++count[deliciousness[i]];          //记录这个数的出现次数，这里的操作才是记录出现次数
    }
    return ans;
}
```

---

# 六、日期算法

## 1. 最常见的日期算法

判断一个年份是否是闰年。

判断一个年份是否是闰年时通常要满足以下两个条件之一 ：

+ 能被 4 整除，同时不能被 100 整除；
+ 能被 400 整除。

那以上条件转换为代码表示如下：

```java
int year = 2023;
if ((year % 4 == 0 && year % 100 != 0) || year % 400 == 0)
    System.out.println(year + "是闰年");
```

平年和闰年之间相差 1 天，平年只有 365 天，闰年有 366 天，差的这一天为 2 月 29 日，所以，平年的 2 月只有 28 天，闰年的 2 月有 29 天。做题中，这个 2 月 29 日经常会被忽略，所以需要注意。

## 2. 题目练习

| 序号 |                           题目链接                           |           备注           |
| :--: | :----------------------------------------------------------: | :----------------------: |
|  1   | [一周中的第几天](https://leetcode.cn/problems/day-of-the-week/description/) |          简单题          |
|  2   | [ 一年中的第几天](https://leetcode.cn/problems/day-of-the-year/description/) |          简单题          |
|  3   | [日期之间隔几天](https://leetcode.cn/problems/number-of-days-between-two-dates/description/) | 简单题，综合了以上两道题 |

[日期之间隔几天](https://leetcode.cn/problems/number-of-days-between-two-dates/description/)

**题目描述**

> 请你编写一个程序来计算两个日期之间隔了多少天。
>
> 日期以字符串形式给出，格式为 `YYYY-MM-DD`，如示例所示。

**示例1**

```
输入：date1 = "2019-06-29", date2 = "2019-06-30"
输出：1
```

**解题思路**

1、直接计算两日期的间隔天数。

需要先将字符串转化为数字类型（y，m，d），然后用一个方法分别计算出该日期在该年的第几天（sum），再判断两个日期的年份大小

+ 如果两个年份相等（y1 == y2），那么两个日期之间间隔天数就为（sum1 - sum2）的绝对值；
+ 如果（y1 > y2），那么先把 y2 该年剩余的天数加上，然后从 y2 + 1 年开始循环累加每年的天数，直到 y1 - 1 年；
+ 如果（y2 > y1），那么先把 y1 该年剩余的天数加上，然后从 y1 + 1 年开始循环累加每年的天数，直到 y2 - 1 年。

需要注意的是闰年的 2 月天数。

**Java代码**

```java
class Solution {
    public int daysBetweenDates(String date1, String date2) {
        int y1 = Integer.parseInt(date1.substring(0, 4));
        int y2 = Integer.parseInt(date2.substring(0, 4));
        int m1 = Integer.parseInt(date1.substring(5, 7));
        int m2 = Integer.parseInt(date2.substring(5, 7));
        int d1 = Integer.parseInt(date1.substring(8, 10));
        int d2 = Integer.parseInt(date2.substring(8, 10));   
        int sum1 = yearDays(y1, m1, d1);
        int sum2 = yearDays(y2, m2, d2);
        int ans = 0;
        if (y1 >= y2) {
            ans = intervalDays(y1, y2, sum1, sum2);
        } else {
            ans = intervalDays(y2, y1, sum2, sum1);
        } 
        return ans;
    }
    // 两个年份之间差距的天数，保证y1 > y2
    public int intervalDays (int y1, int y2, int sum1, int sum2) { 
        if (y1 == y2)
            return Math.abs(sum1 - sum2);
        int ret = 0;
        if (isLeapYear(y2))
            ret += 366 - sum2;
        else
            ret += 365 - sum2;
        for (int i = y2+1; i < y1; i++) {
            if (isLeapYear(i))
                ret += 366;
            else
                ret += 365;
        }
        ret += sum1;
        return ret;
    }
    // 当前日期为该年的多少天
    public int yearDays(int year, int month, int day) {
        int[] monthDays = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
        int ret = 0;
        if (isLeapYear(year))
            monthDays[2] = 29;
        for (int i = 1; i < month; i++) {
            ret += monthDays[i];
        }
        return ret + day;
    }
    // 判断闰年
    public boolean isLeapYear(int year) {
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);
    }
}
```

2、引入第三个初始日期，计算给定的日期距离初始日期的天数，然后两个天数相减。

写完上面 Java 代码，提交过后发现以前提交的 C 代码思路不一样。

用一个比两个日期都小的日期，分别计算两个日期距离该日期的天数，然后相减，即可得两个日期之间间隔天数。

**C代码**

```c
//将字符串转为数字
int toInt(char* date,int len){
    int res=0;
    for(int i=0;i<len;i++){
        res=res*10+(date[i]-'0');
    }
    return  res;
}
//判断平润
bool isLeapYear(int year){
    return (year%4==0&&year%100!=0)||(year%400==0);
}
//计算与1971-01-01相差的天数
int count(char* date){
    int y=toInt(&date[0],4);
    int m=toInt(&date[5],2);
    int d=toInt(&date[8],2);
    int sum=0;
    int month_day[]={0,31,28,31,30,31,30,31,31,30,31,30,31};
    //先计算相差了多少个年头
    for(int i=1971;i<y;i++){
        if(isLeapYear(i))
            sum+=366;
        else
            sum+=365;
    }
    //在计算相差了多少个月份
    if(isLeapYear(y)) month_day[2]=29;
    for(int i=1;i<m;i++){
        sum+=month_day[i];
    }
    //最后加上号数返回
    return sum+d;
}

int daysBetweenDates(char * date1, char * date2){
    int num1=count(date1);
    int num2=count(date2);
    return (num1>num2?(num1-num2):(num2-num1));
}
```

C 语言代码居然比 Java 还少点。

---

# 七、素数判定

## 1. 整除

在式子 $a\div b=c$ 中，$a$ 叫做被除数，$b$ 叫做除数，$c$ 叫做商， $a\div b$ 读作 “a 除以 b” 或 “b 除 a”。

若整数 b 除以非零整数 a ，商为整数，且余数为 0 ，即 a | b（ | 是整除符号），读作 “a整除b” 或 “b能被a整除” 。

基本性质：

+ 若 b|a，c|a，且 b 和 c 互质，则 bc|a 。
+ 若 c|a，c|b，则称 c 是 a，b 的公因数。
+ 若 a，b 的最大公因数等于 1 ，则称 a，b 互质（互素）。

## 2. 素数与合数

素数又称为**质数**，是指在大于 1 的自然数中，除了 1 和它本身以外不再有其他因数的自然数。也就是说，质数除了能被 1 和 它本身整除外，不能被其他数整除。

否则，称为合数。

**合数**是指在大于 1 的整数中，除了能被 1 和本身整除外，太能被其他数（0除外）整除的数。

规定：==1 既不是质数，也不是合数。==

## 3. 性质

质素的性质：

+ 质素p 的约数只有两个：1 和 p 。
+ 任一大于 1 的自然数，要么本身是质数，要么可以分解为几个质数之积，且这种分解是唯一的。（算术基本定理）
+ 质数的个数是无限的。
+ 若 n 为正整数，在 n^2^ 到 (n+1)^2^ 之间至少有一个质数。
+ 若 n 为大于或等于 2 的正整数，在 n 到 n! 之间至少有一个质数。
+ 所有大于 10 的质数中，个位数只有 1 , 3 , 7 , 9 。
+ 在一个大于 1 的数 a 和它的 2 倍之间（即区间（a, 2a] 中）必存在至少一个素数。
+ 不存在长度为8的素数（10000000~99999999中没有素数）

合数的性质：

+ 每一个合数都可以以唯一形式被写成质数的乘积，即分解质因数。（算术基本定理）
+ 所有大于 2 的偶数都是合数。
+ 所有大于 5 的奇数中，个位为 5 的都是合数。
+ 除 0 以外，所有个位为 0 的自然数都是合数。
+ 所有个位为 4，6，8 的自然数都是合数。
+ 最小的（偶）合数为 4 ，最小的奇合数为 9 。

## 3. 素数判定

如何判断一个数 n 是否为素数？

枚举 2 到 n-1 的所有数，判断每个数是否能整除 n ，如果有数能整除 n，那么 n 不是一个素数，否则，n 是一个素数。

Java代码：

```java
public boolean isPrime(int n) {
    for (int i = 2; i < n; i++) {
        if (n % i == 0)
            return false;
    }
    return true;
}
```

以上代码可以进行优化。

**优化**：如果一个数有因子的话，那么它的平方根数以内就有，否则没有因子。

假如一个数 x 是数 n 的因子，即 n | x ，那么一定有一个数 $\frac{n}{x}$ 是 n 的因子且为整数。在 x 和 n/x 之间，会有一个大小关系，假设这个大小关系为 $x \le \frac{n}{x}$ ，就有 $x^2 \le n$ ，再有 $x \le \sqrt{n}$ ，所以在以上程序中，只需要枚举【2，$\sqrt{n}$】的范围即可判定出 n 是否为素数。

以上推理过程中，假设大小关系时，假设为  $x \le \frac{n}{x}$ 或  $\frac{n}{x} \le x$ 都是一样的，因为一定会有一个因子大、一个因子小，如果是完全平方数的话就会有两个因子相等的情况。而因为枚举因子时是从小往大枚举，所以用假设  $x \le \frac{n}{x}$ 来推理。

优化Java代码：

```java
public boolean isPrime(int n) {
    for (int i = 2; i <= Math.sqrt(n); i++) {
        if (n % i == 0)
            return false;
    }
    // 或者换种表示
    // for (int i = 2; i*i <= n; i++) {
    //    if (n % i == 0)
    //        return false;
    // }
    return true;
}
```

## 4. 题目练习

| 序号 |                           题目链接                           |                           备注                           |
| :--: | :----------------------------------------------------------: | :------------------------------------------------------: |
|  1   | [回文素数](https://leetcode.cn/problems/prime-palindrome/description/) |        中等题，学到了知识点：不存在长度为8的素数         |
|  2   | [丑数](https://leetcode.cn/problems/chou-shu-lcof/description/) | 中等题，第二次做，又看了以前提交的答案，三指针、动态规划 |

[回文素数](https://leetcode.cn/problems/prime-palindrome/description/)

**题目描述**

> 求出大于或等于 `N` 的最小回文素数。
>
> 回顾一下，如果一个数大于 1，且其因数只有 1 和它自身，那么这个数是*素数*。
>
> 例如，2，3，5，7，11 以及 13 是素数。
>
> 回顾一下，如果一个数从左往右读与从右往左读是一样的，那么这个数是*回文数。*
>
> 例如，12321 是回文数。

**解题思路**

一个判断是否是素数的方法，一个判断是否是回文串的方法，然后暴力枚举。这一题主要学会了==没有8位数的素数==:dog: 。

**Java代码**

```java
class Solution {
    public int primePalindrome(int n) {
        if (n <= 3) return n == 1 ? 2 : n;
        for (int i = n; ; i++) {
            if (isPalindrome(i) && isPrime(i))
                return i;
        }
    }
    public boolean isPrime(int n) {
        if (n > 2 && n % 2 == 0) return false;
        if (n > 5 && n % 5 == 0)    return false;
        if (n % 10 == 0)    return false;
        for (int i = 2; i*i <= n; i++) {
            if (n % i == 0)
                return false;
        }
        return true;
    }
    public boolean isPalindrome(int n) {
        if (n < 10) return true;
        if (n >= 10000000 && n <= 99999999) return false;
        int m = 0;
        int t = n;
        while (t != 0) {
            m = m * 10 + t % 10;
            t /= 10;
        }
        return n == m;
    }
}
```

[丑数](https://leetcode.cn/problems/chou-shu-lcof/description/)

**题目描述**

> 我们把只包含质因子 2、3 和 5 的数称作丑数（Ugly Number）。求按从小到大的顺序的第 n 个丑数。
>
> `1` 是丑数。

**解题思路**

三指针 + 动态规划，定义一个数组 num[] ，num[i] 表示第 i+1 个丑数，第一个丑数为 1，所以 num[0] = 1，然后定义三指针 i, j, k 用来表示下一个丑数是当前指针指向的丑数乘以对应的质因数，三指针初始化都为0。

**Java代码**

```java
class Solution {
    public int nthUglyNumber(int n) {
        int[] num = new int[n];
        num[0] = 1;
        for (int i = 0, j = 0, k = 0, idx = 1; idx < n; idx++) {
            int x = num[i] * 2;
            int y = num[j] * 3;
            int z = num[k] * 5;
            int min = (x > y ? (y > z ? z : y) : (x > z ? z : x));
            if (min == x)   i++;
            if (min == y)   j++;
            if (min == z)   k++;
            num[idx] = min;
        }
        return num[n-1];
    }
}
```

这个题2022.2.14第一次做，现在第二次做了，想起了三指针，但是没有想起动态规划，还是没有完全掌握。

---

# 八、素数筛选

## 1. Eratosthenes筛法

**埃拉托斯特尼筛法**简称埃氏筛或爱氏筛，是一种由希腊数学家 Eratosthenes 所提出的一种简单检定素数的算法,是一种用来求所有小于 N 的素数的方法。

**主要思想**：把从 2 到 N 的一组正整数从小到大按顺序排列，依次删除每个素数的倍数，留下的就全是素数。

**主要用途：**筛法一般用来计算素数的个数、求出给定范围里的所有素数。

**具体实现：**

使用一个标记数组 flag[] ，其中 flag[i] 表示 i 是否为素数，0 表示素数，否则表示非素数。之所以用 0 表示为素数，因为 Java 创建数组后数组初始化所有元素为 0 ，不需要再赋初始值，方便一点。

因为 0 和 1 都不是素数，所以首先 flag[0] = flag[1] = 1。然后在未被标记的数中找到最小的数，判断这个数是否是素数，如果是素数则将该数的倍数都标记为 1 ，否则将该数标记为 1 ，然后接着向后寻找……

## 2. 题目练习

| 序号 |                           题目链接                           |                             备注                             |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  1   | [质数排列](https://leetcode.cn/problems/prime-arrangements/description/) |       简单题，用筛法算出素数个数，还有用到了排列的知识       |
|  2   | [计数质数](https://leetcode.cn/problems/count-primes/description/) | 中等题，比上一题要简单点，但是数据大一点，Java需要多判断一次 |

  [质数排列](https://leetcode.cn/problems/prime-arrangements/description/)

**题目描述**

> 请你帮忙给从 `1` 到 `n` 的数设计排列方案，使得所有的「质数」都应该被放在「质数索引」（索引从 1 开始）上；你需要返回可能的方案总数。
>
> 让我们一起来回顾一下「质数」：质数一定是大于 1 的，并且不能用两个小于它的正整数的乘积来表示。
>
> 由于答案可能会很大，所以请你返回答案 **模 mod `10^9 + 7`** 之后的结果即可。

**解题思路**

由题可知，这题数据从 1 开始，下标也是从 1 开始，所以 1 到 n 中有多少个素数就有多少个素数位置。这里就用到了简单的排列知识，这题的答案就是 素数的全排列 $\times$ 非素数的全排列 。

**Java代码**

```java
class Solution {
    public int numPrimeArrangements(int n) {
        // 先算出素数的个数
        int cnt = 0;
        int[] f = new int[n+1];
        f[0] = f[1] = 1;
        // 埃氏筛
        for (int i = 2; i <= n; i++) {
            if (f[i] == 0) {
                ++cnt;
                for (int j = i*i; j <= n; j += i)  // （1）
                    f[j] = 1;
            }
        }
        // 然后素数的全排列 x 非素数的全排列
        return (int)(sum(cnt) * sum(n-cnt) % (int)(1e9+7));
    }
    public long sum(int n) {
        if (n <= 1)
            return 1;
        return n * sum(n-1) % (int)(1e9+7);
    }
}
```

（1）：因为 i \* 2、i \* 3……这些数肯定被前面的 2 或 3 筛掉了，所以可以直接从 i \* i 开始。

[计数质数](https://leetcode.cn/problems/count-primes/description/)

**题目描述**

> 给定整数 `n` ，返回 *所有小于非负整数 `n` 的质数的数量* 。

**解题思路**

这题的数据范围是 0 到 n-1 ，不包含 n 的。只需要计算素数的个数就可以了，但是在编码过程中需要注意数据的大小，可能会导致溢出。

**Java代码**

```java
class Solution {
    public int countPrimes(int n) {
        if (n <= 2)
            return 0;
        int ans = 0;
        int[] f = new int[n+1];
        f[0] = f[1] = 1;
        // 埃氏筛
        for (int i = 2; i < n; i++) {
            if (f[i] == 0) {
                ++ans;
                if (i * i < n)  // 防止溢出
                    for (int j = i; j < n; j += i) 
                        f[j] = 1;
            }
        }
        return ans;
    }
}
```

---

# 九、算术基本定理

## 1. 概念定义

算术基本定理可表述为：任何一个大于 1 的自然数 N ，如果 N 不为质数，那么 N 可以==**唯一**分解成有限个质数的乘积==：

​        $N=p1p2p3...pn（p1\le p2\le p3\le ... \le pn，p_i均为质数）$ 

其中 $p_i$ 可以是相等的，所以可以将上式相等的质数进行合并，使用幂的形式表示：

​        $N={p_1}^{a1}{p_2}^{a2}{p_3}^{a3}...{p_n}^{an}（p1\le p2\le p3\le ... \le pn，p_i均为质数，ai为正整数）$

这样的分解称为 N 的**标准分解式**。

Java代码实现

```java
 public void decomposedPrimeFactor (int[] primeFactors, int n) {  // (1)
     int t = n;
     for (int i = 2; i < t; i++) {
         while (n != 0 && n % i == 0) {
             n /= i;
             primeFactors[i]++;
         }
     }
 }
```

（1）：primeFactors 数组用来记录素因子以及个数，它的长度有两种情况

+ n/2 大小：因为不考虑 n 是素数的情况，那它的素因子就不会超过 n/2。
+ n+1 大小：如果 n 是素数，就只有 1 和 n 本身为因子，那么需要开辟 n+1 的大小来保存因子 n。

## 2. 题目练习

| 序号 |                           题目链接                           |                             备注                             |
| :--: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  1   | [完美数](https://leetcode.cn/problems/perfect-number/description/) | 简单题，枚举因子，累加因子，一次累加两个因子，所以枚举范围和判断质数的枚举范围一样 |
|  2   | [丑数](https://leetcode.cn/problems/ugly-number/description/) | 简单题，数学知识，只包含 2 3 5 三个质因数的数，反复除以 2 3 5 后，最后只剩下 1 就是丑数 |

  [完美数](https://leetcode.cn/problems/perfect-number/description/)

**题目描述**

> 对于一个 **正整数**，如果它和除了它自身以外的所有 **正因子** 之和相等，我们称它为 **「完美数」**。
>
> 给定一个 **整数** `n`， 如果是完美数，返回 `true`；否则返回 `false`。

**解题思路**

找出这个数的所有因子，并累加起来，判断累加结果是否和原数相等。在枚举因子时，因为因子都是成对出现的，所以一次可以累加两个因子，所以枚举范围也可以缩半。

还需要注意的是，1 是所有数的因子，又因为一次累加两个因子，1 的对应因子就是数的本身，所以 1 应该为累加器的初始值，避免累加 1 后又累加这个数本身。

**Java代码**

```java
class Solution {
    public boolean checkPerfectNumber(int num) {
        if (num <= 1)
            return false;
        int sum = 1;
        for (int i = 2; i*i < num; i++) {
            if (num % i == 0) {
                sum += i;
                sum += num / i;
                if (sum > num)
                    return false;
            }
        }
        return sum == num;
    }
}
```

[丑数](https://leetcode.cn/problems/ugly-number/description/)

**题目描述**

> **丑数** 就是只包含质因数 `2`、`3` 和 `5` 的正整数。
>
> 给你一个整数 `n` ，请你判断 `n` 是否为 **丑数** 。如果是，返回 `true` ；否则，返回 `false` 。

**解题思路**

如果 n 是丑数的话，那么 n 可以表示为：$n=2^a \times 3^b \times 5^c$，所以可以将 n 一直循环除以 2 3 5 这三个因子，如果最后 n 为 1 ，那么 n 就是丑数。

**Java代码**

```java
class Solution {
    public boolean isUgly(int n) {
        if (n <= 1)
            return n == 1;
        int[] arr = {2,3,5};
        for (int i = 0; i < 3; i++) {
            while (n % arr[i] == 0)
                n /= arr[i];
        }
        return n == 1;
    }
}
```

---

# 十、因子分解和枚举

## 1. 概念定义

**因数分解**又称为**素因数分解**，是把一个正整数写成几个约数的乘积。例如，给出 45 这个数，它可以分解成 3×3×5 ，根据算术基本定理，这样的分解结果应该是独一无二的。

**具体实现：**试除法。可以对一个数的素因子进行试除，比如先一直除素因子 2 ，除尽所有的 2 后，一直除素因子 3 ，就这样一直除这个数的所有素因子，就可以分解成几个素约数的乘积。

## 2. 题目练习

| 序号 | 题目链接                                                     | 备注                                                       |
| ---- | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 1    | [三除数](https://leetcode.cn/problems/three-divisors/description/) | 简单题，可以暴力枚举；可以看出是在判断是否是一个完全平方数 |
| 2    | [ n 的第 k 个因子](https://leetcode.cn/problems/the-kth-factor-of-n/description/) | 中等题，枚举因子 + 计数                                    |
| 3    | [最接近的因数](https://leetcode.cn/problems/closest-divisors/description/) | 中等题，双指针枚举因子或者双循环枚举因子                   |
| 4    | [好因子的最大数目](https://leetcode.cn/problems/maximize-number-of-nice-divisors/) | 困难题，不会做。。。                                       |

 [三除数](https://leetcode.cn/problems/three-divisors/description/)

**题目描述**

> 给你一个整数 `n` 。如果 `n` **恰好有三个正除数** ，返回 `true` ；否则，返回 `false` 。
>
> 如果存在整数 `k` ，满足 `n = k * m` ，那么整数 `m` 就是 `n` 的一个 **除数** 。

**解题思路1**：

【暴力枚举 + 计数法】

直接枚举 [2, sqrt(n)] 范围内的数，判断是否是因子，是则计数器 +1 ，因为因子是成对出现，所以判断两个因子是否相同，不同的话计数加两次，相同的话就加一次。

**Java代码**

```java
class Solution {
    public boolean isThree(int n) {
        int cnt = 0;
        for (int i = 1; i*i <= n; i++) {
            if (n % i == 0) {
                cnt++;
                if (n/i != i)
                    cnt++;
            }
            if (cnt > 3)
                return false;
        }
        return cnt == 3;
    }
}
```

**解题思路2：**

【完全平方数】

由题，n 恰好有 3 个正除数，那除了 1 和 n 本身外，只有一个正除数，说明 n 是一个完全平方数。所以可以先判断 n 是不是完全平方数，如果是的话再枚举还有没有其他因子。

```java
class Solution {
    public boolean isThree(int n) {
        // 其实就是一个完全平方数
        if (n <= 3)
            return false;
        int sqrtn = (int)Math.sqrt(n*1.0);
        if (sqrtn * sqrtn != n)
            return false;
        for (int i = 2; i < sqrtn; i++)
            if (n % i == 0)
                return false;
        return true;
    }
}
```

  [ n 的第 k 个因子](https://leetcode.cn/problems/the-kth-factor-of-n/description/)

**题目描述**

> 给你两个正整数 `n` 和 `k` 。
>
> 如果正整数 `i` 满足 `n % i == 0` ，那么我们就说正整数 `i` 是整数 `n` 的因子。
>
> 考虑整数 `n` 的所有因子，将它们 **升序排列** 。请你返回第 `k` 个因子。如果 `n` 的因子数少于 `k` ，请你返回 `-1` 。

**解题思路：**

在 [1, n] 范围内枚举因子，同时将计数器 k 减减，直到因子枚举完或者 k 小于等于 0 时，如果最后 k 不等于 0 ，说明因子枚举完了但是没有到第 k 个，即因字数小于 k 。

**Java代码**

```java
class Solution {
    public int kthFactor(int n, int k) {
        int ans = -1;
        for (int i = 1; i <= n && k > 0; i++) {
            if (n % i == 0) {
                k--;
                ans = i;
            }
        }
        if (k != 0)
            return -1;
        return ans;
    }
}
```

[最接近的因数](https://leetcode.cn/problems/closest-divisors/description/)

**题目描述**

> 给你一个整数 `num`，请你找出同时满足下面全部要求的两个整数：
>
> - 两数乘积等于  `num + 1` 或 `num + 2`
> - 以绝对差进行度量，两数大小最接近
>
> 你可以按任意顺序返回这两个整数。

**解题思路1：**

【双指针】

首先要知道，一个完全平方数的存在两个相同的因子。如果 num+1 或 num+2 是完全平方数的话，那么答案一定是那两个相等的因子；如果不是完全平方数的话，那可以用双指针，分别以 sqrt(num+1) 和 sqrt(num+1)+1 为起点，向左右两边移动，来寻找两个因子，如果左右指针之积小于 num+1，就将左指针扩大；如果积大于 num+2，就将右指针减小。

**Java代码**

```java
class Solution {
    public int[] closestDivisors(int num) {
        if (num == 1) {
            return new int[]{1,2};
        }
        int[] ans = new int[2];
        int l = (int)Math.sqrt(num+1), r = l+1;
        if (l * l == num+1) {
            return new int[]{l, l};
        }
        ans[0] = l;
        ans[1] = r;
        int min = num+1;
        while (l >= 1 && r <= num) {
            if (l * r == (num + 1) || l * r == (num+2)) {
                if (r - l < min) {
                    min = r - l;
                    ans[0] = l;
                    ans[1] = r;
                } else {
                    break;
                }
                l--;
                r++;
            }
            else if (l * r > (num+2))
                r--;
            else if (l * r < (num+1))
                l++;
        }
        return ans;
    }
}
```

**解题思路2：**

【双循环】

换个角度思考，其实就是在找 num+1 和 num+2 这两个数的一对因子，所以使用双循环，先找 num+1 的因子对，再找 num+2 的因子对。

**Java代码**

```java 
lass Solution {
    public int[] closestDivisors(int num) {
        int[] ans = new int[2];
        int min = num+2;
        for (int n = num+1; n <= num+2; n++) {
            for (int i = 1; i*i <= n; i++) {
                if (n % i == 0) {
                    int j = n / i;
                    if (j - i < min) {
                        min = j - i;
                        ans[0] = i;
                        ans[1] = j;
                    }
                }
            }
        }
        return ans;
    }
}
```

---

# 十一、因子个数

## 1. 概念定义

**因数**是指整数 a 除以整数 b（b不等于0）的商正好是整数而没有余数，我们就说 b 是 a 的因数。因数又称为**约数**或**因子**。

**乘法原理：**做一件事，完成它需要分成 n 个步骤，做第一 步有 m1 种不同的方法，做第二步有 m2 种不同的方法，……，做第 n 步有 mn 种不同的方法。那么完成这件事共有 N=m1×m2×m3×…×mn 种不同的方法。

如何求一个数 n 的因子个数呢？

1）暴力法 + 计数法

在 [1, n] 的范围内枚举，判断是否是能整除 n 的数。但是考虑到因子是成对出现的，如果一个数 a 是 n 的因子，那么一定有另一个数 $\frac{n}{a}$ 也是 n 的因子，假设 $a\le \frac{n}{a}$ ，就有 $a \le \sqrt{n}$ ，所以只需要枚举 $[1,\sqrt{n}]$ 范围内的数即可，同时判断 a 和 $\frac{n}{a}$ 是否相同，不相同计数器一次 +2。

2）算术基本定理 + 乘法原理

根据**算术基本定理**，n 一定可以表示为 $p1p2p3...pk$ ，其中 $p1$ 可取的个数为 $[0,a1]$ ，$p2$ 可取的个数为 $[0, a2]$ ，$pk$ 可取的个数为 $[0, ak]$ ，所以结合乘法原理来看，其中 ${p_{i}}$ 就代表着第 i 步有 ai+1 种不同的方法，也就是说 ${p_{i}}$ 有 ai+1 种取值可能。

所以根据**乘法原理**， n 的因子个数 g(n) 等于 ai+1 的连乘：$g(n)=\prod _{i=1}^{k}(ai+1)$ 。ai+1 是每个位置的可取值个数。

## 2. 题目练习

| 序号 | 题目链接                                                     | 备注                                                         |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1    | [The number of divisors about Humble Numbers](http://acm.hdu.edu.cn/showproblem.php?pid=1492) | 杭电OJ的题，简单题，但是第一次做这种类型的题目，全英文还好说，主要是WA、TLE都没有提示，错了也不知道自己是什么问题。 |
| 2    | [本原串](http://acm.hdu.edu.cn/showproblem.php?pid=2197)     | 杭电OJ的题                                                   |

## 3. 题解报告

[The number of divisors about Humble Numbers](http://acm.hdu.edu.cn/showproblem.php?pid=1492)

**题目描述**

> A number whose only prime factors are 2,3,5 or 7 is called a humble number. The sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 24, 25, 27, ... shows the first 20 humble numbers.
>
> Now given a humble number, please write a program to calculate the number of divisors about this humble number. For  example, 4 is a humble,and it have 3 divisors(1,2,4);12 have 6 divisors.

**解题思路**

题意就是计算给定数 n 的因子个数。该数只有质因数 2，3，5，7 ，所以可以用算术基本定理来解决。

根据算术基本定理：$n=2^a \times 3^b \times 5^c \times 7^d$ ，再结合乘法原理，可得 n 的因子个数为：$(a+1)(b+1)(c+1)(d+1)$ 。得出这个公式后，该问题最主要的步骤就是算出每个质因数的个数，用试除法即可算出。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        long n = 0;
        List<Integer> ans = new ArrayList<>();
        while ((n=sc.nextLong()) != 0) {
            ans.add(sum(n));
        }
        for (int i = 0; i < ans.size(); i++) {
            System.out.println(ans.get(i));
        }
    }
    public static int sum(long n) {
        int ret = 0;
        int n2 = 0, n3 = 0, n5 = 0, n7 = 0;
        while (n != 0 && n % 2 == 0) {
            n2++;
            n /= 2;
        }
        while (n != 0 && n % 3 == 0) {
            n3++;
            n /= 3;
        }
        while (n != 0 && n % 5 == 0) {
            n5++;
            n /= 5;
        }
        while (n != 0 && n % 7 == 0) {
            n7++;
            n /= 7;
        }
        ret = (n2+1) * (n3+1) * (n5+1) * (n7+1);
        return ret;
    }
}
```

[本原串](http://acm.hdu.edu.cn/showproblem.php?pid=2197)

**题目描述**

> 由0和1组成的串中，不能表示为由几个相同的较小的串连接成的串，称为本原串，有多少个长为n（n<=100000000)的本原串?答案mod2008.
>
> 例如，100100不是本原串，因为他是由两个100组成，而1101是本原串。

**解题思路**

本原串的个数 = 串的总数 - 非本原串的个数。

串的长度为 n ，每一位上只能用 0 和 1 表示，所以总的串数为 2^n^，但是题目要求串由 0 和 1 组成，所以总的串数应该减去全 0 和全 1 的串数，即 总的串数 = 2^n^ - 2。

非本原串一定是由 a 位长度的串相加 b 次后得到的串，比如 100100 就是由 3 位的 100 串相加 2 次得到的，所以 a, b 一定是 n 的因子。假设用 f[n] 表示长度为 n 的本原串个数，有 f[n] = 2^n^ - 2 - f[a]，其中 a 是 n 的因数。

**C语言代码**

代码是网上抄的，自己写的Java代码有问题。等二刷时自己再理解写一遍。

```c
#include <stdio.h>

#define LL long long
#define mod 2008
#define N 100000005
int f[N];
int pow_mod(int a,int n)
{
    LL ans=1;
    while(n)
    {
        if(n&1) ans=ans*a%mod;
        a=a*a%mod;
        n>>=1;
    }
    return ans;
}
int get(int n)
{
    if(f[n]) return f[n];
    if(n==1) return 2;
    int ans=pow_mod(2,n);
    for(int i=2;i*i<=n;i++)
    {
        if(n%i==0)
        {
            ans=(ans-get(i))%mod;
            int t=n/i;
            if(i*i!=n) ans=(ans-get(t)+mod)%mod;
        }
    }
    return f[n]=(ans-2+mod)%mod;
}
int main()
{
    int n;
    while(~scanf("%d",&n))
        printf("%d\n",get(n));
    return 0;
}
```

---

# 十二、因子和

## 1. 概念定义

**因子和**就是一个数的所有因子之和。

如何求一个数 n 的因子和？

假设数 n 的因子和为 s(n)，根据算术基本定理，可将 n 分解成质数的乘积。假设最小的质因子为 p，p 的个数为 e，那么有：

​														$n=p^en'$ ，这里的 n' 表示 $n/p^e$ ，即除 p^e^ 外的其他质因子之积。

由上式可得，

+ 当 e = 0 时，$s(n)=s(n')$ 
+ 当 e = k 时，$s(n)=p^k\times s(n')$ 

所以，因子和 s(n) 可以表示为：$s(n)=(p^0+p^1+p^2+p^3+...+p^e)\times s(n')$ 。

+ 因为数 n 中所有的因子都可以分解成质因子的乘积，所以 p^k^ 就表示最小的质因子 p 在 n 的所有因子中出现的最高次数 k 次，那么就有因子 p^0^, p^1^, p^2^, ... , p^k^，然后再与 s(n') 中的质因子相乘就会构成原来的因子。

> 【举例】n = 100，$n=2^2\times 5^2$ 。
>
> n 的因子和： 
>
> $s(100)=1+100+2+50+4+25+5+20+10=217$ 。
>
> $s(100)=(2^0+2^1+2^2)\times (5^0+5^1+5^2)$
>
> ​			$= 1+5+25+2+10+50+4+20+100$
>
> ​			$= 217$
>
> 所以可以看出，p^k^ 是表示质因子 p 最高出现的次数。
>
> 这一段我自己理解的有点吃力，如果有问题可以评论提出，我改。

再根据等比数列的求和公式可得：

​							<font size=5px>$s(n)=\frac{p^0\times (1-p^e)}{1-p}\times s(n')=\frac{1-p^{e+1}}{1-p}\times s(n')=\frac{p^{e+1}-1}{p-1}\times s(n')$</font>   

其中的 $s(n')$ 的计算方法相同，所以数 n 的因子和可以表示为一系列等比数列之和的乘积：

​														<font size=5px>$s(n)=\prod _{i=1}^k \frac{{p_i}^{e_i+1}-1}{p_i-1}$ </font> 

## 2. 题目练习

| 序号 | 题目链接                                                     | 备注                               |
| ---- | ------------------------------------------------------------ | ---------------------------------- |
| ·    | [四因数](https://leetcode.cn/problems/four-divisors/description/) | 中等题，可以暴力，可以利用上面公式 |

## 3. 解题报告

  [四因数](https://leetcode.cn/problems/four-divisors/description/)

**题目描述**

> 给你一个整数数组 `nums`，请你返回该数组中恰有四个因数的这些整数的各因数之和。如果数组中不存在满足题意的整数，则返回 `0` 。

**解题思路1：**

【暴力枚举】

枚举数组中的每个数，计数每个数的因子个数，并累加因子，最后判断因子个数是否为 4 ，是则将累加因子的结果加入答案结果。

**Java代码**

```java
class Solution {
    public int sumFourDivisors(int[] nums) {
        int ans = 0;
        for (int num : nums) {
            int cnt = 2;
            int sum = 1 + num;
            for (int i = 2; i*i <= num; i++) {
                if (num % i == 0) {
                    cnt++;
                    sum += i;
                    if (i*i != num) {
                        cnt++;
                        sum += num/i;
                    }
                    if (cnt > 4)
                        break;
                }
            }
            if (cnt == 4) 
                ans += sum;
        }
        return ans;
    }
}
```

**解题思路2：**

【素数筛】

在题目数据给定范围内进行素数筛选，因为求因子和可以通过分解成素数积来计算。

根据上一节的求因数个数的公式（$g(n)=\prod _{i=1}^{k}(ai+1)$ ）可知，如果 $g(n)=4$ ，那么只有两种情况：

+ 整数 x 只有一个质因数，对应的指数为 3，此时：$g(n)=(3+1)=4$ 
+ 整数 x 有两个质因数，对应的指数都为 1，此时：$g(n)=(1+1)(1+1) = 4$ 

四因数 x 显然除了 1 和 x 本身外只有两个因数，设这两个因数分别为 p、q，且 p != q，那么 x 有两种表示

+ 某个素数的立方：x = p^3^  ：x 的因子	和为：$\frac{p^4-1}{p-1}=1+p+p^2+p^3$ 。（这里就相当于 q 是 p^2^ ）
+ 两个素数的乘积：x = pq ：x 的因子和为：$\frac{p^2-1}{p-1}\times \frac{q^2-1}{q-1}=(p+1)(q+1)$ 。
+ p 和 q 不是素数或者不是素数的次方的话，那么 p 和 q 都能再分解出其他因数出来，就不满足四个因子的条件了。

所以在素数内找出一个因子对，判断因子对是否满足以下情况，满足则是四因数

+ 两个因子都是素数或者一个因子是素数，一个因子是另一个因子的平方
+ 两个因子互不相同

**Java代码**

```java
class Solution {
    int[] f;
    int[] primes;  // （1）
    public int sumFourDivisors(int[] nums) {
        f = new int[100001];
        primes = new int[100001];
        eratosthenesPrime();
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = 1; j <= primes[0]; j++) {
                int p = primes[j];
                if (nums[i] % p == 0) {
                    int q = nums[i] / p;
                    if (isPrime(q) && p != q)  // （2）
                        ans += (p+1) * (q+1);
                    if (q == p*p)			   // （3）
                        ans += p*p*p + p*p + p + 1;
                    break;
                }
            }
        }
        return ans;
    }
    public boolean isPrime(int n) {
        return f[n] == 0;
    }
    public void eratosthenesPrime() {
        f[0] = f[1] = 1;
        primes[0] = 0;
        for (int i = 2; i < 100001; i++) {
            if (f[i] == 0) {
                primes[++primes[0]] = i;
                for (long j = (long)i*i; j < 100001; j += i) 
                    f[(int)j] = 1;
            }
        }
    }
}
```

（1）：primes 数组用来保存素数，primes[0] 是保存素数的个数

（2）：第一种情况

（3）：第二种情况

---

# 十三、最大公约数

## 1. 概念定义

**最大公因数**（highest common factor，hcf），也称**最大公约数**（greatest common divisor，gcd）、最大公因子，指两个或多个整数共有约数中最大的一个。

a，b的最大公约数记为 $(a,b)$ ，或者 $gcd(a,b)$ 。a，b，c的最大公约数记为 $(a,b,c)$ ，或者 $gcd(a,b,c)$ 。

特殊的，当 $gcd(a,b)=1$ ，称 $a$ 和 $b$ 互素。

根据算术基本定理，有以下公式：

​															$a={p_1}^{x1}{p_2}^{x2}{p_3}^{x3}...{p_k}^{xk}$

​															$b={p_1}^{y1}{p_2}^{y2}{p_3}^{y3}...{p_k}^{yk}$

那么 $gcd(a,b)$ 可以表示为：

​										$gcd(a,b)={p_1}^{min(x1,y1)}{p_2}^{min(x2,y2)}{p_3}^{min(x3,y3)}...{p_k}^{min(xk,yk)}$ 

注意：这里的 $a$ 和 $b$ 的分解式中的指数是可以为 0 的。

## 2. 求最大公约数的方法

### 1）朴素法

从大到小枚举 a 的约数，判断是否是 b 的约数，满足条件则就是 a，b 的最大公约数。

Java代码实现

```java
public int gcd(int a, int b) { 
    for (int i = a; i > 1; i--) {
        if (a % i == 0 && b % i == 0)
            return i;
    }
    return 1;
}
```

### 2）质因数分解法

把每个数分别分解质因数，再把各数中的全部**公有质因数**提取出来连乘，所得的积就是这几个数的最大公约数。

例如：求 24 和 60 的最大公约数，先分解质因数，得 24=2×2×2×3，60=2×2×3×5，24 与 60 的全部公有的质因数是 2、2、3，它们的积是 2×2×3=12，所以，gcd(24，60) =12。

Java代码实现

```java
public int gcd(int a, int b) {
    int[] arr1 = new int[a+1];  // （0）
	int[] arr2 = new int[b+1];  // （1）
    int ans = 1;
    decomposedPrimeFactor(arr1, a);
    decomposedPrimeFactor(arr2, b);
    // (2)
    int minLen = arr1.length > arr2.length ? arr2.length : arr1.length;
    for (int i = 2; i < minLen; i++) {
        // (3)
        int min = arr1[i] > arr2[i] ? arr2[i] : arr1[i];
        while (min != 0) {
            ans *= i;
            min--;
        }
    }
    return ans;
}
// 分解质因数
public void decomposedPrimeFactor(int[] primeFactors, int num) {
    for (int i = 2; i <= num; i++) {
        while (num != 0 && num % i == 0) {
            num /= i;
            primeFactors[i]++;
        }
    }
}
```

（0）：用两个数组保存对应数的质因数以及其个数。

（1）：a + 1 和 b + 1 表示可以存 a 和 b，防止 a，b 互素没有答案的情况

（2）：因为只需要累乘公有因子，所以只需要枚举因子数少的一个数组内的因子即可

（3）：同上，只需要累乘该因子在两个数之间出现的最少次数，即是共有的部分。



### 3）辗转相除法

辗转相除法也叫欧几里得算法。

每一个整数 a 都可以表示为 $a=kb+r$ ，其中 $k=[\frac{a}{b}]$ （a/b的向下取整），$r=$ $a$ $mod$ $b$，且 $0≤r<b$ 。假设 c 是 a，b 的公约数，即 a 和 b 都可以被 c 整除。根据 $r=a-kb$ 两边同时除以 $c$ 得 $ \frac{r}{c}=\frac{a}{c}-k\frac{b}{c}$ ，由等式右边可知，$\frac{r}{c}$ 是一个整数，所以 c 也是 r 和 b 的公约数，因此 $g(a,b)=g(b,a\%b)$ 。

特殊的，当 b = 0 时，$gcd(a,b)=a$ 。所以有：

![image-20230523135338489](https://gitee.com/LowProfile666/image-bed/raw/master/img/image-20230523135338489.png)

Java代码实现

```java
public int gcd(int a, int b) {
    if (b == 0)
        return a;
    return gcd(b, a%b);
}
```

## 3. 题目练习

| 序号 | 题目链接                                                     | 备注         |
| ---- | ------------------------------------------------------------ | ------------ |
| 1    | [找出数组的最大公约数](https://leetcode.cn/problems/find-greatest-common-divisor-of-array/description/) | 简单题       |
| 2    | [分式化简](https://leetcode-cn.com/problems/deep-dark-fraction/) | 简单题       |
| 3    | [比例简化](https://www.luogu.com.cn/problem/P2118)           | 洛谷普及题   |
| 4    | [(困难) 序列中不同最大公约数的数目](https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/) | 困难，不会做 |

## 4. 题解报告

[找出数组的最大公约数](https://leetcode.cn/problems/find-greatest-common-divisor-of-array/description/)

**题目描述**

> 给你一个整数数组 `nums` ，返回数组中最大数和最小数的 **最大公约数** 。
>
> 两个数的 **最大公约数** 是能够被两个数整除的最大正整数。

**解题思路**

找出最大最小值，计算最大公因数即可，使用辗转相除法。

**Java代码**

```java
class Solution {
    public int findGCD(int[] nums) {
        int max = nums[0];
        int min = nums[0];
        for (int i = 1; i < nums.length; i++) {
            if (max < nums[i])
                max = nums[i];
            if (min > nums[i])
                min = nums[i];
        }
        return gcd(max, min);
    }
    public int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a%b);
    }
}
```

[分式化简](https://leetcode-cn.com/problems/deep-dark-fraction/)

**题目描述**

> 有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？
>
> ![image-20230524084335416](https://gitee.com/LowProfile666/image-bed/raw/master/img/image-20230524084335416.png)
>
> 连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。
>
> 输入的`cont`代表连分数的系数（`cont[0]`代表上图的`a0`，以此类推）。返回一个长度为2的数组`[n, m]`，使得连分数的值等于`n / m`，且`n, m`最大公约数为1。

**解题思路**

从里层的分数开始计算，也就是从数组的右边开始。给分式通分，然后交换分子分母。

比如：`cont = {1,2,3}`，连分数就为：

​										<font size=5px>$1+\frac{1}{2+\frac{1}{3}}$  = $1+\frac{1}{\frac{2\times 3+1}{3}} $  = $1+\frac{3}{2\times 3+1}$ </font>

**Java代码**

```java
class Solution {
    public int[] fraction(int[] cont) {
        int[] ans = new int[2];
        // 分母
        int fm = cont[cont.length-1];
        // 分子
        int fz = 1;
        for (int i = cont.length-2; i >= 0; i--) {
            fz = (cont[i] * fm + fz);
            int t = fz;
            fz = fm;
            fm = t;
        }
        ans[0] = fm;
        ans[1] = fz;
        return ans;
    }
}
```

  [比例简化](https://www.luogu.com.cn/problem/P2118)

**题目描述**

> 在社交媒体上，经常会看到针对某一个观点同意与否的民意调查以及结果。例如，对某一观点表示支持的有 1498 人，反对的有 902 人，那么赞同与反对的比例可以简单的记为 1498:902。
>
> 不过，如果把调查结果就以这种方式呈现出来，大多数人肯定不会满意。因为这个比例的数值太大，难以一眼看出它们的关系。对于上面这个例子，如果把比例记为 5:3，虽然与真实结果有一定的误差，但依然能够较为准确地反映调查结果，同时也显得比较直观。
>
> 现给出支持人数 A，反对人数 B，以及一个上限 L，请你将 A 比 B 化简为 A′ 比 B′，要求在 A′ 和 B′ 均不大于 L 且 A′ 和 B′ 互质（两个整数的最大公约数是 1）的前提下，A′/B' ≥ A/B 且 A′/B' - A/B 的值尽可能小。

**解题思路**

可以直接枚举 [1, L] 内的两个数，判断两个数的公因数是否为 1，再判断两个数相除是否大于等于原来两个数相除，同时记录下最小的答案。

**Java代码**

```java
import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int a = sc.nextInt();
        int b = sc.nextInt();
        int l = sc.nextInt();
        int ansa = 100, ansb = 1;  // (1)
        for (int i = 1; i <= l; i++) {
            for (int j = 1; j <= l; j++) {
                if (gcd(i,j) == 1) {
                    if (i*b >= j*a) {
                        if (i*ansb < j*ansa) {
                            ansa = i;
                            ansb = j;
                        }
                    }   
                }
            }
        }
        System.out.println(ansa + " " + ansb);
    }
    public static int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a%b);
    }
}
```

（1）：这里的初始答案不能是 1 和 1，否则 1 和 1 就是最终结果

---

# 十四、最小公倍数

## 1. 概念定义

两个或多个整数共有的倍数叫做它们的**公倍数**（common multiple），其中除 0 以外最小的一个公倍数就叫做这几个整数的**最小公倍数**（least common multiple）。

整数 a，b 的最小公倍数记为 [a，b] ，或者记为 lcm(a,b) 。

整数 a，b，c的最小公倍数记为 [a，b，c] 或者 lcm(a,b,c) 。

**性质**

+ 如果两个数是倍数关系，则它们的最小公倍数就是较大的数；

+ 相邻的两个自然数的最小公倍数是它们的乘积。

最小公倍数和最大公因数的关系：最小公倍数 = 两数的乘积 / 最大公约（因）数：

​																		<font size=5px>$lcm(a,b)=\frac{ab}{gcd(a,b)}$ </font>

根据算术基本定理，有以下公式：

​															$a={p_1}^{x1}{p_2}^{x2}{p_3}^{x3}...{p_k}^{xk}$

​															$b={p_1}^{y1}{p_2}^{y2}{p_3}^{y3}...{p_k}^{yk}$

那么 $lcm(a,b)$ 可以表示为：

​										$lcm(a,b)={p_1}^{max(x1,y1)}{p_2}^{max(x2,y2)}{p_3}^{max(x3,y3)}...{p_k}^{max(xk,yk)}$ 

注意：这里的 $a$ 和 $b$ 的分解式中的指数是可以为 0 的。

那么联系到之前的最大公因数的表示为：

​										$gcd(a,b)={p_1}^{min(x1,y1)}{p_2}^{min(x2,y2)}{p_3}^{min(x3,y3)}...{p_k}^{min(xk,yk)}$ 

那么 $lcm(a,b) \times gcd(a,b)$ 就相当于等式右边的素因子的指数相加，即：

​										$min(xi,yi)+max(xi,yi)=xi+yi$ 

​										$lcm(a,b) \times gcd(a,b)={p_1}^{x1+y1}{p_2}^{x2+y2}{p_3}^{x3+y3}...{p_k}^{xk+yk}$ 

又因为：

​										$a \times b={p_1}^{x1+y1}{p_2}^{x2+y2}{p_3}^{x3+y3}...{p_k}^{xk+yk}$

所以有：

​										$lcm(a,b)\times gcd(a,b)=ab$

​										$lcm(a,b)=\frac{ab}{gcd(a,b)}$

## 2. 求最小公倍数的方法

### 1）分解质因数法

先把这几个数的质因数写出来，最小公倍数等于它们**所有的质因数的乘积**（如果有几个质因数相同，则比较两数中哪个数有该质因数的个数较多，乘较多的次数）。

比如求 45 和 30 的最小公倍数：45 = 3 \* 3 \* 5，30 = 2 \* 3 \* 5，lcm(45, 30) = 2 \* 3 \* 3 \* 5 = 90。

Java代码实现

```java
public int lcm(int a, int b) {
    int[] arr1 = new int[a+1];
    int[] arr2 = new int[b+1];
    int ret = 1;
    decomposedPrimeFactor(arr1, a);
    decomposedPrimeFactor(arr2, b);
    // (1)
    int minLen = arr1.length > arr2.length ? arr2.length : arr1.length;
    for (int i = 0; i < minLen; i++) {
        // (2)
        int max = arr1[i] > arr2[i] ? arr1[i] : arr2[i];
        while (max != 0) {
            ret *= i;
            max--;
        }
    }
    // （3）
    if (minLen == arr1.length) {
        for (int i = minLen; i < arr2.length; i++) {
            while (arr2[i] != 0) {
                ret *= i;
                arr2[i]--;
            }
        }
    }
    else {
        for (int i = minLen; i < arr1.length; i++) {
            while (arr1[i] != 0) {
                ret *= i;
                arr1[i]--;
            }
        }
    }
    return ret;
}
public void decomposedPrimeFactor(int[] primeFactors, int num) {
    for (int i = 2; i <= num; i++) {
        while (num != 0 && num % i == 0) {
            num /= i;
            primeFactors[i]++;
        }
    }
}
```

（1）：先枚举完因子数少的

（2）：找出这个因子出现的最大次数

（3）：再枚举因子数多的

### 2）公式法

公式即是最大公因数和最小公倍数之间的关系公式。所以要先算出最大公因数，而最大公因数代码最简单的就是辗转相除法。

Java代码

```java
public int gcd(int a, int b) {
	return b == 0 ? a : gcd(b, a%b);
}
public int lcm(int a, int b) {
    return (a*b) / gcd(a, b);
}
```

以上代码中的 lcm 方法可以换种写法：

```java
public int lcm(int a, int b) {
    return a / gcd(a, b) * b;
}
```

因为乘除法交换位置不影响结果，而且先除法再乘法可以避免数据过大溢出。

## 3. 题目练习

| 序号 | 题目链接                                                     | 备注           |
| ---- | ------------------------------------------------------------ | -------------- |
| 1    | [最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029) | 洛谷普及题     |
| 2    | [(困难) 序列中不同最大公约数的数目](https://leetcode-cn.com/problems/number-of-different-subsequences-gcds/) | 困难提，不会做 |

## 4. 题解报告

  [最大公约数和最小公倍数问题](https://www.luogu.com.cn/problem/P1029)

**题目描述**

> 输入两个正整数 x0, y0，求出满足下列条件的 P, Q 的个数：
>
> 1. P, Q 是正整数。
> 2. 要求 P, Q 以 x0 为最大公约数，以 y0 为最小公倍数。
>
> 试求：满足条件的所有可能的 P, Q  的个数。

**解题思路**

满足条件的数肯定是在 [x0, y0] 范围内的，所以在这个范围中枚举即可。枚举的同时判断最大公因数和最小公倍数是否是 x0 和 y0，是则满足条件。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        int y = sc.nextInt();
        int ans = 0;
        for (int i = x; i <= y; i++) {
            int j = x*y/i;
            if (gcd(i,j) == x && lcm(i,j) == y)
                ans++;
        }
        System.out.println(ans);
    }
    public static int gcd(int a, int b) {
        return b == 0? a : gcd(b, a%b);
    }
    public static int lcm(int a, int b) {
        return a / gcd(a,b) * b;
    }
}
```

---

# 十五、快速幂

## 1. 概念定义

**快速幂**，二进制取幂（Binary Exponentiation，也称平方法），是一个在 $O(logn)$ 的时间范围内计算 $a^n$ 的方法，基于分而治之的思想。

$a$ 的 $n$ 次方表示将 $n$ 个 $a$ 相乘： $a^n=a\times a\times a\times ...\times a(n个a)$  。

快速幂算法的核心思想就是每一步都把指数分成两半，而相应的底数做平方运算。这样不仅能把非常大的指数给不断变小，所需要执行的循环次数也变小，而最后表示的结果却一直不会变。

例如：$a^{11}=a\times a\times a\times ...\times a(11个a)$  

因为 11 的二进制是 (1011)~2~ ，又发现 $a^{11}$ 可以表示为：$a^{11} = a^8\times a^2\times a^1=a^{8+2+1}$ ，会发现 a 的指数其实是 11 的二进制表示中的每个 1 对应的位权之和。

再公式化一点，将 $a^n$ 中的 $n$ 写成二进制形式为 ：$(b_kb_{k-1}...b_2b_1b_0)_2$ ，那么 $n$ 就可以表示为：

​														 <font size=5px> $n=b_k2^k+b_{k-1}2^{k-1}+...+b_22^2+b_12^1+b_02^0(b_k为0或1)$ </font>

那么 $a^n$ 就可以表示为：

​													   <font size=5px> $a^n=a^{b_k2^k+b_{k-1}2^{k-1}+...+b_22^2+b_12^1+b_02^0}$</font>

​														 <font size=5px>$a^n = a^{b_k2^k}\times a^{b_{k-1}2^{k-1}}\times ...\times a^{b_12^1}\times a^{b_02^0}$ </font>

所以计算 $a^n$ 时，只要将==以 a 为底，以 n 的为 1 的二进制位的位权为指数的幂乘==起来就行。

## 2. 具体实现

用代码实现时有两种方式。

理解时只需要记住一个东西：当指数为偶数时，底数平方；当指数为奇数时，底数平方再多乘一个底数。

### 1）循环 + 位运算

判断指数的二进制位每一位是否为 1，是则乘以底数一次，否则不乘，同时不管当前位是否为 1 都要将底数平方扩大，因为判断二进制位是从低位到高位，位权在变大，所以底数也需要变大，而每次变大就是平方。

这里不理解的话根据代码带入示例理解更好一点。

Java代码

```java
public int binPow(int a, int n) {
    if(a == 1 || n == 0) return 1;
    int res = 1;
    while (n != 0) {
        if ((n&1) == 1)  //（1）	
            res *= a;  
        a *= a;
        n >>= 1;
    }
    return res;
}
```

（1）：这里既可以是判断是否为奇数，也可以是判断二进制位上是否为 1。

还可以换种写法。

Java代码

```java
public int binPow(int a, int n){
    if(a == 1 || n == 0) return 1;
    int res = 1;
    for(int i = n; i != 0; i /= 2){
        if(i % 2)
            res = res * a;
        a = a * a;
    }
    return res;
}
```

### 2）递归

本质是分治。

比如要求 $x^{64}$ ，我们可以按照：$x→x^2→x^4→x^8→x^{16}→x^{32}→x^{64}$ 的顺序，从 $x$ 开始，每次直接把上一次的结果进行平方，计算 6 次即可。

比如要求 $x^{77}$ ，我们可以按照：$x→x^2→x^4→x^9→x^{19}→x^{38}→x^{77}$ 的顺序，这些步骤中，有时直接将之前的结果平方，有时又要将之前的结果平方再乘个 x 。

当把以上顺序从右往左看时，

+ 当我们计算 $x^n$ 时，可以先递归计算出 $x^{[n/2]}$ ，$[n/2]$ 是对 $n/2$ 向下取整。
+ 如果 $n$ 是偶数，那么只需要将前一个结果平方即可。
+ 如果 $n$ 是奇数，那么将前一个结果平方后，还要再乘一个 x。

Java代码

```java
public int binPow(int a, int n) {
    if (n == 0)	return 1;
    int res = binPow(a*a, n/2);
    if (n % 2 != 0)
        return res * a;
    return res;
}
```

也可以换种写法。

Java代码

```java
public int binPow(int a, int n) {
    if (n == 0)	return 1;
    int res = binPow(a, n/2);
    if (n % 2 != 0)
        return res * res * a;
    return res * res;
}
```

## 2. 题目练习

| 序号 | 题目链接                                                     | 备注                               |
| ---- | ------------------------------------------------------------ | ---------------------------------- |
| 1    | [ Pow(x, n)](https://leetcode.cn/problems/powx-n/description/) | 中等题                             |
| 2    | [超级次方](https://leetcode.cn/problems/super-pow/description/) | 中等退                             |
| 3    | [整数拆分](https://leetcode.cn/problems/integer-break/description/) | 中等题，感觉是动态规划的题目，没做 |
| 4    | [数组元素的最小非零乘积](https://leetcode.cn/problems/minimum-non-zero-product-of-the-array-elements/description/) | 中等题，贪心 + 快速幂，没做        |
| 5    | [好因子的最大数目](https://leetcode.cn/problems/maximize-number-of-nice-divisors/) | 困难题，不会做。。。               |

## 3. 题解报告

[Pow(x, n)](https://leetcode.cn/problems/powx-n/description/)

**题目描述**

> 实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，x^n^ ）。

**解题思路**

直接使用快速幂的方法，但是需要注意的时，n 都可能为负数，当 n 为负数时，$x^n=\frac{1}{x^{-n}}$ 。

**Java代码**

使用递归的方式：

```java
class Solution {
    public double myPow(double x, int n) {
        if (n < 0)
            return 1 / binPow(x, -n);
        return binPow(x, n);
    }
    public double binPow(double x, int n) {
        if (n == 0)
            return 1.0;
        double res = binPow(x*x, n/2);
        if (n % 2 != 0)
            return res * x;
        return res;
    }
}
```

使用迭代的方式：

```java
class Solution {
    public double myPow(double x, int n) {
        if (n == 0 || x == 1) return 1;
        if (x == 0 || n == 0) return x;
        double ans = 1.0;
        for (int i = n; i != 0; i /= 2) {
            if (i % 2 != 0)
                ans *= x;
            x *= x;
        }
        return n < 0 ? 1 / ans : ans;
    }
} 
```

[超级次方](https://leetcode.cn/problems/super-pow/description/)

**题目描述**

> 你的任务是计算 a^b^  对 `1337` 取模，`a` 是一个正整数，`b` 是一个非常大的正整数且会以数组形式给出。

**解题思路**

使用快速幂，指数 b 是以数组形式给出的。

假设数组 b 为 [2, 1, 2] ，那么 n 应该为 212：

​																		 $n=2\times 100+1\times 10+2\times1$ 

但是数组 b 的长度很大，这样转换成数字肯定会溢出，所以要换种方法，在上面这个例子中，我们发现

​																	 $ a^n = a^{b[0]\times100} + a^{b[1]\times10} + a^{b[2]\times 1 } $ 

那我们可以用一个变量存下第一个元素 $a^{b[0]}$ ，然后每次扩大 10 次方倍，再加上后面的数。

Java代码

```java
class Solution {
    int mod = 1337;
    public int superPow(int a, int[] b) {
        if (a == 1) return 1;
        long ans = 1;
        for (int i = 0; i < b.length; i++) {
            ans = myPow(ans, 10) * myPow(a, b[i]) % mod;
        }
        return (int)ans;
    }
    public long myPow(long a, int n) {
        if (n == 0 || a == 1) return 1;
        long res = 1;
        while (n != 0) {
            if ((n&1) == 1)
                res = res * a % mod;
            a = a * a % mod;
            n >>= 1;
        }
        return res;
    }
}
```

这道题题解感觉没有写清楚，暂时就这样吧。

---

# 十六、交换变量

## 1. 概念定义

将两个变量当作两个盒子，数据就是盒子里面的东西，交换变量就是交换它们之间的数据，就是将两个盒子中的东西互换。

如以下代码

```java
int a = 1;
int b = 2;
```

a，b 都是盒子，1，2 分别是盒子中的东西，交换后，a 里面是 2，b 里面是 1。

## 2. 具体实现

### 1）第三方变量

联系我们的日常生活，要想交换两个盒子里的东西，一般有三个步骤：

+ 先将 a 盒子里的东西拿出来放好，可以放在一个临时的 c 盒子中，
+ 再将 b 盒子里的东西拿出来放进 a 盒子，
+ 再将 c 盒子中的东西放进 b 盒子

这个 c 盒子就是第三方变量，所以用代码实现如下：

C语言代码

```c
void swap(int* a, int* b) {  // (1)
    int c = *a;  // (2)
    *a = *b;
    *b = c;
}
```

（1）：这里使用地址传递的方式，真正交换 a，b 的值

（2）：c 就是那个临时变量

### 2）加减法

这个方法很巧妙啊。直接通过代码来理解。

C语言代码

```c
void swap(int* a, int* b) {
    *a = *a + *b;  //（1）
    *b = *a - *b;  //（2）
    *a = *a - *b;  //（3）
}
```

（1）：此时的 a 就是 a+b

（2）：此时的 b 就是 (a+b)-b，b 的值就变成了 a

（3）：此时的 a 就是 (a+b)-a，a 的值就变成了 b

### 3）位运算

这个方法更加巧妙啊。

该方法会用到位运算符异或（\^），它的运算规则是：==相同为 0，相异为 1，0 异或任何数都为任何数本身==。

还是直接通过代码理解。

C语言代码

```c
void swap(int* a, int* b) {
    *a ^= *b;  // (1)
    *b ^= *a;  // (2)
    *a ^= *b;  // (3)
}
```

（1）：此时的 a 是 a \^ b

（2）：此时的 b 是 b \^ (a \^ b)，b \^ b = 0，0 \^ a = a，b 的值就变成了 a

（3）：此时的 a 是 (a \^ b) ^ a，a \^ a = 0，0 \^ b = b，a 的值就变成了 b

## 3. 题目练习

| 序号 | 题目链接                                                     | 备注 |
| ---- | ------------------------------------------------------------ | ---- |
| 1    | [交换数字](https://leetcode.cn/problems/swap-numbers-lcci/description/) |      |
| 2    | [配对交换](https://leetcode.cn/problems/exchange-lcci/description/) |      |

## 4. 题解报告

  [配对交换](https://leetcode.cn/problems/exchange-lcci/description/)

**题目描述**

> 配对交换。编写程序，交换某个整数的奇数位和偶数位，尽量使用较少的指令（也就是说，位0与位1交换，位2与位3交换，以此类推）。

**解题思路1**

【暴力】

使用数组保存下指定数的二进制位，然后两位两位进行交换，最后再转为十进制数即可。

**Java代码**

```java
class Solution {
    public int exchangeBits(int num) {
        int[] b = new int[32];
        int top = 0;
        for (int i = 0; i < 32; i++) {
            b[i] = num & 1;
            num >>= 1;
        }
        for (int i = 0, j = 1; j < 32; i+=2, j+=2) {
            int t = b[i];
            b[i] = b[j];
            b[j] = t;
        }
        int t = 1;
        int ans = 0;
        for (int i = 0; i < 32; i++) {
            ans += b[i] * t;
            t *= 2;
        }
        return ans;
    }
}
```

**解题思路2**

【牛逼位运算】

二进位上都是 0 和 1，我们可以把数的奇数位置和偶数位置上的 0 或 1 分别保存下来，然后奇数位置的数往左移动一位，偶数位置的数往右移动一位，最后两部分执行或操作即可。

+ 保留偶数位：与 0xaaaaaaaa（偶数位全为 1）进行 与 操作
+ 保留奇数位：与 0x55555555（奇数位全为 1）进行 与 操作

为什么执行或操作呢，因为或操作的规则是：==有1为1，全0为0==。

比如：14 = 0b1110，保留它的偶数位：1010，右移一位为 0101，奇数位：0100，左移一位为 1000，两部分执行或操作：0101 | 1000 = 1101，正是 1110 相邻两位交换后的结果。

**Java代码**

```java
class Solution {
    public int exchangeBits(int num) {
        return (num & 0xaaaaaaaa) >> 1 | (num & 0x55555555) << 1; 
    }
}
```

---

# 十七、最值算法

## 1. 概念定义

是求出两个数或多个数间最大/最小值的方法。

## 2. 具体实现

### 1）两个数的最值

两个数比较大小是最基本的东西，使用 if 语句或者 条件运算符（ ? : ）都可以实现比较两个数的大小，求得最值。

Java代码

```java
public int max(int a, int b) {
    if (a > b)
        return a;
    return b;
}
public int min(int a, int b) {
    return a < b ? a : b;
}
```

### 2）多个数的最值

求多个数的最值的方法基于上面求两个数的最值的方法，先求出两个数的最值，然后用这个最值再和其他数一一比较，求出每次比较的最值，最后一次比较的最值就是答案。

比如有 n 个数 a~0~，a~1~，a~2~，....，a~n~ 时，要求它们的最小值 min，那么先求出前两个数 a~0~，a~1~ 的最小值 m~1~，再用 m~1~ 和第三个数 a~2~ 进行比较求出最小值 m~2~，再用 m~2~ 和第四个数 a~3~ 进行比较求出最小值 m~3~，以此类推，最后就可以求出这个 n 个数的最小值。

用公式表示：

![image-20230527134651205](https://gitee.com/LowProfile666/image-bed/raw/master/img/image-20230527134651205.png)

## 3. 题目练习

| 序号 | 题目链接                                                     | 备注        |
| ---- | ------------------------------------------------------------ | ----------- |
| 1    | [最大连续 1 的个数](https://leetcode.cn/problems/max-consecutive-ones/description/) |             |
| 2    | [数组中两元素的最大乘积](https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/description/) | 可用排序    |
| 3    | [寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/) | 可用二分    |
| 4    | [寻找旋转排序数组中的最小值 II](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array-ii/description/) | 可用二分法· |
| 5    | [第三大的数](https://leetcode.cn/problems/third-maximum-number/description/) | 可用排序    |
| 6    | [三个数的最大乘积](https://leetcode.cn/problems/maximum-product-of-three-numbers/description/) | 可用排序    |

## 4. 题解报告

[最大连续 1 的个数](https://leetcode.cn/problems/max-consecutive-ones/description/)

**题目描述**

> 给定一个二进制数组 `nums` ， 计算其中最大连续 `1` 的个数。

**解题思路**

使用计数法和比较大小。计数每一段连续 1 的个数，然后和最大的个数进行比较。

**Java代码**

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int ans = 0;
        int cnt = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == 1)
                cnt++;
            else 
                cnt = 0;
            ans = max(ans, cnt);
        }
        return ans;
    }
    public int max(int a, int b) {
        return a > b ? a : b;
    }
}
```

[数组中两元素的最大乘积](https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/description/)

**题目描述**

> 给你一个整数数组 `nums`，请你选择数组的两个不同下标 `i` 和 `j`*，*使 `(nums[i]-1)*(nums[j]-1)` 取得最大值。
>
> 请你计算并返回该式的最大值。

**解题思路**

通过比较大小求出数组里最大的两个数。

**Java代码**

```java
class Solution {
    public int maxProduct(int[] nums) {
        int max1 = nums[0];
        int max2 = 0;
        for (int i = 1; i < nums.length; i++) {
            if (max1 < nums[i]) {
                max2 = max1;
                max1 = nums[i];
            } else if (max2 < nums[i])
                max2 = nums[i];
        }
        return (max1-1) * (max2-1);
    }
}
```

[寻找旋转排序数组中的最小值](https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/)

**题目描述**

> 已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：
>
> - 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
> - 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`
>
> 注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。
>
> 给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。
>
> 你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

**解题思路**

就是找数组中的最小值即可，最简单的方法就是遍历数组比较，时间复杂度是 O(n) ，但是也能过。O(log n) 的算法要用二分法。

**Java代码**

```java
class Solution {
    public int findMin(int[] nums) {
        int min = nums[0];
        for (int i = 1; i < nums.length; i++)
            min = Min(min, nums[i]);
        return min;
    }
    public int Min(int a, int b) {
        return a > b ? b : a;
    }
}
```

---

# 十八、统计法（入门）

> 简单的统计法其实就是之前学的计数法。

## 1. 概念定义

**统计法**，顾名思义是在给定的范围内统计出符合设定条件的记录个数。

**基本思想：**用一个条件语句判断当前记录是否符合给定条件，符合则统计个数加一。用循环实现对所有记录的操作。

和计数法和类似，但是又比计数法更加高级。这就需要实际做题中体会了。

## 2. 题目练习

| 序号 | 题目链接                                                     | 备注                             |
| ---- | ------------------------------------------------------------ | -------------------------------- |
| 1    | [存在连续三个奇数的数组](https://leetcode.cn/problems/three-consecutive-odds/description/) |                                  |
| 2    | [统计位数为偶数的数字](https://leetcode.cn/problems/find-numbers-with-even-number-of-digits/description/) |                                  |
| 3    | [有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/description/) | 可用二分                         |
| 4    | [调整数组顺序使奇数位于偶数前面](https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/description/) | 可用双指针                       |
| 5    | [找到数组的中间位置](https://leetcode.cn/problems/find-the-middle-index-in-array/description/) |                                  |
| 6    | [寻找数组的中心下标](https://leetcode-cn.com/problems/find-pivot-index/) |                                  |
|      | [删除有序数组中的重复项](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/) |                                  |
|      | [ 可被 5 整除的二进制前缀](https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/) | 注意溢出问题，防止溢出可以 mod 5 |
|      | [可被 K 整除的最小整数](https://leetcode-cn.com/problems/smallest-integer-divisible-by-k/) |                                  |
|      | [哪种连续子字符串更长](https://leetcode-cn.com/problems/longer-contiguous-segments-of-ones-than-zeros/) |                                  |
|      | [猜数字](https://leetcode-cn.com/problems/guess-numbers/)    |                                  |
|      | [行车管理系统](https://leetcode-cn.com/problems/design-parking-system) |                                  |

## 3. 解题报告

> 该类题目解法差不多，就不都写了。

[存在连续三个奇数的数组](https://leetcode.cn/problems/three-consecutive-odds/description/)

**题目描述**

> 给你一个整数数组 `arr`，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 `true` ；否则，返回 `false` 。

**解题思路**

用一个计数器，初始为 0，遍历数组，碰到奇数则计数加一，碰到偶数则赋值为 0，如果计数器加到了 3 ，则返回。

**Java代码**

```java
class Solution {
    public boolean threeConsecutiveOdds(int[] arr) {
        int cnt = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] % 2 != 0)
                cnt++;
            else
                cnt = 0;
            if (cnt == 3)
                return true;
        }
        return false;
    }
}
```

  [统计位数为偶数的数字](https://leetcode.cn/problems/find-numbers-with-even-number-of-digits/description/)

**题目描述**

> 给你一个整数数组 `nums`，请你返回其中位数为 **偶数** 的数字的个数。

**解题思路**

使用计数器记下位数为偶数的数字的个数。判断位数是否为偶数时，可以直接使用 if 语句判读，也可以使用另一个计数器来计数。

**Java代码**

```java
class Solution {
    public int findNumbers(int[] nums) {
        int ans = 0;
        for (int i = 0; i < nums.length; i++) {
            if (count(nums[i]) % 2 == 0)
                ans++;
        }
        return ans;
    }
    public int count(int num) {
        int res = 0;
        while (num != 0) {
            res++;
            num /= 10;
        }
        return res;
    }
}
```

---

# 十九、进制转换（入门）

## 1. 概念定义

**进制转换**是人们利用符号来计数的方法。进制转换由一组数码符号和两个基本元素（基数和位权）构成。

我们日常中使用最多的就是十进制。

比如十进制数 1234，表示 $1\times1000+2\times100+3\times10+4\times1$ 。从右往左给 1234 每位数字的位置编号为 i = 0，1，2，3 ，每位的数字表示为 d~i~ ，d~i~ 就是基数；每个位置都反映了一个权值，就是位权，比如十位表示 10，百位表示 100。

### 0）分解各位数字

> 在了解进制转换之前，先学习下如何分解一个数的各位数字。

一般在进行进制转换前，要先将数字的每一位数字提取出来。以十进制数为例，这也是平常最常见的。

十进制数 1234，通过模 10 可以得到数字 4，再通过除以 10 可以得到除了 4 的其他数字（123）；再将 123 通过模 10 得到 3，再除以 10 得到 12，以此类推，最后 1234 变成了 0 ，这时每位数字就提取完毕。

Java代码

```java
public void splitNumber(int[] nums, int num) {  // (1)
    int top = 0;
    while (num != 0) {
        nums[top++] = num % 10;
        num /= 10;
    }
}
```

（1）：nums 数组是用来存放数字 num  的每位数字的。

### 1）X进制 转 十进制

X进制转为十进制后的值是：==每一位上的 数字和它的位权之积 的累加和==。

假设X进制的数从右往左给每一位编号为 i，每一位数字表示为 d~i~ ，每一位的位权表示为 w~i~ ，那么X进制转为十进制的表示为：

​																								$\sum_{i=0}^nd_iw_i$ 。

比如：十六进制数 0x123 = $1\times16^2+2\times16^1+3\times16^0=291$

比如：八进制数 0123 = $1\times8^2+2\times8^1+3\times8^0=83$

比如：二进制数 0b110 = $1\times2^2+1\times2^1+0\times2^0=6$

### 2）十进制 转 X进制

十进制转为X进制后的值是：==倒序取原数模 X 的结果，原数每次要除以 X ，直到原数为 0==。

因为任意一个 X 进制的数都可以表示为：$d_nX^n+...+d_2X^2+d_1X^1+d_0X^0$ ，所以每次除以一个 X 可以得到一个余数，就是最低位上的数字。

比如：十进制数 291 转为十六进制数：

```
291 除 16  ========== 余 3
18 除 16  =========== 余 2
1 除 16  ============ 余 1
```

比如：十进制数 83 转为八进制数：

```
83 除 8 ============ 余 3
10 除 8 ============ 余 2
1 除 8 ============= 余 1
```

比如：十进制数 6 转为二进制数：

```
6 除 2 ============= 余 0
3 除 2 ============= 余 1
1 除 2 ============= 余 1
```

### 3）二进制 转 八进制

二进制转八进制后的结果是：==3 位二进制数转为 1 位八进制数==。

比如：二进制数 11101 转为八进制数：

```
11101   
  ==> 11 101  
  ==> 011 101 
  ==> (35)8
```

### 4）八进制 转 二进制

八进制二进制后的结果是：==1 位八进制数转为 3 位二进制数==。

比如：八进制数 35 转为二进制数：

```
35
  ==> 3   5
  ==> 011 101
  ==> 011101
```

### 5）二进制 转 十六进制

二进制转十六进制后的结果是：==4 位二进制数转为 1 位十六进制数==。

比如：二进制数 110111 转为十六进制数：

```
110111
  ==> 11  0111
  ==> 3   7
  ==> 37
```

### 6）十六进制 转 二进制

十六进制转为二进制后的结果是：==1 位十六进制转为 4 位二进制==。

比如：十六进制数 37 转为二进制数：

```
37
  ==> 3    7
  ==> 0011 0111
  ==> 110111
```

## 2. 题目练习

| 序号 | 题目链接                                                     | 备注                 |
| ---- | ------------------------------------------------------------ | -------------------- |
|      | [二进制中1的个数](https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/) | 位运算、统计法       |
|      | [ 各位相加](https://leetcode-cn.com/problems/add-digits/)    | 分解各位数字         |
|      | [ 二进制链表转整数](https://leetcode-cn.com/problems/convert-binary-number-in-a-linked-list-to-integer/) | 二进制转十进制       |
|      | [K 进制表示下的各位数字总和](https://leetcode-cn.com/problems/sum-of-digits-in-base-k/) | 十进制转k进制        |
|      | [ 统计最大组的数目](https://leetcode-cn.com/problems/count-largest-group/) | 分解各位数字、统计法 |
|      | [ 七进制数](https://leetcode-cn.com/problems/base-7/)        | 十进制转七进制       |
|      | [ 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/) | 十进制转十六进制     |

## 3. 题解报告

[ 七进制数](https://leetcode-cn.com/problems/base-7/)

**题目描述**

> 给定一个整数 `num`，将其转化为 **7 进制**，并以字符串形式输出。

**解题思路**

num 一直模 7，保存结果，直到 num 等于 0 结束，此时保存的结果顺序是从低位到高位，所以需要将顺序逆转。

**Java代码**

```java
class Solution {
    public String convertToBase7(int num) {
        if (num == 0)
            return "0";
        int[] s = new int[10];
        String res = "";
        if (num < 0) {  // (1)
            res += '-';
            num *= -1;
        }
        int top = 0;
        while (num != 0) {
            s[top++] = (num % 7);
            num /= 7;
        }
        for (int i = 0, j = top-1; i < j; i++, j--) {
            int t = s[i];
            s[i] = s[j];
            s[j] = t;
        }
        for (int i = 0; i < top; i++) {
            res += s[i];
        }
        return res;
    }
}
```

（1）：是负数的话将负号保存下来，然后变成正数计算。

[ 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)

**题目描述**

> 给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 补码运算 方法。
>
> **注意:**
>
> 1. 十六进制中所有字母(`a-f`)都必须是小写。
> 2. 十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符`'0'`来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 
> 3. 给定的数确保在32位有符号整数范围内。
> 4. **不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。**

**解题思路**

4 位二进制转为 1 位十六进制，所以一共需要 8 位十六进制数来表示 32 位的整数。为了不再颠倒顺序，我们可以先计算出整数的高 4 位的和，并转成十六进制，然后再计算下一个 4 位。

为了能先计算高位，我们移动的位数可以用 4 的倍数来控制，要想得到最高的 4 位，那么就需要右移 4\*7 位，然后 &15 就可以得到这最高 4 位。

15 的二进制表示为：1111 。

**Java代码**

```java
class Solution {
    public String toHex(int num) {
        if (num == 0)
            return "0";
        char[] hex = "0123456789abcdef".toCharArray();
        String res = "";
        for (int i = 7; i >= 0; i--) {
            int t = (num >> 4*i) & 15;
            if (res.equals("") && t == 0)
                continue;
            res += hex[t];
        }
        
        return res;
    }
}
```

---

# 二十、进制转换（进阶）

## 1. 概念定义

除了上一节里提到的常用进制（二进制、八进制、十六进制）相互转换，平时还有一些不常用的进制。

比如 26 进制，Excel 表格的列号就是使用的 26 进制，使用 ABC 大写字母来表示的。

## 2. 题目练习

| 序号 | 题目链接                                                     | 备注         |
| ---- | ------------------------------------------------------------ | ------------ |
|      | [快乐数](https://leetcode-cn.com/problems/happy-number/)     |              |
|      | [ Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/) |              |
|      | [ Excel 表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/) |              |
|      | [ 最小好进制](https://leetcode-cn.com/problems/smallest-good-base/) | 困难题，数学 |

## 3. 题解报告

[Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)

**题目描述**

> 给你一个整数 `columnNumber` ，返回它在 Excel 表中相对应的列名称。
>
> 例如：
>
> ```
> A -> 1
> B -> 2
> C -> 3
> ...
> Z -> 26
> AA -> 27
> AB -> 28 
> ...
> ```

**解题思路**

10 进制转换为 26 进制，且用大写字母表示。用整数模 26 拿到余数，再除以 26，每次保存下余数的英文表示，最后按逆序把保存的余数连接在一起即可。

这里的 26 进制是从 1 开始的，没有 0 这个数。一般性的进制转换题目无须进行额外操作，是因为我们是在「每一位数值范围在 [0,x)」的前提下进行「逢 *x* 进一」。

但本题需要我们将从 1 开始，因此在执行「进制转换」操作前，我们需要先对 columnNumber 执行减一操作，从而实现整体偏移。

[LeetCode题解](https://leetcode.cn/problems/excel-sheet-column-title/solutions/849680/gong-shui-san-xie-cong-1-kai-shi-de-26-j-g2ur/) 

**Java代码**

```java
class Solution {
    public String convertToTitle(int columnNumber) {
        List<Character> temp = new ArrayList<>();
        while (columnNumber != 0) {
            --columnNumber;
            char c = (char)('A' + columnNumber%26);
            temp.add(c);
            columnNumber /= 26;
        }
        String res = "";
        for (int i = temp.size()-1; i >= 0; i--) {
            res += temp.get(i);
        }
        return res;
    }
}
```

---

# 二十一、字符串算法——字符串遍历

## 1. 概念定义

**遍历字符串**就是访问字符串中的每一个字符。

C 语言里的字符串就是字符数组。而 Java 中有字符串类型：String，关于字符串的很多方法 Java 中都已经封装好了，直接调用很方便。但是为了理解每个方法的作用与原理，所以不能依赖已封装好的方法，自己也要会实现。

### **1）具体实现**

#### **a）遍历字符串**

在 Java 中遍历字符串时，直接遍历字符串对象是这样的：

```java
String s = "HelloWorld";
for (int i = 0; i < s.length(); i++) {
    System.out.println(s.charAt(i));
}
```

在以上遍历过程中会一直调用 length() 和 charAt() 方法。

而我一般习惯将 字符串 转成 字符数组 来操作，因为有下标操作起来更简单快捷：

```java
char[] arr = s.toCharArray();
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
```

#### 2）大小写转换

在 ASCII 码里，大写英文字母和小写英文字母之间的差值是 32 ，所以，只需要加减 32 就可以实现大小字母转换。

```java
char[] arr = s.toCharArray();
for (int i = 0; i < arr.length; i++) {
    if (arr[i] >= 'A' && arr[i] <= 'Z')
        arr[i] += 32;
    if (arr[i] >= 'a' && arr[i] <= 'z')
        arr[i] -= 32;
}
```

除了加减 32 的方法外，还有个异或 32 的方法：

```java
char[] arr = s.toCharArray();
for (int i = 0; i < arr.length; i++) {
    arr[i] ^= 32;
}
```

我们对照 ASCII 码表来看，会发现大写字母和小写字母的二进制表示之间，只有一位不同，就是第 6 位

+ 大写字母的第 6 位二进制是 0
+ 小写字母的第 6 位二进制是 1

所以我们可以通过改变第 6 位二进制来实现大小写字母的转换。联想到异或操作的规则：==相同为 1，不同为 0==，所以在第 6 位二进制位上进行异或 1 的操作话，就可以实现大小写字母间的转换。

1 个字节里的第 6 位是 1 ，那么表示的数就是 32（0b00100000），所以用字符异或 32 就可以完成大小写转换。

比如：

```
a  : 01100001
32 : 00100000
A  : 01000001

a ^= 32 ==> 01000001 ==> A
A ^= 32 ==> 01100001 ==>
```

![img](https://gitee.com/LowProfile666/image-bed/raw/master/img/e850352ac65c103880a07b53bc119313b17e8941)



## 2. 题目练习

| 序号 | 题目链接                                                     | 备注                     |
| ---- | ------------------------------------------------------------ | ------------------------ |
| 1    | [判断国际象棋棋盘中一个格子的颜色](https://leetcode-cn.com/problems/determine-color-of-a-chessboard-square/) | 遍历                     |
| 2    | [速算机器人](https://leetcode-cn.com/problems/nGK0Fy/)       | 遍历，可以用数学         |
| 3    | [ 执行操作后的变量值](https://leetcode-cn.com/problems/final-value-of-variable-after-performing-operations/) | 遍历、判断字符           |
| 4    | [长度为三且各字符不同的子字符串](https://leetcode-cn.com/problems/substrings-of-size-three-with-distinct-characters/) | 遍历                     |
| 5    | [检测大写字母](https://leetcode-cn.com/problems/detect-capital/) | 遍历、判断大小写         |
| 6    | [转换成小写字母](https://leetcode-cn.com/problems/to-lower-case/) | 遍历、大写转小写         |
| 7    | [判断字符串的两半是否相似](https://leetcode-cn.com/problems/determine-if-string-halves-are-alike/) | 遍历、判断是否包含       |
| 8    | [将所有数字用字符替换](https://leetcode-cn.com/problems/replace-all-digits-with-characters/) | 遍历                     |
| 9    | [字符串中不同整数的数目](https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/) | 遍历、判断字符是否是数字 |

## 3. 题解报告

---

[字符串中不同整数的数目](https://leetcode-cn.com/problems/number-of-different-integers-in-a-string/)

**题目描述**

> 给你一个字符串 `word` ，该字符串由数字和小写英文字母组成。
>
> 请你用空格替换每个不是数字的字符。例如，`"a123bc34d8ef34"` 将会变成 `" 123 34 8 34"` 。注意，剩下的这些整数为（相邻彼此至少有一个空格隔开）：`"123"`、`"34"`、`"8"` 和 `"34"` 。
>
> 返回对 `word` 完成替换后形成的 **不同** 整数的数目。
>
> 只有当两个整数的 **不含前导零** 的十进制表示不同， 才认为这两个整数也不同。

**解题思路**

这题本意是返回字符中不同数字的个数，每个数字是由字符隔开的，所以其实不用将字符替换为空格。

遍历字符串，用一个 List 集合来保存数字。当遍历到数字时，先去除前导零，将其余数字连接起来形成一个字符串，先判断 List 集合里是否有该字符串，没有则加入字符串，最后返回 List 集合的长度就是不同的数字个数。

**Java代码**

```java
class Solution {
    public int numDifferentIntegers(String word) {
        List<String> cnt = new ArrayList<>();
        char[] s = word.toCharArray();
        int i = 0;
        while (i < s.length) {
            if (s[i] < '0' || s[i] > '9') {
                i++;
                continue;
            }
            String temp = "";
            while (i < s.length && s[i] == '0')   i++;
            while (i < s.length && s[i] >= '0' && s[i] <= '9')
                temp += s[i++];
            if (cnt.contains(temp) == false) {
                cnt.add(temp);
            }
        }
        return cnt.size();
    }
}
```

---

# 二十二、字符串算法——字符串比较

## 1. 概念定义

两个字符串进行比较，比较的是字符串中每个字符的大小。两个字符串的大小取决于首个不同的字符的大小，这个大小是字符的字典顺序先后，或者说是字符的 Unicode 值的大小。

Java 中有个方法：

```java
public int compareTo(String anotherString)
```

该方法的返回值是一个整数，一般就是首个不同字符之间的差值

+ 0 ：str1 和 str2 相等
+ 大于 0 ：str1 大于 str2
+ 小于 0 ：str1 小于 str2

使用这个方法：

```java
String str1 = "abcdef";
String str2 = "abccde";
str1.compareTo(str2);
```

这个方法的比较原理：

```
str1 : "abcdef"
str2 : "abccde"
str1    str2
 'a' == 'a' 
 'b' == 'b'
 'c' == 'c'
 'd' >  'c'
```

str1 和 str2 从头开始，比较每一个字符，当 str 1 和 str2 比较到首个不相同的字符时，不再往下比较，方法结束。此时方法的返回值就是：

```java
str1.charAt(k) - str2.charAt(k)
```

所以以上代码的结果是一个正整数，因为 `'d'` 在字典中位于 `'c'` 的后面，所以 str1 比 str2 大，结果为一个正整数，这个正整数是 1 ，为 `'d'` 和 `'c'` 之间的差值。

但是以上的例子中，两个字符串的长度一样且有不同的字符，如果比较两个字符串大小时，长度不一样且没有不一样的字符时，结果又怎么确定？

如果不存在不同的字符，那么较短的字符串按字典顺序位于较长的字符串前，此时方法的返回值就是：

```java
str1.length() - str2.length()
```

比如：

```java
String str1 = "abcdef";
String str2 = "abcd";
str1.compareTo(str2);
```

这种情况下，在还没有找到不同字符的时候，str2 就已经没了，那么结果就是一个正整数。	

## 2. 题目练习

| 序号 | 题目链接                                                     | 备注           |
| ---- | ------------------------------------------------------------ | -------------- |
| 1    | [替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/) | 连接字符串     |
| 2    | [稀疏数组搜索](https://leetcode-cn.com/problems/sparse-array-search-lcci/) | 比较           |
| 3    | [美好字符串](https://leetcode-cn.com/problems/longest-nice-substring/) | 比较，暴力     |
| 4    | [ 单词规律](https://leetcode-cn.com/problems/word-pattern/)  | 比较           |
| 5    | [解码字母到整数映射](https://leetcode-cn.com/problems/decrypt-string-from-alphabet-to-integer-mapping/) | 截取子串、连接 |
| 6    | [作为子字符串出现在单词中的字符串数目](https://leetcode-cn.com/problems/number-of-strings-that-appear-as-substrings-in-word/) | 判断是否是子串 |
| 7    | [统计匹配检索规则的物品数量](https://leetcode-cn.com/problems/count-items-matching-a-rule/) | 比较           |

## 3. 题解报告

---

[美好字符串](https://leetcode-cn.com/problems/longest-nice-substring/)

**题目描述**

> 当一个字符串 `s` 包含的每一种字母的大写和小写形式 **同时** 出现在 `s` 中，就称这个字符串 `s` 是 **美好** 字符串。比方说，`"abABB"` 是美好字符串，因为 `'A'` 和 `'a'` 同时出现了，且 `'B'` 和 `'b'` 也同时出现了。然而，`"abA"` 不是美好字符串因为 `'b'` 出现了，而 `'B'` 没有出现。
>
> 给你一个字符串 `s` ，请你返回 `s` 最长的 **美好子字符串** 。如果有多个答案，请你返回 **最早** 出现的一个。如果不存在美好子字符串，请你返回一个空字符串。

**解题思路**

数据不大，暴力求解。

枚举左端点，枚举右端点，记录下最大美好字符串的长度，用两个计数数组来记录出现的大小写字符，最后比较两个数组里的相同字符是否都出现过，是则为美好字符串，否则不是。

代码中枚举右端点时是从最右边开始枚举，所以每次改变右端点时，计数数组要相应的改变。

**Java代码**

```java
class Solution {
    public String longestNiceSubstring(String s) {
        char[] arr = s.toCharArray();
        String ans = "";
        int max = 0;
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < arr.length; i++) {
            int[] uper = new int[26];
            int[] lower = new int[26];
            for (int j = i; j < arr.length; j++) {
                if (arr[j] >= 'a')
                    lower[arr[j]-'a']++;
                else    
                    uper[arr[j]-'A']++;
            }
            for (int j = arr.length-1; j > i; j--) {
                sb = new StringBuilder(s.substring(i, j+1));
                if (check(uper, lower)) {
                    if (sb.length() > max) {
                        max = sb.length();
                        ans = sb.toString();
                    }
                }
                if (arr[j] >= 'a')
                    lower[arr[j]-'a']--;
                else    
                    uper[arr[j]-'A']--;
            }
        }
        return ans;
    }
    public boolean check(int[] uper, int[] lower) {
        for (int i = 0; i < 26; i++) {
            if ((lower[i] != 0 || uper[i] != 0) && lower[i] * uper[i] == 0)
                return false;
        }
        return true;
    }
}
```

当然自己的代码还是很粗糙，看了下大佬的代码,，同样是暴力枚举，看着舒服一点，但是效率慢一点：

```java
class Solution {
    public String longestNiceSubstring(String s) {
        int n = s.length();
        String ans = "";
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                if (j - i + 1 > ans.length() &&
                    check(s.substring(i, j + 1))
                   ) 
                    ans = s.substring(i, j + 1);
            }
        }
        return ans;
    }
    boolean check(String s) {
        Set<Character> set = new HashSet<>();
        for (char c : s.toCharArray()) set.add(c);
        for (char c : s.toCharArray()) {
            char a = Character.toLowerCase(c), b = Character.toUpperCase(c);
            if (!set.contains(a) || !set.contains(b)) return false;
        }
        return true;
    }
}
```













# 十八、

> 

## 1. 概念定义

## 2. 题目练习

| 序号 | 题目链接 | 备注 |

## 3. 题解报告

---

**题目描述**

**解题思路**

**Java代码**







