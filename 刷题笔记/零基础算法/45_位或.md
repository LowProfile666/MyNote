# 位或

## 1. 概念定义

### 1）按位或

位或也就是按位或，顾名思义就是按二进制位进行“或”操作。



按位或运算符 `|` 是一个双目运算符，其功能是将参与运算的两数各对应的二进位相或。参与的两个数均以补码形式出现。



按位或的规则：==有 1 为 1，全 0 为 0==。如下：

```java
1 | 1 = 1
1 | 0 = 1
0 | 1 = 1
0 | 0 = 0
```



由上可得一些性质：

+ 任何数 位或 1，都是 1。
+ 只有 0 位或 0，结果才为 0。



比如：3 | 5 = 7

```
3 ：   	011
5 ： | 	101
      ----------
      	   111  
```



### 2）应用

根据位或的运算规则，位或操作可以应用于很多的场合。

#### a. 将指定位变为 1

一个二进制位上要么是 0 要么是 1，要将指定位变成 1，那么可以用该位上的数字与 1 进行 `|` 操作，因为不管当前位是 0 还是 1，与 1 进行或操作都会为 1。



比如：将 133 的低位第 5 位变为 1：

```java
133 | 0b10000
```



#### b. 将指定位变为 0

如果一个二进制位上是 1，要怎么才能将它变为 0 呢？在 位与 的学习中学到了如何解决该问题。

比如：一个数的二进制低位的第五位是 1，要将它变为 0，可用 `0b11111111111111111111111111101111` 或 `0xFFFFFFEF` 与这个数进行 `&` 操作，但是这种写法可读性差，又容易失手出错。



那如何利用位或来解决这个问题？可以利用位或和减法。

+ 首先，将指定位转换为 1
+ 然后，将指定位的 1 减去

比如：将 149 的低位第五位变为 0：

```java
(149 | 0b10000) - 0b10000
```



这样，指定位就必然变成 0。



注意：在不确定指定位一定是 1 的情况下，不能直接使用减法，否则会产生借位，所以要先使用 `|` 操作保证该位一定是 1。

## 2. 题目练习

| 题目链接                                                     | 备注 |
| ------------------------------------------------------------ | ---- |
| [统计按位或能得到最大值的子集数目](https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/) |      |

## 3. 解题报告

[统计按位或能得到最大值的子集数目](https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/)

**题目描述**

> 给你一个整数数组 `nums` ，请你找出 `nums` 子集 **按位或** 可能得到的 **最大值** ，并返回按位或能得到最大值的 **不同非空子集的数目** 。
>
> 如果数组 `a` 可以由数组 `b` 删除一些元素（或不删除）得到，则认为数组 `a` 是数组 `b` 的一个 **子集** 。如果选中的元素下标位置不一样，则认为两个子集 **不同** 。
>
> 对数组 `a` 执行 **按位或** ，结果等于 `a[0] OR a[1] OR ... OR a[a.length - 1]`（下标从 **0** 开始）。

**解题思路**

记 n 为 nums 的长度，我们以二进制的方式来想，将 n 个数当成 n 个二进制位，每一位用 0 和 1 来分别表示当前位的数 选 与 不选 的状态。

因为有 n 位，每一位有 2 种状态，所以总共有 `2^n - 1` 种情况，即 `1 << n` 。用从 0 到 1<<n 的数字 i 即可表示每一种可能的情况，i 的二进制位中的 1 的位置就是 nums 中被选中的数字的位置。

**Java代码**

```java
class Solution {
    public int countMaxOrSubsets(int[] nums) {
        int n = nums.length;
        int max = 0;  // (1)
        int res = 0; 
        int total = 1 << n;  // (2)
        for (int i = 0; i < total; i++) {  // (3)
            int cur = 0;  // (4)
            for (int j = 0; j < n; j++) {  // (5)
                if (((i >> j) & 1) == 1) {  
                    cur |= nums[j];
                }       
            }
            if (cur > max) {
                max = cur;
                res = 1;
            } else if (cur == max)
                res++;
        }
        return res;
    }
}
```

（1）：最大或值

（2）：总的情况数量

（3）：遍历每一种情况，每个 i 就是一种子集情况，i 的二进制位的 1 的位置就是 nums 中被选中的数字的位置

（4）：当前情况的或值

（5）：计算当前情况选中的数字的或值
