# Acwing 模板

## 第  场周赛

**时间：**2023/5/20 19:00 - 20:15

**战况：**AC 0 题。

**总结：**

### 题目链接

| 题目链接 | 备注 |
| -------- | ---- |
|          |      |

### 解题报告

<font size=5px color=red>**第一题** ：</font>

**题目描述**

> 

**输入格式**

> 

**输出格式**

> 

**解题思路**



**Java代码**

```java

```

<font size=5px color=red>**第二题** ：</font>

**题目描述**

> 

**输入格式**

> 

**输出格式**

> 

**解题思路**



**Java代码**

```java

```

<font size=5px color=red>**第三题** ：</font>

**题目描述**

> 

**输入格式**

> 

**输出格式**

> 

**解题思路**



**Java代码**

```java

```

----



# LeetCode 模板

## 第  场周赛

**时间**：2023/5/21 10:30 - 12:00

**战况**：AC 0 题。

**总结**：

### **题目链接**

| 题目链接 | 备注 |
| :------: | :--: |
|          |      |
|          |      |
|          |      |
|          |      |

### 解题报告

<font size=5px color=red>**第一题**：</font>

**题目描述**

> 

**解题思路**



**Java代码**

```java

```

<font size=5px color=red>**第二题**：</font>

**题目描述**

> 

**解题思路**



**Java代码**

```java

```

---



# CodeForces 模板

## Name

**时间**：2023/5/25 22:35 - 2023/5/26 00:35

**战况**：AC 1 题。

**总结**：

### 题目链接

| 题目链接 | 备注 |
| -------- | ---- |
|          |      |
|          |      |
|          |      |
|          |      |
|          |      |
|          |      |

### 解题报告

<font size=5px color=red>**第一题**：</font>

**题目描述**

> 

**Input**

> 

**Output**

> 

**解题思路**



**Java代码**

```java

```

<font size=5px color=red>**第二题**：</font>

**题目描述**

> 

**Input**

> 

**Output**

> 

**解题思路**



**Java代码**

```java

```

---





# AcWing

## 第 104 场周赛

**时间**：2023/5/20 19:00 - 20:15

**战况**：AC 1题，TLE 两题。:cry:

### **题目链接**

| 序号 |                         题目链接                         |       备注       |
| :--: | :------------------------------------------------------: | :--------------: |
|  1   | [第几项 ](https://www.acwing.com/problem/content/4984/)  |      简单题      |
|  2   |   [进制](https://www.acwing.com/problem/content/4985/)   | 中等题，留待将来 |
|  3   | [最大的数](https://www.acwing.com/problem/content/4986/) | 中等题，赛后做出 |

### 题解报告

<font size=5px color=red>**第一题** ：[第几项 ](https://www.acwing.com/problem/content/4984/)</font>

**题目描述**

> 给定一个正偶数 $n$ ，我们生成如下两个等差数列：
>
> - 奇数等差数列：$1,3,5,...,n-1$ 
> - 偶数等差数列：$n,n-2,n-4,...,2$ 
>
> 给定一个 $[1,n]$ 范围内的整数 $a$，请你判断它在哪个数列，并输出它在该数列的第几项。
>
> 等差数列求项数公式：
>
> <center><font size=5px>项数=(末项-首项)/公差 + 1</font></center>
>
> 数列中的每一个数都叫做这个数列的项。排在第一位的数称为这个数列的第 1 项（通常也叫做首项），排在第二位的数称为这个数列的第 2 项，以此类推。

**输入格式**

> 共一行，两个整数 n,a。

**输出格式**

> 一个整数，表示 a 在数列的第几项。

**输出格式**

> 一个整数，表示 a 在数列的第几项。

**解题思路**

这题很简单，其实就是求正数第几个奇数，倒数第几个偶数，或者说是求等差数列的第几项。公式都是直接给出来的，所以可以直接套着公式走。

如果输入的 a 是偶数，那么首项就是 n ，如果 a 是奇数，那么首项就是 1，a 一直都是末项，因为求的就是 a 的项数，而公差明显就是 2。

**Java代码**

```java
import java.util.Scanner;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int a = sc.nextInt();
        int a1 = 1, d = 2;
        if (a % 2 == 0) {
            a1 = n;
        }
        System.out.println(Math.abs(a-a1)/d + 1);
    }
}
```

<font size=5px color=red>**第二题**：[进制](https://www.acwing.com/problem/content/4985/)</font>

【暂不会】

<font size=5px color=red>**第三题**：[最大的数](https://www.acwing.com/problem/content/4986/)</font>

**题目描述**

> 给定一个长度为 n 的正整数数列 a1,a2,…,an。
>
> 请你回答 n 个问题，其中第 i 个问题是：请你找到一个尽可能小的**非负**整数 bi，使得 ai 增加 bi 后满足，所有位于 ai 后面的元素（如果有的话）都**严格小于** ai。
>
> 注意，所有问题相互独立，互不影响。

**输入格式**

> 第一行包含整数 n。
>
> 第二行包含 n 个整数 a1,a2,…,an。

**输出格式**

> 共一行，输出 n 个整数 b1,b2,…,bn。

**解题思路**

本题的意思就是，让数列里的每一位，都加上一个数后，可以大于该位后面的每一位，并且要让加上的这个数尽量小。

~~我第一次做题的解决方法是：找到数组的最大值，然后可以得到该最大值左边的所有元素的最小加数，因为左边的数只要大于这个最大值，就肯定大于其它数了；然后递归处理该最大值的右边部分。但是这个方法会超时。~~

可以用一个数组 nums，接收输入的数，用一个数组 ans，保存 nums 内对应位的最小加数。然后用一个指针 cur_max 从 nums 数组的右边往左边走起，拿 cur_max 与 cur_max 前一个数 pre 进行比较，这样就不用考虑那么多，只需要考虑 nums 里每一位的右边的一个数即可。

+ 如果 pre 大于 cur_max ：pre 对应的最小加数就是 0，因为 pre 不用加就比右边的所有数大了。同时将 cur_max 更新为 pre。
+ 如果 pre 等于 cur_max ：pre 对应的最小加数就是 1，因为 pre 只需要加 1 就可以比右边所有数大了。
+ 如果 pre 小于 cur_max ：pre 对应的最小加数就是 cur_max - pre + 1，因为不能等于右边的数，所以要加 1。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++)
            nums[i] = sc.nextInt();
        int[] ans = new int[n];
        int cur_max = nums[n-1];
        ans[n-1] = 0;
        for (int i = n-2; i >= 0; i--) {
            if (nums[i] > cur_max) {
                cur_max = nums[i];
                ans[i] = 0;
            }
            else if (nums[i] == cur_max)
                ans[i] = 1;
            else
                ans[i] = cur_max - nums[i] + 1;
        }
        for (int i = 0; i < n; i++) {
            System.out.print(ans[i] + " ");
        }
    }
}
```

## 第 105 场周赛

**时间**：2023/5/27 19:00 - 20:15

**战况**：尝试 2 题，AC 1题。:cry:

**总结**：还是得多练习。

### **题目链接**

| 序号 |                           题目链接                           |       备注       |
| :--: | :----------------------------------------------------------: | :--------------: |
|  1   |   [极值数量](https://www.acwing.com/problem/content/5032/)   |      简单题      |
|  2   | [核心元素](https://www.acwing.com/problem/content/description/5033/) | 简单题，赛后做出 |
|  3   |   [矩阵扩张](https://www.acwing.com/problem/content/5034/)   | 中等题，留待将来 |

### 题解报告

<font size=5px color=red>**第一题** ：[极值数量](https://www.acwing.com/problem/content/5032/)</font>

**题目描述**

> 给定一个长度为 n 的整数数组 a1,a2,…,an。
>
> 如果一个元素左右两边**均有**相邻元素（也就是不位于数组的两端），且满足以下两个条件之一：
>
> - 该元素的值**严格大于**其左右相邻元素的值
> - 该元素的值**严格小于**其左右相邻元素的值
>
> 则称该元素为一个极值元素。
>
> 请你计算，给定数组中有多少个极值元素。

**输入格式**

> 第一行包含整数 n。
>
> 第二行包含 n 个整数 a1,a2,…,an。

**输出格式**

> 一个整数，表示极值元素的数量。

**解题思路**

就是求出数组中比相邻数字大和比相邻数字小的数之和，这种数肯定不会出现在数组的首尾，所以只需要从下标 1 开始遍历到 n-1 即可。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++)
            nums[i] = sc.nextInt();
        int ans = 0;
        for (int i = 1; i < n-1; i++) {
            if (nums[i] > nums[i-1] && nums[i] > nums[i+1])
                ans++;
            if (nums[i] < nums[i-1] && nums[i] < nums[i+1])
                ans++;
        }
        System.out.println(ans);
    }
}
```

<font size=5px color=red>**第二题** ：[核心元素](https://www.acwing.com/problem/content/description/5033/)</font>

**题目描述**

> 给定一个长度为 n 的整数数组 a1,a2,…,an，数组中的每个元素都是一个 1∼n 之间的整数。
>
> 我们规定，数组中出现次数最多的元素为数组的核心元素，例如数组 [1,1,1,2,3] 的核心元素为 1。
>
> 此外，如果数组中出现次数最多的元素不唯一，则出现次数最多的元素中数值最小的那个元素为数组的核心元素，例如数组 [1,2,2,3,3] 的核心元素为 2。
>
> 对于 1≤i≤n 的每个整数 i，请你计算有多少个给定数组的**非空连续**子数组的核心元素为 i。

**输入格式**

> 第一行包含整数 n。
>
> 第二行包含 n 个整数 a1,a2,…,an。

**输出格式**

> 共一行，输出 n 个整数，其中第 i 个整数表示给定数组中核心元素为 i 的**非空连续**子数组的数量。

**解题思路**

题意是：分别求核心元素为 1 到 n 的子数组的个数。

枚举子数组的左端点和右端点，来枚举以每个位置为左端点的所有子数组情况，这样的话，子数组范围每次扩大都是向右移动一个元素，用一个数组来记录每个数字出现的次数，方便比较出核心元素。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n];
        int[] cnt = new int[5001];
        int[] res = new int[5001];
        for (int i = 0; i < n; i++)
            nums[i] = sc.nextInt();
        for (int i = 0; i < nums.length; i++) {
            cnt = new int[5001];
            int key = 0;
            for (int j = i; j < nums.length; j++) {
                int t = nums[j];
                cnt[t]++;
                if (cnt[t] > cnt[key] || cnt[t] == cnt[key] && t < key)
                    key = t;
                res[key]++;
            }
        }
        for (int i = 1; i <= n; i++)
            System.out.print(res[i] + " ");
    }
}
```

## 第 106 场周赛

**时间**：2023/6/3 19:00 - 20:15

**战况**：AC 1题。:cry:

**总结**：第二题感觉还差点，和图相关的，等我复习到搜素算法时就能过一次了。

### **题目链接**

| 序号 |                           题目链接                           |  备注  |
| :--: | :----------------------------------------------------------: | :----: |
|  1   |  [字符串操作](https://www.acwing.com/problem/content/5035/)  | 简单题 |
|  2   | [最远距离](https://www.acwing.com/problem/content/description/5036/) |        |
|  3   |     [配对](https://www.acwing.com/problem/content/5037/)     |        |

### 题解报告

<font size=5px color=red>**第一题** ：[字符串操作](https://www.acwing.com/problem/content/5035/)</font>

**题目描述**

> 给定一个长度为 n 的字符串 s1s2…sn。
>
> 你需要对该字符串连续进行 m 次字符替换操作。
>
> 每次操作给定一个操作范围 l,r 和两个字符 c1、c2，你需要将 sl…sr 中的所有 c1（如果有的话）都替换为 c2。
>
> 请你输出所有操作完成后，最终得到的字符串。

**输入格式**

> 第一行包含两个整数 n,m。
>
> 第二行包含一个长度为 n 的字符串 s1s2…sn，此字符串由小写字母构成。
>
> 接下来 m 行，每行包含四个参数 l,r,c1,c2，其中 c1 和 c2 均为小写字母。

**输出格式**

> 输出所有操作完成后，最终得到的字符串。

**解题思路**

字符串的操作。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        char[] s = sc.next().toCharArray();
        while (m-- != 0) {
            int l = sc.nextInt()-1;
            int r = sc.nextInt()-1;
            char c1 = sc.next().charAt(0);
            char c2 = sc.next().charAt(0);
            while (l <= r) {
                if (s[l] == c1)
                    s[l] = c2;
                l++;
            }
        }
        System.out.println(String.valueOf(s));
    }   
}
```

## 第 107 场周赛

**时间**：2023/6/10 19:00 - 20:15

**战况**：AC 2题。:cry:

**总结**：差一点 AK，最后一题暴力解法过了，但是比赛结束两分钟了。

### **题目链接**

| 序号 |                         题目链接                         | 备注 |
| :--: | :------------------------------------------------------: | :--: |
|  1   | [四舍五入](https://www.acwing.com/problem/content/5038/) |      |
|  2   |  [二元组](https://www.acwing.com/problem/content/5039/)  |      |
|  3   | [区间异或](https://www.acwing.com/problem/content/5040/) |      |

### 题解报告

<font size=5px color=red>**第一题** ：[四舍五入](https://www.acwing.com/problem/content/5038/)</font>

**题目描述**

> 给定一个非负整数 n，请你将它四舍五入为一个以 0 结尾的数。

**输入格式**

> 一个非负整数 n。

**输出格式**

> 一个整数，表示四舍五入后的 n。

**解题思路**

就是判断整数 n 的个位数是否大于 5：

+ 大于等于 5 ：向前进一，个位变 0 。
+ 小于 5 ：个位变 0 。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if (n % 10 < 5)
            n -= n%10;
        else {
            n += 10 - n%10;
        }
        System.out.println(n);
    }   
}
```

<font size=5px color=red>**第二题** ：[二元组](https://www.acwing.com/problem/content/5039/)</font>

**题目描述**

> 给定两个整数 n,m，请你计算有多少个整数二元组 (x,y) 能够同时满足以下所有条件：
>
> - 1≤x≤n
> - 1≤y≤m
> - (x+y)mod5=0
>
> 注意，(1,2) 和 (2,1) 视为两个不同二元组。

**输入格式**

> 共一行，包含两个整数 n,m。

**输出格式**

> 一个整数，表示满足条件的整数二元组 (x,y) 的数量。

**解题思路**

暴力解法，	在一定范围内枚举 5 的倍数。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        long res = 0;
        int min = n > m ? m : n;
        int max = n > m ? n : m;
        for (int num = 5; num/2 <= max; num+=5) {
            int x = num-1;
            if (x <= n && x <= m) {
                res += num / 2 * 2;
                if (num % 2 == 0)
                    res--;
                continue;
            }
            if (x > max)
                x = max;
            if (num - x > min)
                continue;
            res += x - (num-min) + 1;
        }
        System.out.println(res);
    }
}
```

<font size=5px color=red>**第三题** ：[区间异或](https://www.acwing.com/problem/content/5040/)</font>

**题目描述**

> 给定一个长度为 n 的整数数组 a1,a2,…,an。
>
> 你需要依次执行 m 个操作，操作分为以下两种：
>
> - `1 l r`，求和操作，你需要计算并输出 al+al+1+…+ar 的值。
> - `2 l r x`，异或操作，你需要令 al=al⊕x,al+1=al+1⊕x,…,ar=ar⊕x。其中 ⊕ 指按位异或。

**输入格式**

> 第一行包含整数 n。
>
> 第二行包含 n 个整数 a1,a2,…,an。
>
> 第三行包含整数 m。
>
> 接下来 m 行，每行包含一个操作指令，格式如题面描述。

**输出格式**

> 每个求和操作输出一行结果，一个整数，表示 al+al+1+…+ar 的值。

**解题思路**

暴力模拟。

**Java代码**

```java
import java.util.*;
public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++)
            arr[i] = sc.nextInt();
        int m = sc.nextInt();
        int a = 0, l = 0, r = 0, x = 0;
        while (m-- != 0) {
            a = sc.nextInt();
            l = sc.nextInt();
            r = sc.nextInt();
            if (a == 1) {
                System.out.println(sum(arr, l-1, (r>=n?n-1:r-1)));
            } else {
                x = sc.nextInt();
                for (int i = l-1; i < r; i++) {
                    arr[i] ^= x;
                }
            }
        }
    }
    public static long sum(int[] a, int l, int r) {
        long res = 0;
        while (l <= r) {
            res += a[l];
            l++;
        }
        return res;
    }
}
```

## 第 108 场周赛

**时间：**2023/6/17 19:00 - 20:15

**战况：**AC 2 题。

**总结：**

### 题目链接

| 题目链接                                                 | 备注 |
| -------------------------------------------------------- | ---- |
| [函数](https://www.acwing.com/problem/content/5041/)     |      |
| [构造数组](https://www.acwing.com/problem/content/5042/) |      |
| [拼接数组](https://www.acwing.com/problem/content/5043/) |      |

### 解题报告

<font size=5px color=red>**第一题** ：[函数](https://www.acwing.com/problem/content/5041/)</font>

**题目描述**

> 已知，$f(x)=2x^2+2x+1$。
>
> 给定一个整数 n，请你计算并输出 f(n) 的值。

**输入格式**

> 一个整数 n。

**输出格式**

> 一个整数，表示 f(n) 的值。

**解题思路**

直接输出公式的结果。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        System.out.println((2 * n * n - 2 * n + 1));
    }
}
```

<font size=5px color=red>**第二题** ：[构造数组](https://www.acwing.com/problem/content/5042/)</font>

**题目描述**

> 给定一个长度为 n 的正整数数组 a1,a2,…,an。
>
> 请你构造一个正整数数组 b1,b2,…,bn，要求：
>
> 1. 对于 1≤i≤n，1≤bi≤ai 均成立。
> 2. 在满足上一要求的前提下，令 Mex(b) 尽可能大。
>
> Mex(b) 指**未**在数组 b 中出现过的最小**正**整数。
>
> 请你计算并输出，Mex(b) 的最大可能值。

**输入格式**

> 第一行包含整数 n。
>
> 第二行包含 n 个整数 a1,a2,…,an。

**输出格式**

> 一个整数，表示 Mex(b) 的最大可能值。

**解题思路**

要想得到没出现过的最小正整数，且这个数尽可能最大，那么 bi 就应该从 1 开始，每次增加 1 ，如果 bi > ai 了，那么 bi 就是 ai，用一个数组 b 来表示 bi，数组 a 来表示 ai：

+ b[i] = b[i-1] + 1 (i < n && b[i] < a[i])
+ b[i] = a[i] (b[i] > a[i])

可以将 a 数组排序，因为这里的顺序不影响，然后按以上规则给 b 数组每个元素赋值，最后输出 b 数组的最后一个元素 + 1，因为 b[b.length-1] 一定是已经出现过的最大整数，所以给它 + 1 才是未出现过的最小的整数。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }
        Arrays.sort(a);
        int[] b = new int[n];
        b[0] = 1;
        for (int i = 1; i < a.length; i++) {
            b[i] = b[i-1] + 1;
            if (b[i] > a[i])
                b[i] = a[i];
        }
        System.out.println(b[b.length-1] + 1);
    }
}
```

----

## 第 109 场周赛

**时间：**2023/6/24 19:00 - 20:15

**战况：**AC 2 题。

**总结：**

### 题目链接

| 题目链接                                               | 备注 |
| ------------------------------------------------------ | ---- |
| [函数](https://www.acwing.com/problem/content/5044/)   |      |
| [病毒](https://www.acwing.com/problem/content/5045/)   |      |
| [鸡尾酒](https://www.acwing.com/problem/content/5046/) |      |

### 解题报告

<font size=5px color=red>**第一题** ：[函数](https://www.acwing.com/problem/content/5044/)</font>

**题目描述**

> 已知，
>
> ![image-20230624222536366](https://gitee.com/LowProfile666/image-bed/raw/master/img/image-20230624222536366.png)
>
> 给定一个整数 n，请你计算并输出 f(n) 的值。

**输入格式**

> 一个整数 n。

**输出格式**

> 一个整数，表示 f(n) 的值。

**解题思路**

1 左移 n/2 位就是 2 的 n/2 次方。

**Java代码**

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if (n % 2 == 0)
            System.out.println(1 << n / 2);
        else
            System.out.println(0);
    }
}
```

<font size=5px color=red>**第二题** ：[病毒](https://www.acwing.com/problem/content/5045/)</font>

**题目描述**

> 给定一个 n 行 m 列的方格矩阵，行编号 1∼n，列编号 1∼m。
>
> 其中，第 i 行第 j 列的方格的坐标为 (i,j)。
>
> 初始时，有 k 个方格被病毒感染。
>
> 每一分钟，病毒都会从每个感染方格向上下左右四个方向蔓延一格。
>
> 最终，所有方格都将被病毒感染。
>
> 请你找到最后被感染的方格。
>
> 如果这样的方格不唯一，则输出任意一个即可。

**输入格式**

> 第一行包含两个整数 n,m。
>
> 第二行包含一个整数 k。
>
> 第三行包含 2k 个整数 x1,y1,x2,y2,…,xk,yk，每对 (xi,yi) 表示一个感染方格的坐标。保证 k 个感染方格的坐标两两不同。

**输出格式**

> 输出两个整数 x,y，表示最后被感染的方格的坐标为 (x,y)。
>
> 如果答案不唯一，输出任意合理答案均可。

**解题思路**

该题是一个 BFS 类的题目，算的是离病毒源最远的距离的点。【还不会这样写】

竞赛时就想着模拟，用一个队列先将病毒源入队，然后每次入队被新感染的格子，同时用一个全局变量记录未被感染的格子数，当未被感染的格子数为 1 时，就记录下当前格子的坐标，并作为答案输出。

**Java代码**

```java
import java.util.*;
public class Main{
    static int count, resx, resy;
    static List<int[]> list;
    public static void main(String[] args){
        list = new ArrayList<>();
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        count = n * m;
        int k = sc.nextInt();
        int[][] mat = new int[n+1][m+1];
        for (int i = 0; i < k; i++) {
            int x = sc.nextInt();
            int y = sc.nextInt();
            mat[x][y] = 1;
            list.add(new int[]{x, y});
        }
        count -= k;
        resx = 1; resy = 1;
        for (int i = 0; i < list.size(); i++) {
            int x = list.get(i)[0];
            int y = list.get(i)[1];
            dfs(mat, n+1, m+1, x, y);
            if (count < 1)
                break;
        }
        System.out.println(resx + " " + resy);
    }
    public static void dfs(int[][] mat, int n, int m, int x, int y) {
        if (x-1 >= 1 && mat[x-1][y] != 1) {
            if (--count == 0) {
                resx = x-1;
                resy = y;
            }
            list.add(new int[]{x-1, y});
            mat[x-1][y] = 1;
        }
            
        if (x+1 < n && mat[x+1][y] != 1) {
            if (--count == 0) {
                resx = x+1;
                resy = y;
            }
            list.add(new int[]{x+1, y});
            mat[x+1][y] = 1;
        }
            
        if (y-1 >= 1 && mat[x][y-1] != 1) {
            if (--count == 0) {
                resx = x;
                resy = y-1;
            }
            list.add(new int[]{x, y-1});
            mat[x][y-1] = 1;
        }
            
        if (y+1 < m && mat[x][y+1] != 1) {
           if (--count == 0) {
                resx = x;
                resy = y+1;
            }
            list.add(new int[]{x, y+1});
            mat[x][y+1] = 1;
        }
    }
}
```

<font size=5px color=red>**第三题** ：[鸡尾酒](https://www.acwing.com/problem/content/5046/)</font>

**题目描述**

> 某种鸡尾酒由 n 种饮品（编号 1∼n）混合调制而成。
>
> 在调制该鸡尾酒时，n 种饮品必须严格按照 a1:a2:…:an 的比例进行混合。
>
> n 种饮品的实际现有量分别为 b1,b2,…,bn 升。
>
> 现在，请你用一个最大容积为 v 升的量杯来调制该鸡尾酒，利用此量杯一次可以调制出 0∼v 升鸡尾酒。
>
> 由于时间有限，你只能调制**一次**。
>
> 请问，利用现有材料和给定量杯，你最多可以调制出多少升鸡尾酒。
>
> 注意：
>
> - 调制出的鸡尾酒量不一定是整数。
> - 由于只能调制一次，所以无论材料多么充裕，你都最多只能调制出 v 升鸡尾酒。

**输入格式**

> 第一行包含两个整数 n,v。
>
> 第二行包含 n 个整数 a1,a2,…,an。
>
> 第三行包含 n 个整数 b1,b2,…,bn。

**输出格式**

> 一个实数，表示可以调制出的鸡尾酒的最大量（单位：升）。
>
> 输出结果与正确答案的相对或绝对误差小于 10^−4^，则视为正确。

**解题思路**

数学题，因为 ai 间存在着比例关系：

 $a1:a2:a3:...:an$ 

可以设每个 ai 使用的饮品量为 x ，即：

$a_1x:a_2x:a_3x:...:a_nx$ 

 a~i~x 即为第 i 种饮品的实际用量，那么实际能配出的鸡尾酒升数就是各个 a~i~x 之和：

$a_1x + a_2x+a_3x+...+a_nx$ 

而实际用量最大只能为 b~i~，所以：

$a_ix\leqslant b_i$ 

所以，要求出能配置的最大升数，主要是求出 x 的最大值。又因为最大能调出的鸡尾酒升数为 v，所以有：

$a_1x + a_2x+a_3x+...+a_nx \leqslant v$ ，

设 $sum = a_1+a_2+a_3+...+a_n$ ，即：

$x\leqslant \frac{v}{sum}$  

由上和由题可得：

+ $ 0\leqslant x\leqslant \frac{bi}{ai}$ 
+ $ 0\leqslant x\leqslant \frac{v}{sum}$ 

那么 x 的最大值应该为：

$x_{max}=min(\frac{bi}{ai},\frac{v}{sum})$ 

所以实际能配置出的最大的升数就应该为：

$a_1x_{max}+a_2x_{max}+a_3x_{max}+...+a_nx_{max}$ 

即：

$sum\times x_{max}$ 

**Java代码**

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int v = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) a[i] = sc.nextInt();
        int[] b = new int[n];
        for (int i = 0; i < n; i++) b[i] = sc.nextInt();
        double sum = 0, x = 200;
        for (int i = 0; i < n; i++) {
            x = Math.min(x, (double)b[i] / a[i]);  // 这里一定要注意强转，不然结果会是int形，失去精度
            sum += a[i];
        }
        x = Math.min(x, v / sum);
        System.out.println(x * sum);
    }
}
```

----



## 第 110 场周赛

**时间：**2023/7/1 19:00 - 20:15

**战况：**AC 2 题。

**总结：**

### 题目链接

| 题目链接                                                 | 备注 |
| -------------------------------------------------------- | ---- |
| [求和](https://www.acwing.com/problem/content/5047/)     |      |
| [三角形数](https://www.acwing.com/problem/content/5048/) |      |
| [智商药](https://www.acwing.com/problem/content/5049/)   |      |

### 解题报告

<font size=5px color=red>**第一题** ：[求和](https://www.acwing.com/problem/content/5047/)</font>

**题目描述**

> 给定 n 个整数 a1,a2,…,an 和一个整数 S。
>
> 请你判断，a1+a2+…+an 是否等于 S。

**输入格式**

> 第一行包含整数 T，表示共有 T 组测试数据。
>
> 每组数据第一行包含两个整数 n,S。
>
> 第二行包含 n 个整数 a1,a2,…,an。

**输出格式**

> 每组数据输出一行结果，如果 a1+a2+…+an 等于 S，则输出 `YES`，否则输出 `NO`。

**解题思路**



**Java代码**

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        while (T-- != 0) {
            int n = sc.nextInt();
            int s = sc.nextInt();
            for (int i = 0; i < n; i++)
                s -= sc.nextInt();
            System.out.println((s==0) ? "YES" : "NO");
        }
    }
}
```



<font size=5px color=red>**第二题** ：[三角形数](https://www.acwing.com/problem/content/5048/)</font>

**题目描述**

> 一定数目的点或圆在等距离的排列下可以形成一个等边三角形，这样的数被称为三角形数。
>
> 前 6 个三角形数分别为 1,3,6,10,15,21。
>
> ![a.png](https://gitee.com/LowProfile666/image-bed/raw/master/img/19_2a26645601-a.png)
>
> 第 n 个三角形数是从 11 开始的 n 个自然数的和，即 n(n+1)2。
>
> 给定一个正整数 x，请你判断 x 能否表示为两个三角形数（可以相同）的和。

**输入格式**

> 一个正整数 x。

**输出格式**

> 如果 x 可以表示为两个三角形数之和，则输出 `YES`，否则输出 `NO`。

**解题思路**

最开始的想法是使用哈希表，遍历每一个三角形数，判断 x 减去这个三角形数的差是否存在。但是会超时。

使用前后双指针，相加，如果大于 x，则将右指针减小；如果小于 x，则将左指针增大。

**Java代码**

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int x = sc.nextInt();
        List<Integer> list = new ArrayList<>();
        for (int i = 0; ; i++) {
            if (i*(i+1)/2 >= x)
                break;
            list.add(i*(i+1)/2);
        }
        String res = "NO";
        int l = 0, r = list.size()-1;
        while (l <= r) {
            int a = list.get(l) + list.get(r);
            if (a == x) {
                res = "YES";
                break;
            } else if (a > x)
                r--;
            else 
                l++;
        }
        System.out.println(res);
    }
}
```

<font size=5px color=red>**第三题** ：</font>

**题目描述**

> 

**输入格式**

> 

**输出格式**

> 

**解题思路**



**Java代码**

```java

```

----





---

# LeetCode

## 第 346 场周赛

**时间**：2023/5/21 10:30 - 12:00

**战况**：AC 0 题。:cry:

**总结**：参加周赛次数太少，做题时没有专注思考。比如第一题我一眼就想到了栈，但是在脑中模拟实现时却不知道怎么模拟下去，导致思路偏移，最后思路混乱，无从下手。

### **题目链接**

| 序号 |                           题目链接                           |       备注       |
| :--: | :----------------------------------------------------------: | :--------------: |
|  1   | [删除子串后的字符串最小长度 ](https://leetcode.cn/contest/weekly-contest-346/problems/minimum-string-length-after-removing-substrings/) | 简单题，赛后做出 |
|  2   | [字典序最小回文串](https://leetcode.cn/contest/weekly-contest-346/problems/lexicographically-smallest-palindrome/) | 简单题，赛后做出 |
|  3   | [求一个整数的惩罚数](https://leetcode.cn/problems/find-the-punishment-number-of-an-integer/) | 中等题，留待将来 |
|  4   | [修改图中的边权](https://leetcode.cn/problems/modify-graph-edge-weights/) | 困难题，留待将来 |

### 解题报告

<font size=5px color=red>**第一题**：[删除子串后的字符串最小长度 ](https://leetcode.cn/contest/weekly-contest-346/problems/minimum-string-length-after-removing-substrings/)</font>

**题目描述**

> 给你一个仅由 **大写** 英文字符组成的字符串 `s` 。
>
> 你可以对此字符串执行一些操作，在每一步操作中，你可以从 `s` 中删除 **任一个** `"AB"` 或 `"CD"` 子字符串。
>
> 通过执行操作，删除所有 `"AB"` 和 `"CD"` 子串，返回可获得的最终字符串的 **最小** 可能长度。
>
> **注意**，删除子串后，重新连接出的字符串可能会产生新的 `"AB"` 或 `"CD"` 子串。

**解题思路**

~~第一眼看到这个就想到了用栈匹配括号的问题，但是做题时没做出来。~~

维护一个栈，遍历字符串，将每一个不是 ‘B’ 和 ‘D’ 的字符入栈，当碰到 ‘B’ 和 ‘D’ 字符时，判断栈顶是否是 ‘A’ 或 ‘C’，如果是则出栈，如果不是则将 ‘B’ 和 ‘D’ 入栈。

最后，栈里剩下的元素就是删除完 ”AB“ 和 ”CD“ 的字符。

**Java代码**

```java
class Solution {
    public int minLength(String s) {
        char[] arr = s.toCharArray();
        char[] stack = new char[arr.length];
        int top = 0;
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == 'B' && top > 0 && stack[top-1] == 'A') {
                --top;
            } else if (arr[i] == 'D' && top > 0 && stack[top-1] == 'C') {
                --top;
            } else {
                stack[top++] = arr[i];
            }
        }
        return top;
    }
}
```

<font size=5px color=red>**第二题**：[字典序最小回文串 ](https://leetcode.cn/problems/lexicographically-smallest-palindrome/)</font>

**题目描述**

> 给你一个由 **小写英文字母** 组成的字符串 `s` ，你可以对其执行一些操作。在一步操作中，你可以用其他小写英文字母 **替换** `s` 中的一个字符。
>
> 请你执行 **尽可能少的操作** ，使 `s` 变成一个 **回文串** 。如果执行 **最少** 操作次数的方案不止一种，则只需选取 **字典序最小** 的方案。
>
> 对于两个长度相同的字符串 `a` 和 `b` ，在 `a` 和 `b` 出现不同的第一个位置，如果该位置上 `a` 中对应字母比 `b` 中对应字母在字母表中出现顺序更早，则认为 `a` 的字典序比 `b` 的字典序要小。
>
> 返回最终的回文字符串。

**解题思路**

本题就是把字符串 s 转换成一个回文串，一个尽量小的回文串。所以可以利用双指针，判断前后字符是否相等，相等则构成回文条件，不等则需要使其相等。

因为题目要求最小的回文串，所以当两个字符不相等时，将大的字符转换成小的字符即可。

**Java代码**

```java
class Solution {
    public String makeSmallestPalindrome(String s) {
        char[] arr = s.toCharArray();
        int l = 0, r = arr.length-1;
        while (l < r) {
            if (arr[l] != arr[r]) {
                if (arr[l] > arr[r])
                    arr[l] = arr[r];
                else
                    arr[r] = arr[l];
            }
            l++;
            r--;
        }
        return String.valueOf(arr);
    }
}
```

## 第 347 场周赛

**时间**：2023/5/28 10:30 - 12:00

**战况**：AC 2 题。:cry:

**总结**：比上一次好很多了，虽然做出来得只是两道简单题。但是两道题都是一遍过的感觉很爽，尤其是第二题时，一大段描述，我最初以为我应该还是做不出来，但是多看了一会发现可以试一下，就试过了。所以说，最起码要在尝试后才说不行。

### **题目链接**

| 序号 |                           题目链接                           | 备注 |
| :--: | :----------------------------------------------------------: | :--: |
|  1   | [移除字符串中的尾随零](https://leetcode.cn/problems/remove-trailing-zeros-from-a-string/) |  AC  |
|  2   | [对角线上不同值的数量差](https://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals/) |  AC  |
|  3   | [使所有字符相等的最小成本](https://leetcode.cn/problems/minimum-cost-to-make-all-characters-equal/) |      |
|  4   | [矩阵中严格递增的单元格数](https://leetcode.cn/problems/maximum-strictly-increasing-cells-in-a-matrix/) |      |

### 解题报告

<font size=5px color=red>**第一题**：[移除字符串中的尾随零](https://leetcode.cn/problems/remove-trailing-zeros-from-a-string/) </font>

**题目描述**

> 给你一个用字符串表示的正整数 `num` ，请你以字符串形式返回不含尾随零的整数 `num` 。

**解题思路**

将字符串从后往前遍历，遍历到第一个不是 0 的字符，然后返回该下标即之前的字符串。

**Java代码**

```java
class Solution {
    public String removeTrailingZeros(String num) {
        char[] s = num.toCharArray();
        int i = s.length-1;
        for ( ; i >= 0; i--) {
            if (s[i] != '0')
                break;
        }
        return num.substring(0, i+1);
    }
}
```

<font size=5px color=red>**第二题**：[对角线上不同值的数量差](https://leetcode.cn/problems/difference-of-number-of-distinct-values-on-diagonals/) </font>

**题目描述**

> 给你一个下标从 `0` 开始、大小为 `m x n` 的二维矩阵 `grid` ，请你求解大小同样为 `m x n` 的答案矩阵 `answer` 。
>
> 矩阵 `answer` 中每个单元格 `(r, c)` 的值可以按下述方式进行计算：
>
> - 令 `topLeft[r][c]` 为矩阵 `grid` 中单元格 `(r, c)` 左上角对角线上 **不同值** 的数量。
> - 令 `bottomRight[r][c]` 为矩阵 `grid` 中单元格 `(r, c)` 右下角对角线上 **不同值** 的数量。
>
> 然后 `answer[r][c] = |topLeft[r][c] - bottomRight[r][c]|` 。
>
> 返回矩阵 `answer` 。
>
> **矩阵对角线** 是从最顶行或最左列的某个单元格开始，向右下方向走到矩阵末尾的对角线。
>
> 如果单元格 `(r1, c1)` 和单元格 `(r, c) `属于同一条对角线且 `r1 < r` ，则单元格 `(r1, c1)` 属于单元格 `(r, c)` 的左上对角线。类似地，可以定义右下对角线。

**解题思路**

遍历 grid 矩阵中每一个元素，然后计算出每个元素的上/下对角线不同值得数量，赋给 answer 中对应的位置即可。

这里的每个单元格的对角线，就是从当前单元格开始，一直往下一行、往右一列的连线；而上对角线就是比当前单元格行数、列数都小的单元格，下对角线就是比当前单元格行数、列数都大的单元格。

所以，遍历每个单元格时，可以通过当前单元格的坐标来确定它的上下对角线。

**Java代码**

```java
class Solution {
    public int[][] differenceOfDistinctValues(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] res = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                res[i][j] = Math.abs(topLeft(grid, i, j) - bottomRight(grid, i, j));
            }
        }
        return res;
    }
    public int topLeft(int[][] grid, int x, int y) {
        if (x == 0 || y == 0) return 0;
        int[] cnt = new int[51];
        for (int i = x-1, j = y-1; i >= 0 && j >= 0; i--, j--) {
            cnt[grid[i][j]]++;
        }
        int res = 0;
        for (int i = 0; i < 51; i++)
            if (cnt[i] != 0)
                res++;
        return res;
    }
    public int bottomRight(int[][] grid, int x, int y) {
        if (x == grid.length || y == grid[0].length)    return 0;
        int[] cnt = new int[51];
        for (int i = x+1, j = y+1; i < grid.length && j < grid[0].length; i++, j++) {
            cnt[grid[i][j]]++;
        }
        int res = 0;
        for (int i = 0; i < 51; i++)
            if (cnt[i] != 0)
                res++;
        return res;
    }
}
```

## 第 348 场周赛

**时间**：2023/6/4 10:30 - 12:00

**战况**：AC 2 题。:cry:

**总结**：依旧两题，第三题超了内存限制，但是不知道怎么优化。

### **题目链接**

| 序号 |                           题目链接                           | 备注 |
| :--: | :----------------------------------------------------------: | :--: |
|  1   | [最小化字符串长度](https://leetcode.cn/contest/weekly-contest-348/problems/minimize-string-length/) |  AC  |
|  2   | [半有序排列](https://leetcode.cn/contest/weekly-contest-348/problems/semi-ordered-permutation/) |  AC  |
|  3   | [查询后矩阵的和](https://leetcode.cn/contest/weekly-contest-348/problems/sum-of-matrix-after-queries/) |      |
|  4   | [统计整数数目](https://leetcode.cn/contest/weekly-contest-348/problems/count-of-integers/) |      |

### 解题报告

<font size=5px color=red>**第一题**：[最小化字符串长度](https://leetcode.cn/contest/weekly-contest-348/problems/minimize-string-length/) </font>

**题目描述**

> 给你一个下标从 **0** 开始的字符串 `s` ，重复执行下述操作 **任意** 次：
>
> - 在字符串中选出一个下标 `i` ，并使 `c` 为字符串下标 `i` 处的字符。并在 `i` **左侧**（如果有）和 **右侧**（如果有）各 **删除** 一个距离 `i` **最近** 的字符 `c` 。
>
> 请你通过执行上述操作任意次，使 `s` 的长度 **最小化** 。
>
> 返回一个表示 **最小化** 字符串的长度的整数。

**解题思路**

其实就是统计字符串中有多少个不同的字母。因为只要有相同的字母就绝对可以删掉，最后留下的字母一定是互不相同的。

**Java代码**

```java
class Solution {
    public int minimizedStringLength(String s) {
        char[] ss = s.toCharArray();
        int[] cnt = new int[26];
        for (int i = 0; i < ss.length; i++) {
            ++cnt[ss[i]-'a'];
        }
        int res = 0;
        for (int i = 0; i < 26; i++) {
            if (cnt[i] != 0)
                res++;
        }
        return res;
    }
}
```

<font size=5px color=red>**第二题**：[半有序排列](https://leetcode.cn/contest/weekly-contest-348/problems/semi-ordered-permutation/)</font>

**题目描述**

> 给你一个下标从 **0** 开始、长度为 `n` 的整数排列 `nums` 。
>
> 如果排列的第一个数字等于 `1` 且最后一个数字等于 `n` ，则称其为 **半有序排列** 。你可以执行多次下述操作，直到将 `nums` 变成一个 **半有序排列** ：
>
> - 选择 `nums` 中相邻的两个元素，然后交换它们。
>
> 返回使 `nums` 变成 **半有序排列** 所需的最小操作次数。
>
> **排列** 是一个长度为 `n` 的整数序列，其中包含从 `1` 到 `n` 的每个数字恰好一次。

**解题思路**

最小操作次数就是让 1 和 n 移动到下标 0 和 n-1 位置上的次数，可以使用双指针，先找出 1 和 n 所在的位置，然后注意 n 所在的位置是否是在 1 的左边，因为在 1 的左边的话，将 1 移动到下标 0 时肯定会和 n 进行一次交换，这样的话 n 的位置就会向后移动一位。最后返回 1 和 n 当前位置到数组两端的距离之和。

**Java代码**

```java
class Solution {
    public int semiOrderedPermutation(int[] nums) {
        int res = 0;
        int l = 0, r = nums.length-1;
        while (nums[l] != 1)    l++;
        while (nums[r] != nums.length)   r--;
        if (r < l)  r++;
        return l + (nums.length-1-r);
    }
}
```

## 第 106 场双周赛

**时间：**2023/6/10 22:30 - 00:00

**战况：**AC 2 题。

**总结：**第一次双周赛，和周赛一样，稳定 2 题。

### 题目链接

| 题目链接                                                     | 备注 |
| ------------------------------------------------------------ | ---- |
| [判断一个数是否迷人](https://leetcode.cn/problems/check-if-the-number-is-fascinating/) |      |
| [找到最长的半重复子字符串](https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/) |      |
| [移动机器人](https://leetcode.cn/problems/movement-of-robots/) |      |
| [找到矩阵中的好子集](https://leetcode.cn/problems/find-a-good-subset-of-the-matrix/) |      |

### 解题报告

<font size=5px color=red>**第一题** ：[判断一个数是否迷人](https://leetcode.cn/problems/check-if-the-number-is-fascinating/)</font>

**题目描述**

> 给你一个三位数整数 `n` 。
>
> 如果经过以下修改得到的数字 **恰好** 包含数字 `1` 到 `9` 各一次且不包含任何 `0` ，那么我们称数字 `n` 是 **迷人的** ：
>
> - 将 `n` 与数字 `2 * n` 和 `3 * n` **连接** 。
>
> 如果 `n` 是迷人的，返回 `true`，否则返回 `false` 。
>
> **连接** 两个数字表示把它们首尾相接连在一起。比方说 `121` 和 `371` 连接得到 `121371` 。

**解题思路**

直接判断 n 和 2\*n 和 3\*n 三个数中是否分别有重复的数字，是则返回 false，否则返回 true。

在最开始还可以进行一些数的筛选，因为 n 是 3 位数，n 和 2\*n、3\*n 连起来是 9 位数，那么 3\*n 最高也只能是 3 位数，所以有：

3\*n <= 999

所以有：n <= 333

又因为 n 不能含相同数字，所以 n 最高为 321 。n 最低为 123 。

**Java代码**

```java
class Solution {
    public boolean isFascinating(int n) {
        int n2 = 2 * n;
        int n3 = 3 * n;
        int[] cnt = new int[10];
        while (n != 0) {
            if (n % 10 == 0)
                return false;
            if (++cnt[n%10] > 1)
                return false;
            n /= 10;
        }
        while (n2 != 0) {
            if (n2 % 10 == 0)
                return false;
            if (++cnt[n2%10] > 1)
                return false;
            n2 /= 10;
        }
        while (n3 != 0) {
            if (n3 % 10 == 0)
                return false;
            if (++cnt[n3%10] > 1)
                return false;
            n3 /= 10;
        }
        return true;
    }
}
```

<font size=5px color=red>**第二题** ：[找到最长的半重复子字符串](https://leetcode.cn/problems/find-the-longest-semi-repetitive-substring/)</font>

**题目描述**

> 给你一个下标从 **0** 开始的字符串 `s` ，这个字符串只包含 `0` 到 `9` 的数字字符。
>
> 如果一个字符串 `t` 中至多有一对相邻字符是相等的，那么称这个字符串是 **半重复的** 。
>
> 请你返回 `s` 中最长 **半重复** 子字符串的长度。
>
> 一个 **子字符串** 是一个字符串中一段连续 **非空** 的字符。

**解题思路**

枚举每个子字符串，用一个 boolean 标记是否出现过相邻相等字符，记录下每个子字符串的长度，保留最长的字符串长度。

**Java代码**

```java
class Solution {
    public int longestSemiRepetitiveSubstring(String s) {
        char[] ss = s.toCharArray();
        int max = 0;
        for (int i = 0; i < ss.length; i++) {
            boolean f = false;
            int len = 1;
            for (int j = i; j < ss.length-1; j++) {
                if (!f && ss[j] == ss[j+1]) {
                    f = true;
                } else if (f && ss[j] == ss[j+1]) {
                    break;
                }
                len++;
            }
            max = max > len ? max : len;
        }
        return max;
    }
}
```

## 第 349 场周赛

**时间：**2023/6/11 10:30 - 12:00

**战况：**AC 2 题。

**总结：**稳定 2 题。

### 题目链接

| 题目链接                                                     | 备注 |
| ------------------------------------------------------------ | ---- |
| [既不是最小值也不是最大值](https://leetcode.cn/problems/neither-minimum-nor-maximum/) |      |
| [执行子串操作后的字典序最小字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation/) |      |
| [收集巧克力](https://leetcode.cn/problems/collecting-chocolates/) |      |
| [最大和查询](https://leetcode.cn/problems/maximum-sum-queries/) |      |

### 解题报告

<font size=5px color=red>**第一题** ：[既不是最小值也不是最大值](https://leetcode.cn/problems/neither-minimum-nor-maximum/)</font>

**题目描述**

> 给你一个整数数组 `nums` ，数组由 **不同正整数** 组成，请你找出并返回数组中 **任一** 既不是 **最小值** 也不是 **最大值** 的数字，如果不存在这样的数字，返回 **`-1`** 。
>
> 返回所选整数。

**解题思路**

排序，返回除了第一个和最后一个数字即可。

**Java代码**

```java
class Solution {
    public int findNonMinOrMax(int[] nums) {
        if (nums.length <= 2)
            return -1;
        Arrays.sort(nums);
        return nums[1];
    }
}
```

<font size=5px color=red>**第二题** ：[执行子串操作后的字典序最小字符串](https://leetcode.cn/problems/lexicographically-smallest-string-after-substring-operation/)</font>

**题目描述**

> 给你一个仅由小写英文字母组成的字符串 `s` 。在一步操作中，你可以完成以下行为：
>
> - 选则 `s` 的任一非空子字符串，可能是整个字符串，接着将字符串中的每一个字符替换为英文字母表中的前一个字符。例如，'b' 用 'a' 替换，'a' 用 'z' 替换。
>
> 返回执行上述操作 **恰好一次** 后可以获得的 **字典序最小** 的字符串。
>
> **子字符串** 是字符串中的一个连续字符序列。
>
> 现有长度相同的两个字符串 `x` 和 字符串 `y` ，在满足 `x[i] != y[i]` 的第一个位置 `i` 上，如果 `x[i]` 在字母表中先于 `y[i]` 出现，则认为字符串 `x` 比字符串 `y` **字典序更小** 。

**解题思路**

'a' 是字典序中最小的存在，所以找到第一个不是连续的 'a' 的位置，将其之前的字符全部减一。

如果字符串里全是 'a' ，那么只需要将字符串的最后一个字符变成 'z' 即可。

**Java代码**

```java
class Solution {
    public String smallestString(String s) {
        char[] ss = s.toCharArray();
        int l = 0;
        while (l < ss.length && ss[l] == 'a')
            ++l;
        if (l == ss.length) {
            ss[l-1] = 'z';
            return String.valueOf(ss);
        }
        while (l < ss.length && ss[l] != 'a') {
            --ss[l++];
        }
        return String.valueOf(ss);
    }
}
```

## 第 107 场双周赛

**时间**：2023/6/24 22:30 - 00:00

**战况**：AC 1 题。

**总结**：

### **题目链接**

|                           题目链接                           | 备注 |
| :----------------------------------------------------------: | :--: |
| [最大字符串配对数目](https://leetcode.cn/problems/find-maximum-number-of-string-pairs/) |      |
| [构造最长的新字符串](https://leetcode.cn/problems/construct-the-longest-new-string/) |      |
| [字符串连接删减字母](https://leetcode.cn/problems/decremental-string-concatenation/) |      |
| [统计没有收到请求的服务器数目](https://leetcode.cn/problems/count-zero-request-servers/) |      |

### 解题报告

<font size=5px color=red>**第一题**：[最大字符串配对数目](https://leetcode.cn/problems/find-maximum-number-of-string-pairs/)</font>

**题目描述**

> 给你一个下标从 **0** 开始的数组 `words` ，数组中包含 **互不相同** 的字符串。
>
> 如果字符串 `words[i]` 与字符串 `words[j]` 满足以下条件，我们称它们可以匹配：
>
> - 字符串 `words[i]` 等于 `words[j]` 的反转字符串。
> - `0 <= i < j < words.length`
>
> 请你返回数组 `words` 中的 **最大** 匹配数目。
>
> 注意，每个字符串最多匹配一次。

**解题思路**

可以使用哈希表，将所有字符串先保存在哈希表中，然后再遍历字符串数组，判断每个字符串逆转后是否存在于哈希表中。需要注意的是回文串的存在，因为题目要求各个字符串间互不相同，所以回文串不会有匹配的字符串的，所以当遍历到一个回文串时，直接跳过即可。

**Java代码**

```java
class Solution {
    public int maximumNumberOfStringPairs(String[] words) {
        HashSet<String> set = new HashSet<>();
        int res = 0;
        for (String s : words)
            set.add(s);
        for (String s : words) {
            String t = new StringBuffer(s).reverse().toString();
            if (!s.equals(t) && set.contains(t)) {
                res++;
                set.remove(t);
                set.remove(s);
            }
        }
        return res;
    }
}
```

<font size=5px color=red>**第二题**：[构造最长的新字符串](https://leetcode.cn/problems/construct-the-longest-new-string/)</font>

**题目描述**

> 给你三个整数 `x` ，`y` 和 `z` 。
>
> 这三个整数表示你有 `x` 个 `"AA"` 字符串，`y` 个 `"BB"` 字符串，和 `z` 个 `"AB"` 字符串。你需要选择这些字符串中的部分字符串（可以全部选择也可以一个都不选择），将它们按顺序连接得到一个新的字符串。新字符串不能包含子字符串 `"AAA"` 或者 `"BBB"` 。
>
> 请你返回新字符串的最大可能长度。
>
> **子字符串** 是一个字符串中一段连续 **非空** 的字符序列。

**解题思路**

先不考虑 AB 字符串，先考虑 AA 和 BB 字符串，AA 和 BB 是可以相互一直连接的形成 AABBAABB...，直到有一方个数为 0 。

假设 x 和 y 中，x 小于等于 y，那么最多可以使用 x 个 AA ，同时也会使用掉 x 个 BB，但是如果还有多余的 BB 的话，剩下的 BB 一定还可以再使用一个，因为 x 个 AA 和 x 个 BB 组成的字符一定是这样的：AA...BB 或者 BB...AA ，所以还可以使用一个 BB 要么接在头，要么接在尾。

那么 AA 和 BB 的使用总数就是：`2*min(x, y) + (x == y ? 0 : 1)`。

而 AB 是可以放在 BB 和 AB 之后的，所以 z 个 AB 都可以直接接在一个 BB 的后面。所以总的字符串使用总数就是：`2*min(x, y) + (x == y ? 0 : 1) + z`，题目要求最大的长度，那么返回字符串的使用总数乘以 2 就是了，因为每个字符串的长度为 2 。

**Java代码**

```java
class Solution {
    public int longestString(int x, int y, int z) {
        int b = x == y ? 0 : 1;
        return 2 * (Math.min(x, y) * 2 + b + z);
    }
}
```

---

## 第 351 场周赛

**时间**：2023/6/25 10:30 - 12:00

**战况**：AC 1 题。

**总结**：

### **题目链接**

|                           题目链接                           | 备注 |
| :----------------------------------------------------------: | :--: |
| [美丽下标对的数目](https://leetcode.cn/problems/number-of-beautiful-pairs/) |      |
| [得到整数零需要执行的最少操作数](https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/) |      |
| [将数组划分成若干好子数组的方式](https://leetcode.cn/problems/ways-to-split-array-into-good-subarrays/) |      |
| [机器人碰撞](https://leetcode.cn/problems/robot-collisions/) |      |

### 解题报告

<font size=5px color=red>**第一题**：[美丽下标对的数目](https://leetcode.cn/problems/number-of-beautiful-pairs/)</font>

**题目描述**

> 给你一个下标从 **0** 开始的整数数组 `nums` 。如果下标对 `i`、`j` 满足 `0 ≤ i < j < nums.length` ，如果 `nums[i]` 的 **第一个数字** 和 `nums[j]` 的 **最后一个数字** **互质** ，则认为 `nums[i]` 和 `nums[j]` 是一组 **美丽下标对** 。
>
> 返回 `nums` 中 **美丽下标对** 的总数目。
>
> 对于两个整数 `x` 和 `y` ，如果不存在大于 1 的整数可以整除它们，则认为 `x` 和 `y` **互质** 。换而言之，如果 `gcd(x, y) == 1` ，则认为 `x` 和 `y` 互质，其中 `gcd(x, y)` 是 `x` 和 `k` **最大公因数** 。

**解题思路**

直接暴力枚举即可。

获得一个数的最高位可以这样做：判断该数是不是一个大于等于 10 的数，是的话就循环除 10，直到该数为个位数就是原数的最高位。

**Java代码**

```java
class Solution {
    public int countBeautifulPairs(int[] nums) {
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            for (int j = i+1; j < nums.length; j++) {
                int a = nums[i];
                while (a >= 10)
                    a /= 10;
                int b = nums[j] % 10;
                if (gcd(a, b) == 1)
                    res++;
            }
        }
        return res;
    }
    public int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a%b);
    }
}
```

或者可以使用哈希表，将高位的数字记录到哈希表中，然后遍历每个数的尾数是否和 1 到 9 互质，是的话就累加次数。

```java
class Solution {
    public int countBeautifulPairs(int[] nums) {
        int[] cnt = new int[10];
        int res = 0;
        for (int x : nums) {
            for (int i = 1; i <= 9; i++)
                if (gcd(x%10, i) == 1) 
                    res += cnt[i];
            while (x >= 10)
                x /= 10;
            ++cnt[x];
            
        }
        return res;
    }
    public int gcd(int a, int b) {
        return b == 0 ? a : gcd(b, a%b);
    }
}
```

<font size=5px color=red>**第二题**：[得到整数零需要执行的最少操作数](https://leetcode.cn/problems/minimum-operations-to-make-the-integer-zero/)</font>

**题目描述**

> 给你两个整数：`num1` 和 `num2` 。
>
> 在一步操作中，你需要从范围 `[0, 60]` 中选出一个整数 `i` ，并从 `num1` 减去 `2i + num2` 。
>
> 请你计算，要想使 `num1` 等于 `0` 需要执行的最少操作数，并以整数形式返回。
>
> 如果无法使 `num1` 等于 `0` ，返回 `-1` 。

**解题思路**

假设有 k 次操作，num1 - (num2 + 2^i^)  的过程就是：

$num1-(num2+2^i)-(num2+2^i)-...【k 个(num2+2^i),i不一定相同】$   

可以化成：

$num1-k*num2-(2^i+...)(k个2^i,i不一定相同)$ 

要使：

 $num1-k*num2-(2^i+...)=0$ 

那么：

$num1-k*num2=(2^i+...)$ 

设 $x=num1-k*num2$ ，那么只要求出 x 能被分解成多少个 2^i^ 即可。

而 x 最多能分解出 x 个 2^i^（i=0），最少只能分解出 x 的二进制表示中 1 的个数。

那么我们可以枚举操作次数 k，判断 x 是否能分解出 k 个 2^i^ ，意思就是 k 只要在 x 能分解 2^i^ 的个数范围中即可，即：

$x.bitCount \leqslant k \leqslant x$ 

满足则返回 k，否则，返回 -1。

数据较大，需要使用 long 类型。

**Java代码**

```java
class Solution {
    public int makeTheIntegerZero(int num1, int num2) {
        for (long k = 1; k <= num1-num2*k; k++) {
            long x = num1 - num2 * k;
            if (k >= bitCount(x))
                return (int)k;
        }
        return -1;
    }
    public int bitCount(long n) {
        int res = 0;
        while (n != 0) {
            if ((n & 1) == 1)
                res++;
            n >>= 1;
        }
        return res;
    }
}
```

---



## 第 352 场周赛

**时间**：2023/5/21 10:30 - 12:00

**战况**：AC 0 题。

**总结**：

### **题目链接**

|                           题目链接                           | 备注 |
| :----------------------------------------------------------: | :--: |
| [最长奇偶子数组](https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/) |      |
| [和等于目标值的质数对](https://leetcode.cn/problems/prime-pairs-with-target-sum/) |      |
| [不间断子数组](https://leetcode.cn/problems/continuous-subarrays/) |      |
| [所有子数组中不平衡数字之和](https://leetcode.cn/problems/sum-of-imbalance-numbers-of-all-subarrays/) |      |

### 解题报告

<font size=5px color=red>**第一题**：[最长奇偶子数组](https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/)</font>

**题目描述**

> 给你一个下标从 **0** 开始的整数数组 `nums` 和一个整数 `threshold` 。
>
> 请你从 `nums` 的子数组中找出以下标 `l` 开头、下标 `r` 结尾 `(0 <= l <= r < nums.length)` 且满足以下条件的 **最长子数组** ：
>
> - `nums[l] % 2 == 0`
> - 对于范围 `[l, r - 1]` 内的所有下标 `i` ，`nums[i] % 2 != nums[i + 1] % 2`
> - 对于范围 `[l, r]` 内的所有下标 `i` ，`nums[i] <= threshold`
>
> 以整数形式返回满足题目要求的最长子数组的长度。
>
> **注意：子数组** 是数组中的一个连续非空元素序列。

**解题思路**

枚举起点 l，记下每个起点开始的最大长度，比较出最大值即可。

**Java代码**

```java
class Solution {
    public int longestAlternatingSubarray(int[] nums, int threshold) {
        int res = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] % 2 != 0 || nums[i] > threshold)
                continue;
            int cur = 1;
            for (int j = i+1; j < nums.length; j++) {
                if (nums[j] % 2 == nums[j-1] % 2)
                    break;
                if (nums[j] > threshold)
                    break;
                cur++;
            }
            res = res > cur ? res : cur;
        }
        return res;
    }
}
```

<font size=5px color=red>**第二题**：[和等于目标值的质数对](https://leetcode.cn/problems/prime-pairs-with-target-sum/)</font>

**题目描述**

> 给你一个整数 `n` 。如果两个整数 `x` 和 `y` 满足下述条件，则认为二者形成一个质数对：
>
> - `1 <= x <= y <= n`
> - `x + y == n`
> - `x` 和 `y` 都是质数
>
> 请你以二维有序列表的形式返回符合题目要求的所有 `[xi, yi]` ，列表需要按 `xi` 的 **非递减顺序** 排序。如果不存在符合要求的质数对，则返回一个空数组。
>
> **注意：**质数是大于 `1` 的自然数，并且只有两个因子，即它本身和 `1` 。

**解题思路**

先使用素数筛将所有可能出现的素数求出来，然后枚举每一个素数 x，判断 n-x 是否是一个素数，是则加入答案列表，并且标记已被使用。

一定要将使用过的素数进行标记处理，不然的话会出现重复，比如 10 = 3 + 7，在枚举到 3 的时候就已经把 3、7 都加入了答案列表，如果不标记已被使用的话，当后面枚举到 7 的时候又会把 7、3 加入到答案lie'biao

**Java代码**

```java
class Solution {
    public List<List<Integer>> findPrimePairs(int n) {
        int[] f = new int[n];
        for (int i = 2; i < n; i++) {
            if (f[i] == 0) {
                for (long j = (long)i*i; j < n; j += i)
                    f[(int)j] = 1;
            }
        }
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> t = new ArrayList<>();
        for (int i = 2; i < n; i++) {
            if (f[i] == 0) {
                int x = i;
                int y = n - x;
                if (y > 1 && y < n && f[y] == 0) {
                    t.add(x);
                    t.add(y);
                    f[y] = 1;
                    res.add(t);
                    t = new ArrayList<>();
                }
            }
        }
        return res;
    }
}
```

---



---

# CodeForces

## Educational Codeforces Round 149 [Rated for Div. 2\]

**时间**：2023/5/25 22:35 - 2023/5/26 00:35

**战况**：AC 1 题。:cry:

**总结**：第一次尝试 cf 的比赛，满满都是新的体验，最开始连提交代码的地方都没找到的，一直以为只能用文件提交……界面是全英文的，但是不影响我看懂题目意思，也不影响我一道题都做不出。

前两题认为难度不大，想表达的意思很简单，但是我第一想法只会暴力，结果又暴不出来，导致思维又陷入沼泽，经人提点后又豁然开朗，感觉这题是真简单，但是为什么不会做？

所以这种比赛还是要多参加，平时也要多训练，争取下一次能做出前二题。

### 题目链接

| 序号 | 题目链接                                                     | 备注                       |
| ---- | ------------------------------------------------------------ | -------------------------- |
| A    | [Grasshopper on a Line](https://codeforces.com/contest/1837/problem/A) | 简单数学题，问了人才做出来 |
| B    | [Comparison String](https://codeforces.com/contest/1837/problem/B) |                            |
| C    | [Best Binary String](https://codeforces.com/contest/1837/problem/C) |                            |
| D    | [Bracket Coloring](https://codeforces.com/contest/1837/problem/D) |                            |
| E    | [Playoff Fixing](https://codeforces.com/contest/1837/problem/E) |                            |
| F    | [Editorial for Two](https://codeforces.com/contest/1837/problem/F) |                            |

### 解题报告

<font size=5px color=red>**第一题**：[Grasshopper on a Line](https://codeforces.com/contest/1837/problem/A)</font>

**题目描述**

> You are given two integers x and k. Grasshopper starts in a point 0 on an OX axis. In one move, it can jump some integer distance, **that is not divisible by k**, to the left or to the right.
>
> What's the smallest number of moves it takes the grasshopper to reach point x? What are these moves? If there are multiple answers, print any of them.

**Input**

> The first line contains a single integer t (1 ≤ t ≤ 1000) — the number of testcases.
>
> The only line of each testcase contains two integers x and k (1 ≤ x ≤ 100; 2 ≤ k ≤ 100) — the endpoint and the constraint on the jumps, respectively.

**Output**

> For each testcase, in the first line, print a single integer n — the smallest number of moves it takes the grasshopper to reach point x.
>
> In the second line, print n integers, each of them not divisible by k. A positive integer would mean jumping to the right, a negative integer would mean jumping to the left. The endpoint after the jumps should be exactly x.
>
> Each jump distance should be from −10^9^ to 10^9^. In can be shown that, for any solution with the smallest number of jumps, there exists a solution with the same number of jumps such that each jump is from −10^9^ to 10^9^.
>
> It can be shown that the answer always exists under the given constraints. If there are multiple answers, print any of them.

**解题思路**

题目意思就是在 ox 轴上，可以往左和往右移动，每次移动的距离不能被 k 整除，求从 0 到 x 最少移动几次，每次移动距离是多少。

没有限制每次移动的距离是多少，所以最简单就是直接移动 x 的距离，但是需要判断 x 是否能被 k 整除，如果能整除的话，那就不能直接移动 x 的距离，那可以第一次移动 x-1 的距离，然后第二次移动 1 的距离；如果不能整除的话，那么 1 次移动 x 的距离就性。

**Java代码**

```java
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while (n-- != 0) {
            int x = sc.nextInt();
            int k = sc.nextInt();
            if (x % k != 0) {
                System.out.println(1);
                System.out.println(x);
                continue;
            } else {
                System.out.println(2);
                System.out.println(x-1 + " " + 1);
            }
        }
    }
}
```

<font size=5px color=red>**第二题**：[Comparison String](https://codeforces.com/contest/1837/problem/B)</font>

**题目描述**

> You are given a string s of length n, where each character is either < or >.
>
> An array a consisting of n+1 elements is compatible with the string s if, for every i from 1 to n, the character s~i~ represents the result of comparing a~i~ and a~i+1~, i. e.:
>
> - s~i~ is < if and only if a~i~<a~i+1~;
> - s~i~ is > if and only if a~i~>a~i+1~.
>
> For example, the array [1,2,5,4,2] is compatible with the string <<>>. There are other arrays with are compatible with that string, for example, [13,37,42,37,13].
>
> The **cost** of the array is the number of different elements in it. For example, the cost of [1,2,5,4,2] is 4; the cost of [13,37,42,37,13] is 3.
>
> You have to calculate the minimum cost among all arrays which are compatible with the given string s.

**Input**

> The first line contains one integer t (1≤t≤500) — the number of test cases.
>
> Each test case consists of two lines:
>
> - the first line contains one integer n (1≤n≤100);
> - the second line contains the string s, consisting of n characters. Each character of s is either < or >.

**Output**

> For each test case, print one integer — the minimum cost among all arrays which are compatible with the given string s.

**解题思路**

题目意思是给你一个长度为 n 的只有 <> 两种字符组成的字符串，然后求出大小关系匹配这个字符串的所需数字最少的个数。

比如字符串 <<>> ，可以表示 a\<b\<c\>b\>a ，比如 1<2<3>2>1 ，或者 1<3<5>4>2 ，这种情况下，所需数字最少的情况就是 1<2<3>2>1 ，因为只用到了 3 个数字，而第二种情况用到了 5 个数字。

[思路没想好……]

**Java代码**

```java
import java.util.Scanner;
 
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        while (n-- != 0) {
            int ans = 1, temp = 1;
            int len = sc.nextInt();
            String str = sc.next();
            char[] s = str.toCharArray();
            for (int i = 1; i < s.length; i++) {
                if (s[i] == s[i-1])
                    temp++;
                else {
                    ans = ans > temp ? ans : temp;
                    temp = 1;
                }
            }
            ans = ans > temp ? ans : temp;
            System.out.println(ans+1);
        }
    }
}
```

## Codeforces Round 876 (Div. 2)

**时间**：2023/6/3 22:35 - 2023/6/3 00:35

**战况**：AC 0 题。:cry:

**总结**：第一题的题都理解了半天，然后没有做出来，感觉是个找规律或者啥结论的题，但是不知道。

### 题目链接

| 序号 | 题目链接                                                     | 备注 |
| ---- | ------------------------------------------------------------ | ---- |
|      | [The Good Array](https://codeforces.com/contest/1839/problem/A) |      |
|      | [Lamps](https://codeforces.com/contest/1839/problem/B)       |      |
|      | [Insert Zero and Invert Prefix](https://codeforces.com/contest/1839/problem/C) |      |
|      | [Ball Sorting](https://codeforces.com/contest/1839/problem/D) |      |
|      | [Decreasing Game](https://codeforces.com/contest/1839/problem/E) |      |

### 解题报告

  [The Good Array](https://codeforces.com/contest/1839/problem/A)

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- != 0) {
            int n = sc.nextInt();
            int k = sc.nextInt();
            System.out.println(2+(n-2)/k);
        }
    }
}
```

## Codeforces Round 877 (Div. 2)

**时间**：2023/6/? 22:35 - 2023/6/? 00:35

**战况**：AC 0 题。:cry:

**总结**：

### 题目链接

| 序号 | 题目链接                                                     | 备注 |
| ---- | ------------------------------------------------------------ | ---- |
|      | [ Blackboard List](https://codeforces.com/contest/1838/problem/A) |      |
|      | [[Minimize Permutation Subarrays](https://codeforces.com/contest/1838/problem/B)](https://codeforces.com/contest/1839/problem/B) |      |
|      | [[No Prime Differences](https://codeforces.com/contest/1838/problem/C)](https://codeforces.com/contest/1839/problem/C) |      |
|      | [Bracket Walk](https://codeforces.com/contest/1838/problem/D) |      |
|      | [Count Supersequences](https://codeforces.com/contest/1838/problem/E) |      |
|      | [Stuck Conveyor](https://codeforces.com/contest/1838/problem/F) |      |

### 解题报告

[Blackboard List](https://codeforces.com/contest/1838/problem/A)  

**题目描述**

> Two integers were written on a blackboard. After that, the following step was carried out n−2 times:
>
> - Select any two integers on the board, and write the absolute value of their difference on the board.
>
> After this process was complete, the list of n integers was shuffled. You are given the final list. Recover **one** of the initial two numbers. You do **not** need to recover the other one.
>
> You are guaranteed that the input can be generated using the above process.

**Input**

> The first line of the input contains a single integer t (1≤t≤100) — the number of test cases. The description of the test cases follows.
>
> The first line of each test case contains a single integer n (3≤n≤100) — the size of the final list.
>
> The next line of each test case contains n integers a1,a2,…an (−10^9^≤ai≤10^9^) — the shuffled list of numbers written on the blackboard.
>
> It is guaranteed that the input was generated using the process described above.

**Output**

> For each test case, output a single integer x — one of the two initial numbers on the blackboard.
>
> If there are multiple solutions, print any of them.

**解题思路**

每次操作得到的是差值的绝对值，所以中途是不可能得到负数的，如果有负数就是最初的数字之一。另外，假如两个值求差，其差值肯定不会大于这两个数中的最大值，所以操作过程得到的数应该是越来越小的，所以最大的正数就是最初的数字之一，因为不会有两个数相减得到它。

**Java代码**

```java
import java.util.*;
 
public class Main{
    public static void main(String[] ags){
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- != 0) {
            int n = sc.nextInt();
            int min = 10000, max = -10000;
            for (int i = 0; i < n; i++) {
                int a = sc.nextInt();
                min = min < a ? min : a;
                max = max > a ? max : a;
            }
            if (min < 0)
                System.out.println(min);
            else
                System.out.println(max);
        }
    }
}
```



## Codeforces Round 878(Div. 3)

**时间**：2023/6/6 22:35 - 2023/6/7 00:35

**战况**：AC 1 题。:cry:

**总结**：这次题比较简单，但是思维转不过来，还有 bc 题的统计方式数目这类题型，一直担心超时不敢做，结果果然超时。

### 题目链接

| 序号 | 题目链接                                                     | 备注 |
| ---- | ------------------------------------------------------------ | ---- |
|      | [Cipher Shifer](https://codeforces.com/contest/1840/problem/A) |      |
|      | [[Binary Cafe](https://codeforces.com/contest/1840/problem/B)](https://codeforces.com/contest/1839/problem/B) |      |
|      | [Ski Resort](https://codeforces.com/contest/1840/problem/C)  |      |
|      | [Wooden Toy Festival](https://codeforces.com/contest/1840/problem/D) |      |
|      | [Character Blocking](https://codeforces.com/contest/1840/problem/E) |      |
|      | [Railguns](https://codeforces.com/contest/1840/problem/F)    |      |
|      | [In Search of Truth (Easy Version)](https://codeforces.com/contest/1840/problem/G1) |      |
|      | [In Search of Truth (Hard Version)](https://codeforces.com/contest/1840/problem/G2) |      |

### 解题报告

[Cipher Shifer](https://codeforces.com/contest/1840/problem/A)

**题目描述**

> There is a string a (unknown to you), consisting of lowercase Latin letters, encrypted according to the following rule into string s:
>
> - after each character of string a, an arbitrary (possibly zero) number of any lowercase Latin letters, different from the character itself, is added;
> - after each such addition, the character that we supplemented is added.
>
> You are given string s, and you need to output the initial string a. In other words, you need to decrypt string s.
>
> Note that each string encrypted in this way is decrypted **uniquely**.

**Input**

The first line of the input contains a single integer t (1≤t≤1000) — the number of test cases.

The descriptions of the test cases follow.

The first line of each test case contains a single integer n (2≤n≤100) — the length of the encrypted message.

The second line of each test case contains a string s of length n — the encrypted message obtained from some string a.

**Output**

For each test case, output the decrypted message a on a separate line.

**解题思路**

求出原来没加密的字符串，加密规则是：

+ 在每个字符后面加上随机数目（可能为0）的不同于当前字符的字符。
+ 在上个条件后，再用当前字符结尾

**Java代码**

```java
import java.util.*;
 
public class Main{

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        while (t-- != 0) {
            int n = sc.nextInt();
            char[] s = sc.next().toCharArray();
            StringBuffer res = new StringBuffer();
            res.append(s[0]);
            for (int i = 1, j = 0; i < n; i++) {
                if (s[i] == res.charAt(j) && i + 1 < n) {
                    res.append(s[++i]);
                    j++;
                }
            }
            System.out.println(String.valueOf(res));
        }
    }
}
```





----

# 牛客网

## 2023年儿童节比赛

**时间**：2023/6/1 19:00 - 2023/6/1 21:00

**战况**：AC 1 题。:cry:

**总结**：第一次做牛客的比赛，战况不佳，感觉有点难。

### 题目链接

| 序号 | 题目链接                                                     | 备注                           |
| ---- | ------------------------------------------------------------ | ------------------------------ |
| A    | [ 九九八十一](https://ac.nowcoder.com/acm/contest/58604/A)   | 不知道为什么一直报数组非法访问 |
| B    | [ 小X的问题](https://ac.nowcoder.com/acm/contest/58604/B)    |                                |
| C    | [ 该查表了](https://ac.nowcoder.com/acm/contest/58604/C)     |                                |
| D    | [ child](https://ac.nowcoder.com/acm/contest/58604/D)        |                                |
| E    | [ 小沙的悬崖](https://ac.nowcoder.com/acm/contest/58604/E)   |                                |
| F    | [ 啊啵呲嘚呃佛歌](https://ac.nowcoder.com/acm/contest/58604/F) | 这个最简单                     |
| G    | [小红过61](https://ac.nowcoder.com/acm/contest/58604/G)      |                                |
| H    | [majsoul](https://ac.nowcoder.com/acm/contest/58604/H)       |                                |





---

# 洛谷

## 【LGR-142-Div.4】洛谷入门赛 #13

**时间**：2023/6/9 19:00 - 2023/6/9 21:00

**战况**：AC 4.5 题。:cry:

**总结**：一共 10 题，没做到一半，还需要加油。感觉读题有点费事。

![image-20230609211931296](https://gitee.com/LowProfile666/image-bed/raw/master/img/image-20230609211931296.png)

### 题目链接

|                           题目链接                           | 备注                                             |
| :----------------------------------------------------------: | ------------------------------------------------ |
| [魔方](https://www.luogu.com.cn/problem/T342065?contestId=109937) | 简单计算                                         |
| [教学楼](https://www.luogu.com.cn/problem/T342066?contestId=109937) | if else 判断就完了                               |
| [课桌](https://www.luogu.com.cn/problem/T342067?contestId=109937) | 简单计算，注意数值范围                           |
| [教室](https://www.luogu.com.cn/problem/T342068?contestId=109937) | 简单计算，注意题目是最后一行是第几行、有几个桌子 |
| [信](https://www.luogu.com.cn/problem/T342069?contestId=109937) | TLE 5个案例，不知道为什么                        |
| [纸条](https://www.luogu.com.cn/problem/T342070?contestId=109937) |                                                  |
| [棋](https://www.luogu.com.cn/problem/T342071?contestId=109937) |                                                  |
| [演唱会](https://www.luogu.com.cn/problem/T342072?contestId=109937) |                                                  |
| [std::cerr](https://www.luogu.com.cn/problem/T342076?contestId=109937) |                                                  |
| [碎忆破的记](https://www.luogu.com.cn/problem/T342079?contestId=109937) |                                                  |

