## 水题

| 题目链接                                                     | 评分（等级） | 备注                   |
| ------------------------------------------------------------ | ------------ | ---------------------- |
| [对数组执行操作](https://leetcode.cn/problems/apply-operations-to-an-array/description/) | 1124         | LeetCode，模拟         |
| [子数组和排序后的区间和](https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/description/?envType=featured-list&envId=gQg42xUz) | 1402         | LeetCode，排序，前缀和 |
| [找出给定方程的正整数解](https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/description/?envType=featured-list&envId=gQg42xUz) | 1405         | LeetCode，枚举         |
|                                                              |              |                        |



## 排序

| 题目链接                                                     | 评分（等级） | 备注     | 题解           |
| ------------------------------------------------------------ | ------------ | -------- | -------------- |
| [2679. 矩阵中的和](https://leetcode.cn/problems/sum-in-a-matrix/description/) | 1333         | LeetCode | [题解](#排序1) |





## 链表

| 题目链接                                                     | 评分（等级） | 备注               | 题解           |
| ------------------------------------------------------------ | ------------ | ------------------ | -------------- |
| [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/description/) | 中等         | LeetCode，反转链表 | [题解](#链表1) |





## 队列

| 题目链接 | 评分（等级） | 备注 | 题解 |
| -------- | ------------ | ---- | ---- |
|          |              |      |      |





## 模拟

| 题目链接                                                     | 评分（等级） | 备注         | 题解           |
| ------------------------------------------------------------ | ------------ | ------------ | -------------- |
| [无限区域](https://www.acwing.com/problem/content/4446/)     | 简单         | AcWing，数学 | [题解](#模拟1) |
| [狗和猫](https://www.acwing.com/problem/content/description/4121/) | 简单         | AcWing       | [题解](#模拟2) |
| [1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/description/) | 1173         | LeetCode     | [题解](#模拟3) |





## 数列

| 题目链接                                                     | 评分（等级） | 备注               | 题解           |
| ------------------------------------------------------------ | ------------ | ------------------ | -------------- |
| [2485. 找出中枢整数](https://leetcode.cn/problems/find-the-pivot-integer/description/) | 1207         | LeetCode，等差数列 | [题解](#数列1) |





## 枚举

| 题目链接                                                     | 评分（等级） | 备注   |
| ------------------------------------------------------------ | ------------ | ------ |
| [饥饿的牛](https://www.acwing.com/problem/content/description/4911/) | 简单         | AcWing |



## 哈希表

| 题目链接                                                     | 评分（等级） | 备注     |
| ------------------------------------------------------------ | ------------ | -------- |
| [相等行列对](https://leetcode.cn/problems/equal-row-and-column-pairs/description/) | 1286         | LeetCode |



## 贪心

| 题目链接                                                     | 评分（等级） | 备注     | 题解           |
| ------------------------------------------------------------ | ------------ | -------- | -------------- |
| [划分字母区间](https://leetcode.cn/problems/partition-labels/description/?envType=featured-list&envId=gQg42xUz) | 1443         | LeetCode |                |
| [照相](https://www.acwing.com/problem/content/4443/)         | 中等         | AcWing   |                |
| [1253. 重构 2 行二进制矩阵](https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/description/) | 1506         | LeetCode | [题解](#贪心3) |
| [2600. K 件物品的最大和](https://leetcode.cn/problems/k-items-with-the-maximum-sum/description/) | 1434         | LeetCode | [题解](#贪心4) |



## 后缀和

| 题目链接                                                     | 评分（等级） | 备注     |
| ------------------------------------------------------------ | ------------ | -------- |
| [比较字符串最小字母出现频次](https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/description/) | 中等         | LeetCode |



## 字符串

| 题目链接                                                     | 评分（等级） | 备注                     |                  |
| ------------------------------------------------------------ | ------------ | ------------------------ | ---------------- |
| [快速打字](https://www.acwing.com/problem/content/description/4385/v) | 简单         | AcWing，字符串遍历、比较 |                  |
| [字符串转换](https://www.acwing.com/problem/content/4125/)   | 简单         | AcWingf，遍历、转换      |                  |
| [2490. 回环句](https://leetcode.cn/problems/circular-sentence/description/) | 1263         | LeetCode，分隔，比较     | [题解](#字符串3) |
| [递增子串](https://www.acwing.com/problem/content/description/3751/) | 简单         | AcWing，比较，前缀和     | [题解](#字符串4) |
| [Kick_Start](https://www.acwing.com/problem/content/description/3328/) | 简单         | AcWing，枚举             | [题解](#字符串5) |



## 二叉树

| 题目链接                                                     | 评分（等级） | 备注               | 题解             |
| ------------------------------------------------------------ | ------------ | ------------------ | ---------------- |
| [面试题 04.03. 特定深度节点链表](https://leetcode.cn/problems/list-of-depth-lcci/description/) | 中等         | LeetCode，层次遍历 | [题解](#二叉树1) |
| [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/description/) | 中等         | LeetCode           | [题解](#二叉树2) |
| [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/description/) | 中等         | LeetCode           | [题解](#二叉树3) |
| [1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/description/) | 1360         | LeetCode           | [题解](#二叉树4) |





## DFS && BFS

| 题目链接                                                     | 评分（等级） | 备注           | 题解               |
| ------------------------------------------------------------ | ------------ | -------------- | ------------------ |
| [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/description/) | 中等         | LeerCode，搜索 | [题解](#DFS&&BFS1) |
| [841.钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/description/) | 1412         | LeetCode，DFS  | [题解](#DFS&&BFS2) |
| [面试题 04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/description/) | 中等         | LeetCode，BFS  | [题解](#DFS&&BFS3) |



## DP

| 题目链接                                                     | 评分（等级） | 备注               | 题解         |
| ------------------------------------------------------------ | ------------ | ------------------ | ------------ |
| [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/) | 困难         | LeetCode，DP + DFS | [题解](#DP1) |
| [LCP 07. 传递信息](https://leetcode.cn/problems/chuan-di-xin-xi/description/) | 简单         | LeetCoder          | [题解](#DP2) |







## 题解报告

### 排序

<span id=排序1>[2679. 矩阵中的和](https://leetcode.cn/problems/sum-in-a-matrix/description/)</span>

> 给你一个下标从 **0** 开始的二维整数数组 `nums` 。一开始你的分数为 `0` 。你需要执行以下操作直到矩阵变为空：
>
> 1. 矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。
> 2. 在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 **分数** 中。
>
> 请你返回最后的 **分数** 。

将矩阵中的每一行从小到大排序，然后从右往左遍历每一列，选出一列中的最大值，累加到分数中。

**Java代码**

```java
class Solution {
    public int matrixSum(int[][] nums) {
        int res = 0;
        for (int[] arr : nums)
            Arrays.sort(arr);
        for (int i = nums[0].length-1; i >=0; i--) {
            int max = nums[0][i];
            for (int j = 1; j < nums.length; j++) {
                if (max < nums[j][i])
                    max = nums[j][i];
            }
            res += max;
        }
        return res;
    }
}
```





### 链表

<span id=链表1>[445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/description/)</span>

> 给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。

整数的存储方式和我们平常习惯的相反，所以先将两个链表反转以下，然后进行相加操作，最后将结果也反转一下即可。

**Java代码**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        l1 = reverse(l1);
        l2 = reverse(l2);
     
        ListNode head = new ListNode(0);
        ListNode dummy = new ListNode(-1, head);
        while (l1 != null || l2 != null) {
            if (l1 != null) {
                head.val += l1.val;
                l1 = l1.next;
            }                
            if (l2 != null) {
                head.val += l2.val;
                l2 = l2.next;
            }
            head.next = new ListNode();
            head.next.val = head.val / 10;
            if (head.next.val == 0 && l1 == null && l2 == null)
                head.next = null;
            head.val = head.val % 10;
            head = head.next;
        }
        return reverse(dummy.next);
    }
    public ListNode reverse(ListNode l) {
        ListNode pre = null, left = l, right = l.next;
        while (right != null) {
            left.next = pre;
            pre = left;
            left = right;
            right = right.next;
        }
        left.next = pre;
        return left;
    }
}
```









### 字符串

<span id=字符串3>[2490. 回环句](https://leetcode.cn/problems/circular-sentence/description/)</span>

> **句子** 是由单个空格分隔的一组单词，且不含前导或尾随空格。
>
> - 例如，`"Hello World"`、`"HELLO"`、`"hello world hello world"` 都是符合要求的句子。
>
> 单词 **仅** 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。
>
> 如果句子满足下述全部条件，则认为它是一个 **回环句** ：
>
> - 单词的最后一个字符和下一个单词的第一个字符相等。
> - 最后一个单词的最后一个字符和第一个单词的第一个字符相等。
>
> 例如，`"leetcode exercises sound delightful"`、`"eetcode"`、`"leetcode eats soul"` 都是回环句。然而，`"Leetcode is cool"`、`"happy Leetcode"`、`"Leetcode"` 和 `"I like Leetcode"` 都 **不** 是回环句。
>
> 给你一个字符串 `sentence` ，请你判断它是不是一个回环句。如果是，返回 `true` ；否则，返回 `false` 。

遍历，找到字符串中的空格，比较空格前后的两个字符是否相等。还要比较整个字符串的首尾两字符是否相等。

```java
class Solution {
    public boolean isCircularSentence(String sentence) {
        if (sentence.charAt(sentence.length() - 1) != sentence.charAt(0)) {
            return false;
        }
        for (int i = 0; i < sentence.length(); i++) {
            if (sentence.charAt(i) == ' ' 
             && sentence.charAt(i + 1) != sentence.charAt(i - 1)) {
                return false;
            } 
        }
        return true;
    }
}
```

<span id=字符串4>[递增子串](https://www.acwing.com/problem/content/description/3751/)</span>

> 你的朋友约翰刚刚度假归来，他迫不及待地想要跟你分享他了解到的关于字符串的一个新性质。
>
> 他了解到，如果一个长度为 L 的大写字母构成的字符串 C，满足对于每对索引 i,j（1≤i≤j≤L，索引编号 1∼L），位置 i 处的字符均小于位置 j 处的字符，则该字符串是严格递增的。
>
> 例如，字符串 `ABC` 和 `ADF` 是严格递增的，而字符串 `ACC` 和 `FDA` 则不是。
>
> 在教给你这个关于字符串的新性质后，他打算考一考你：
>
> 给定一个长度为 N 的字符串 S，请你计算对于每个位置 i（1≤i≤N），以该位置结束的最长严格递增子串的长度是多少？

求的是以当前字符为结尾的最长递增子串，那么以第一个字符结束的最长子串长度只能是 1。

暴力解法就是从当前字符往前遍历，计算有多少个满足严格递增的字符。

然而，可以发现，当前位置的最长严格递增子串长度是直接由上一个位置的长度加 1 来的，所以可以直接使用前缀和而不用再遍历。

**C代码**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int t = 0, cases = 0;
    scanf("%d", &t);
    for (cases = 1; cases <= t; cases++) {
        int n = 0;
        scanf("%d", &n);
        char* s = (char*)malloc(sizeof(char) * (n+1));
        scanf("%s", s);
        int res[n];
        res[0] = 1;
        for (int i = 1; i < n; i++) {
            res[i] = 1;
            if (s[i] > s[i-1])
                res[i] += res[i-1];
        }
        printf("Case #%d: ", cases);
        for (int i = 0; i < n; i++) {
            printf("%d ", res[i]);
        }
        printf("\n");
    }
    return 0;
}
```



<span id=字符串5>[Kick_Start](https://www.acwing.com/problem/content/description/3328/)</span>

>Ksenia 非常喜欢读书，因此每天她都会从自己最喜欢的书中选取一段内容进行阅读，然后再开始她早晨的其他活动。
>
>一段内容可以看作是整个文本中的一个子字符串。
>
>Ksenia 有点迷信，她坚信如果阅读的这段内容是以字符串 `KICK` 开头，然后中间包含 0 个或更多个字符，最后以字符串 `START` 结尾，即使这段内容没什么意义，她的一天也会非常的幸运。
>
>给定这本书的全部文本内容，请你数一数在这本书变得破旧不堪，Ksenia 不得不再买新书之前，共有多少个幸运片段可供她阅读。
>
>只要两个片段的起始位置或结束位置不同，就认为这两个片段是不同的，即使它们包含的内容完全相同。
>
>还需注意，不同片段之间可能会有重叠部分。

第一想法：分别记录下每个 KICK 和 START 的起始下标，然后一个 KICK 可以对应其之后的所有 START，只需遍历判断每个 KICK 的下标之后有多少个 START 即可，累加上就是答案。

换个思路也可以这样，统计每个 START 前的 KICK 的数目，当碰到 START 时，答案就累加上其前面的 KICK 数目。

**Java代码**

```java
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(in.readLine());
        for (int cases = 1; cases <= t; cases++) {
            String s = in.readLine();
            int res = 0;
            int len = s.length();
            int k = 0;
            for (int i = 0; i < len-4; i++) {
                if (s.substring(i, i+4).equals("KICK")) {
                    k++;
                    i += 2;
                }
                else if (i+5 <= len && s.substring(i, i+5).equals("START")) {
                    res += k;
                    i += 3;
                }
            }
            System.out.println("Case #" + cases + ": " + res);
        }
    }
}
```









### 模拟

<span id=模拟1>[无限区域](https://www.acwing.com/problem/content/4446/)</span>

> 给定一个无限大的二维平面，设点 S 为该平面的中心点。
>
> 设经过点 S 的垂直方向的直线为 P，如果直线 P 是一个圆的切线，且切点恰好为点 S，那么：
>
> - 如果该圆位于直线 P 的右侧，则称之为右圆。
> - 如果该圆位于直线 P 的左侧，则称之为左圆。
>
> 现在，给定三个整数 R,A,B，你需要按照右圆、左圆、右圆、左圆…的顺序不断画圆，具体要求如下：
>
> - 第一个右圆的半径等于 R。
> - 每个左圆的半径等于你画的**上一个圆**的半径乘以 A。
> - 每个右圆（第一个除外）的半径等于你画的**上一个圆**的半径除以 B（向下取整）。
> - 当你要画的圆的半径等于 0 时，绘画停止。
>
> ![InfinityAreaImage.png](https://cdn.acwing.com/media/article/image/2022/05/09/19_51ca0c24cf-InfinityAreaImage.png)
>
> 请你计算，所有画出的圆的面积之和。
>
> 保证绘画会在有限数量的步骤后停止。

直接模拟 R 的变化即可。

**Java代码**

```java
import java.util.*;
public class Main{
    static double PI = 3.1415926;
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        for (int i = 1; i <= t; i++) {
            int r = sc.nextInt();
            int a = sc.nextInt();
            int b = sc.nextInt();
            double s = PI * r * r;
            boolean f = false;
            while (r != 0) {
                if (!f) {
                    f = true;
                    r *= a;
                }
                else {
                    f = false;
                    r /= b;
                }
                s += PI * r * r;
            }
            System.out.println("Case #" + i + ": " + s);
        }
    }
}
```



<span id=模拟2>[狗和猫](https://www.acwing.com/problem/content/description/4121/)</span>

> 你在动物收容所工作，负责喂养动物。
>
> 你一共准备了 D 份狗粮和 C 份猫粮。
>
> 一共有 N 只动物排队等候用餐，有的是狗，有的是猫。
>
> 当然，也有可能全都是狗或者全都是猫。
>
> 我们可以用一个长度为 N 的由大写字母 C 和 D 组成的字符串 S 来表示队列中猫狗的顺序。
>
> 如果队列中第 i 只动物是猫，则第 i 个字符为 C。
>
> 如果队列中第 i 只动物是狗，则第 i 个字符为 D。
>
> 动物们严格按照排队顺序依次进食。
>
> 每只狗吃一份狗粮，每只猫吃一份猫粮。
>
> 此外，你还有额外的猫粮。
>
> 每当一条狗吃完一份狗粮，你就会为猫多提供 M 份猫粮。
>
> 每只动物都只会在排在其前面的所有动物都进食完毕后，才肯进食。
>
> 这也就意味着，当轮到某只动物进食，但是却没有相应的食物时，它和排在它后面的所有动物都会因此无法进食。
>
> 请问，在这种情况下，队列中的**所有狗**能否都得到喂食。

模拟进食的过程，遍历字符串，碰到 D 字符就将狗粮减一，且将猫粮加 M；碰到 C 字符就将猫粮减一。

同时要判断猫粮狗粮的数量是否为 0，

+ 当狗粮的数量为 0 后，就需判断剩下未遍历的字符中是否还有 D，有则 NO，无则 YES。
+ 当猫粮的数量为 0 后且碰到 C 字符，也需要判断剩下字符中是否存在 D，因为当前的 C 已经过不去了。

如果能将所有的字符都遍历到，那说明能喂完所有的狗。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int cases = 1; cases <= T; cases++) {
            int n = sc.nextInt();  // 猫狗总数
            int d = sc.nextInt();  // 狗粮
            int c = sc.nextInt();  // 猫粮
            int m = sc.nextInt();  // 猫粮增量
            char[] s = sc.next().toCharArray();
            int f = 0;
            while (f != n && d != 0) {
                if (s[f++] == 'D') {
                    d--;
                    c += m;
                } else if (c != 0) {
                    c--;
                } else if (c == 0)
                    break;
            }
            String res = "YES";
            while (f != n) {
                if (s[f++] == 'D') {
                    res = "NO";
                    break;
                }
            }
            System.out.println("Case #" + cases + ": " + res);
        }
    }
}
```

<span id=模拟3>[1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/description/)</span>

> 有一堆石头，每块石头的重量都是正整数。
>
> 每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：
>
> - 如果 `x == y`，那么两块石头都会被完全粉碎；
> - 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。
>
> 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。

模拟碎石的过程，每次将石头的重量排序，粉碎掉最大和次大的石头，然后将最大的石头剩下的放在次大的位置，进行下一次排序。

**Java代码**

```java
class Solution {
    public int lastStoneWeight(int[] stones) {
        int n = stones.length;
        while (n > 1) {
            bubbleSort(stones, n);
            stones[n-2] = stones[n-1] - stones[n-2];
            n--;
        }
        return stones[0];
    }
    public void bubbleSort(int[] nums, int n) {
        for (int i = n-1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (nums[j] > nums[j+1]) {
                    int t = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = t;
                }
            }
        }
    }
}
```







### 贪心

<span id=贪心3>[1253. 重构 2 行二进制矩阵](https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/description/)</span>

>给你一个 `2` 行 `n` 列的二进制数组：
>
>- 矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 `0` 就是 `1`。
>- 第 `0` 行的元素之和为 `upper`。
>- 第 `1` 行的元素之和为 `lower`。
>- 第 `i` 列（从 `0` 开始编号）的元素之和为 `colsum[i]`，`colsum` 是一个长度为 `n` 的整数数组。
>
>你需要利用 `upper`，`lower` 和 `colsum` 来重构这个矩阵，并以二维整数数组的形式返回它。
>
>如果有多个不同的答案，那么任意一个都可以通过本题。
>
>如果不存在符合要求的答案，就请返回一个空的二维数组。

先考虑到上下两行都有 1 的情况，也就是 colsum 中等于 2 的位置。使用一个变量 numOfTwo 记录下来又多少个这样的位置，然后和 upper、lower 中的最小值进行比较：

+ 如果 numOfTwo 大于 min(upper, lower)，那么不能构成一个满足要求的二维数组

在统计 2 的同时，用一个 sum 来记录二进制数组中总共的 1 的个数，再和 upper、lower 的和进行比较：

+ 如果 sum 不等于 upper + lower，那么不能构成一个满足要求的二维数组

之后用 upper、lower 减去 numOfTwo， 再根据 colsum 的内容来构造二维数组。

**Java代码**

```java
class Solution {
    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> l1 = new ArrayList<>();
        List<Integer> l2 = new ArrayList<>();
        int sum = 0, numOfTwo = 0;
        for (int i = 0; i < colsum.length; i++) {
            if (colsum[i] == 2)
                numOfTwo++;
            sum += colsum[i];
        }
        if (upper + lower != sum || Math.min(upper, lower) < numOfTwo)
            return res;
        upper -= numOfTwo;
        lower -= numOfTwo;
        for (int i = 0; i < colsum.length; i++) {
            if (colsum[i] == 2) {
                l1.add(1);
                l2.add(1);
            } else if (colsum[i] == 1) {
                if (upper != 0) {
                    l1.add(1);
                    l2.add(0);
                    upper--;
                } else if (lower != 0) {
                    l1.add(0);
                    l2.add(1);
                    lower--;
                }
            } else {
                l1.add(0);
                l2.add(0);
            }
        }
        res.add(l1);
        res.add(l2);
        return res;
    }
}
```



<span id=贪心4>[2600. K 件物品的最大和](https://leetcode.cn/problems/k-items-with-the-maximum-sum/description/)</span>

> 袋子中装有一些物品，每个物品上都标记着数字 `1` 、`0` 或 `-1` 。
>
> 给你四个非负整数 `numOnes` 、`numZeros` 、`numNegOnes` 和 `k` 。
>
> 袋子最初包含：
>
> - `numOnes` 件标记为 `1` 的物品。
> - `numZeroes` 件标记为 `0` 的物品。
> - `numNegOnes` 件标记为 `-1` 的物品。
>
> 现计划从这些物品中恰好选出 `k` 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。

当 k 小于等于 numOnes 时，最大值就是 k 的值；

当 k 大于 numOnes 且小于 numOnes+numZeroes 时，最大值就是 numOnes 的值；

否则，最大值就是 numOnes 减去 k-numOnes-numZeroes（即为剩下的-1的个数）。

**Java代码**

```java
class Solution {
    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        if (k <= numOnes)
            return k;
        else if (k <= numOnes + numZeros)
            return numOnes;
        else 
            return numOnes - (k - numOnes - numZeros);
    }
}
```





### 数列

<span id=数列1>[2485. 找出中枢整数](https://leetcode.cn/problems/find-the-pivot-integer/description/)</span>

> 给你一个正整数 `n` ，找出满足下述条件的 **中枢整数** `x` ：
>
> - `1` 和 `x` 之间的所有元素之和等于 `x` 和 `n` 之间所有元素之和。
>
> 返回中枢整数 `x` 。如果不存在中枢整数，则返回 `-1` 。题目保证对于给定的输入，至多存在一个中枢整数。

这是一个首项为 1，公差为 1 ，项数为 n 的等差数列，而 1 到 x 和 x 到 n 也分别是两个等差数列，于是该题就是求一个 x 使`[1, x]` 和 `[x. n]` 这两等差数列的前 n 项和相等。

等差数列的求和公式：$Sn = \frac{n(a1+an)}{2}$ 

所以有：

$S(1,x)=S(x,n)$ 

$\frac{x(1+x)}{2}=\frac{(n-x+1)(x+n)}{2}$ 

$x=\sqrt{\frac{n^2+n}{2}}$

所以求出 $\frac{n^2+n}{2}$ 的平方根，判断这个根的平方是否等于它，是则返回，否则返回 -1。

**Java代码**

```java
class Solution {
    public int pivotInteger(int n) {
        int sum = (n * n + n) / 2;
        int x = (int)Math.sqrt(sum);
        if (x * x == sum)
            return x;
        return -1;
    }
}
```





### DP

<span id = DP1>[329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/)</span>

> 给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。
>
> 对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。
>
> **示例 1：**
>
> ![image-20230624132652262](https://gitee.com/LowProfile666/image-bed/raw/master/img/image-20230624132652262.png)
>
> ```
> 输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
> 输出：4 
> 解释：最长递增路径为 [1, 2, 6, 9]。
> ```

该题可以使用动态规划，用 `dp[i][j]` 来表示以 (i, j) 这个点为终点的最长递增路径长度，那么 `dp[i][j]` 就是由 (i, j) 的四周的点的最长递增路径中的最大值加 1 来的，也就是：$dp[i][j] = max(dp[i-1][j],dp[i][j-1],dp[i][j+1],dp[i+1][j])+1$ 。

Java代码

```java
class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int res = 0;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dp[i][j] == 0) {
                    dp[i][j] = dfs(matrix, m, n, i, j, dp);
                }
                res = res > dp[i][j] ? res : dp[i][j];
            }
        }
        return res;
    }
    int[][] dir = {
        {-1, 0}, {1, 0}, {0, -1}, {0, 1}
    };
    public int dfs(int[][] a, int m, int n, int x, int y, int[][] dp) {
        int res = 1;
        for (int i = 0; i < 4; i++) {
            int tx = x + dir[i][0];
            int ty = y + dir[i][1];
            if (tx < 0 || tx >= m || ty < 0 || ty >= n)
                continue;
            if (a[x][y] > a[tx][ty]) {
                if (dp[tx][ty] == 0)
                    dp[tx][ty] = dfs(a, m, n, tx, ty, dp);
                dp[x][y] = dp[tx][ty] + 1;
                res = Math.max(res, dp[x][y]);
            }
        }
        return res;
    }
}
```

<span id = DP2>[LCP 07. 传递信息](https://leetcode.cn/problems/chuan-di-xin-xi/description/)</span>

> 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
>
> 1. 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
> 2. 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
> 3. 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
>
> 给定总玩家数 `n`，以及按 `[玩家编号,对应可传递玩家编号]` 关系组成的二维数组 `relation`。返回信息从小 A (编号 0 ) 经过 `k` 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
>
> **示例 1：**
>
> > 输入：`n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3`
> >
> > 输出：`3`
> >
> > 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。

该题可以将 relation 数组中的关系看作是一个有向图，那么可以使用一个邻接矩阵 mat 来表示每个点之间的边，使用动态规划，用数组 dp 表示每一轮到每个点的方案数，`dp[i][j]` 表示第 i 轮到 j 这个点的方案数，`dp[i][j]` 是由上一轮（i-1轮）某些点的方案数加起来的。

Java代码

```java
class Solution {
    public int numWays(int n, int[][] relation, int k) {

        int[][] mat = new int[10][10];  
        int[][] dp = new int[6][10];  // dp[i][j] 表示第 i 轮传到 j 这个点的方案数
        for (int[] r : relation) {
            mat[r[0]][r[1]] = 1;
        }
        dp[0][0] = 1;
        for (int i = 1; i <= k; i++) {  // 第 i 轮
            for (int j = 0; j < n; j++) {  // 终点
                for (int f = 0; f < n; f++) {  // 起点
                    if (mat[f][j] == 1)
                        dp[i][j] += dp[i-1][f];
                }
            }
        }
        return dp[k][n-1];
    }
}
```



### DFS && BFS

<span id = DFS&&BFS1>[547. 省份数量](https://leetcode.cn/problems/number-of-provinces/description/)</span>

> 有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。
>
> **省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
>
> 给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。
>
> 返回矩阵中 **省份** 的数量。
>
> **示例 1：**
>
> ![img](https://gitee.com/LowProfile666/image-bed/raw/master/img/graph1.jpg)
>
> ```
> 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
> 输出：2
> ```

该题和正常的图的邻接矩阵有点差别。

使用深度优先搜索的方法，遍历每一个城市节点，同时使用一个标记数组来标记哪些节点是访问过的，再遍历和当前城市直接联系的城市。

Java代码

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;  // 城市总数
        int res = 0;  // 省份数量
        boolean[] f = new boolean[n];
        for (int i = 0; i < n; i++) {
            if (!f[i]) {
                dfs(isConnected, i, n, f);
                res++;
            }
        }
        return res;
    }
    public void dfs(int[][] a, int i, int n, boolean[] f) {
        f[i] = true;
        for (int j = 0; j < n; j++) {
            if (a[i][j] == 1 && !f[j])  // 遍历每一个直接联系的城市
                dfs(a, j, n, f);
        }
    }
}
```

<span id=DFS&&BFS2>[841.钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/description/)</span>

> 有 `n` 个房间，房间按从 `0` 到 `n - 1` 编号。最初，除 `0` 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。
>
> 当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。
>
> 给你一个数组 `rooms` 其中 `rooms[i]` 是你进入 `i` 号房间可以获得的钥匙集合。如果能进入 **所有** 房间返回 `true`，否则返回 `false`。

rooms 其实就是一个邻接链表，rooms[i] 里的值就是 i 能访问到的点。

使用一个标记数组 f 来记录每个点是否被访问过了，在使用深度优先搜索从 room[0] 开始访问每个可以访问的节点，最后遍历标记数组，如果有没访问到的点就返回 false。

**Java代码**

```java
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        boolean[] f = new boolean[n];
        dfs(0, rooms, f);
        for (int i = 0; i < f.length; i++)
            if (!f[i])
                return false;
        return true;
    }
    public void dfs(int cur, List<List<Integer>> rooms, boolean[] f) {
        if (f[cur])
            return;
        f[cur] = true;
        for (int i = 0; i < rooms.get(cur).size(); i++) {
            dfs(rooms.get(cur).get(i), rooms, f);
        }
    }
}
```

<span id = DFS&&BFS3>[面试题 04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/description/)</span>

> 节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

使用邻接表和广度优先遍历。

先将有向图转换成邻接表，然后遍历以起点为头的邻接表，判断是否能到目标点。

**Java代码**

```java
class Solution {
    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {
        List<List<Integer>> list = new ArrayList<>();
        // 用 list 构建邻接表
        for (int i = 0; i < graph.length; i++)
            list.add(new ArrayList<>());
        for (int i = 0; i < graph.length; i++) {
            int a = graph[i][0];
            int b = graph[i][1];
            if (a == start && b == target)
                return true;
            list.get(a).add(b);
        }
        boolean[] f = new boolean[n];
        // 用队列实现 BFS
        Queue<Integer> q = new LinkedList<>();
        q.offer(start);
        f[start] = true;
        while (!q.isEmpty()) {
            int cur = q.poll();
            List<Integer> t = list.get(cur);
            for (int i = 0; i < t.size(); i++) {
                int nex = t.get(i);
                if (!f[nex]) {
                    q.offer(nex);
                    f[nex] = true;
                    if (nex == target)
                    	return true;
                }
            }
        }
        return false;
    }
}
```





### 二叉树

<span id = "二叉树1">[面试题 04.03. 特定深度节点链表](https://leetcode.cn/problems/list-of-depth-lcci/description/)</span>

> 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 `D`，则会创建出 `D` 个链表）。返回一个包含所有深度的链表的数组。
>
> 示例：
>
> ```
> 输入：[1,2,3,4,5,null,7,8]
> 
>         1
>        /  \ 
>       2    3
>      / \    \ 
>     4   5    7
>    /
>   8
> 
> 输出：[[1],[2,3],[4,5,7],[8]]
> ```

该题可以使用层次遍历，记录下每个节点以及它的层数，然后根据层数装入数组，最后返回数组。

**Java代码**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
 class Node{
     TreeNode node;
     int high;
     public Node(TreeNode node, int high) {
         this.node = node;
         this.high = high;
     }
 }
class Solution {
    public ListNode[] listOfDepth(TreeNode tree) {
        if (tree == null)
            return null;
        Node[] q = new Node[10000];
        int f = 0, r = 0;
        q[r++] = new Node(tree, 1);
        while (f < r) {
            TreeNode cur = q[f].node;
            if (cur.left != null) {
                q[r++] = new Node(cur.left, q[f].high+1);
            }
            if (cur.right != null) {
                q[r++] = new Node(cur.right, q[f].high+1);
            }
            f++;
        }
        ListNode[] res = new ListNode[q[r-1].high];
        int top = 0;
        int preHigh = 1;
        for (int i = 0; i < r; i++) {
            ListNode t = new ListNode(q[i].node.val);
            ListNode t1 = t;
            while (i < r-1 && q[i].high == q[i+1].high) {
                ListNode t2 = new ListNode(q[i+1].node.val);
                t1.next = t2;
                t2.next = null;
                t1 = t2;
                i++;
            }
            res[top++] = t;
        }
        return res;
    }
}
```

<span id = "二叉树2">[\654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/description/)</span>

> 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:
>
> 1. 创建一个根节点，其值为 `nums` 中的最大值。
> 2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
> 3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。
>
> 返回 *`nums` 构建的* ***最大二叉树\*** 。

根据题意模拟，先找出数组最大值，以该最大值为当前节点的值，该最大值的下标为左右子树分界点，然后以相同的规则递归。

**Java代码**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode res = new TreeNode();
        int maxIdx = getMaxIdx(nums, 0, nums.length-1);
        res.val = nums[maxIdx];
        res.left = construct(res, nums, 0, maxIdx-1);
        res.right = construct(res, nums, maxIdx+1, nums.length-1);
        return res;
    }
    public int getMaxIdx(int[] nums, int l, int r) {
        if (l > r)
            return -1;
        int max = nums[l], maxIdx = l;
        while (l <= r) {
            if (max < nums[l]) {
                max = nums[l];
                maxIdx = l;
            }
            ++l;
        }
        return maxIdx;
    }
    public TreeNode construct(TreeNode root, int[] nums, int l, int r) {
        int maxIdx = getMaxIdx(nums, l, r);
        if (maxIdx == -1)
            return null;
        root = new TreeNode(nums[maxIdx]);
        root.left = construct(root, nums, l, maxIdx-1);
        root.right = construct(root, nums, maxIdx+1, r);
        return root;
    }
}
```

<span id = "二叉树3">[\113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/description/)</span>

> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> **叶子节点** 是指没有子节点的节点。

该题需要使用先序遍历和栈，将遍历路上的节点值存入栈中，同时维护一个变量 sum 累加路径节点的值，当碰到叶子节点时判断 sum 是否和 target 相等。

**Java代码**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<List<Integer>> ans;
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        ans = new ArrayList<>();
        int[] nodes = new int[5000];
        preOrder(root, targetSum, 0, nodes, 0);
        return ans;
    }
    public void preOrder(TreeNode root, int targetSum, int curSum, int[] nodes, int top) {
        if (root == null)
            return;
        curSum += root.val;
        nodes[top++] = root.val;
        if (root.left == null && root.right == null) {
            if (curSum == targetSum) {
                List<Integer> temp = new ArrayList<>();
                for (int i = 0; i < top; i++)
                    temp.add(nodes[i]);
                ans.add(temp);
            }
            return;
        }
        preOrder(root.left, targetSum, curSum, nodes, top);
        preOrder(root.right, targetSum, curSum, nodes, top);
    }
}
```

<span id = "二叉树4">[\1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/description/)</span>

> 给你一棵根为 `root` 的二叉树，请你返回二叉树中好节点的数目。
>
> 「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。

该题的意思就是，记录从根到当前节点上，当前节点的值最大时的节点个数，所以使用一个变量 max 记录路径上的最大值，当碰到节点值大于等于 max 时，答案就加一。

**Java代码**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans;
    public int goodNodes(TreeNode root) {
        ans = 0;
        preOrder(root, root.val);
        return ans;
    }
    public void preOrder(TreeNode root, int max) {
        if (root == null)
            return;
        if (root.val >= max) {
            ans++;
            max = root.val;
        }
        preOrder(root.left, max);
        preOrder(root.right, max);
    }
}
```

