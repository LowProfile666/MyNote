基于浏览器的 B/S 结构应用十分流行。Spring Boot 非常适合 Web 应用开发。可以使用嵌入式 Tomcat、Jetty、Undertow 或 Netty 创建一个自包含的 HTTP 服务器。一个 Spring Boot 的 Web 应用能够自己独立运行，不依赖需要安装的 Tomcat，Jetty 等。

Spring Boot 可以创建两种类型的 Web 应用

+ 基于 Servlet 体系的 Spring Web MVC 应用
+ 使用 spring-boot-starter-webflux 模块来构建响应式，非阻塞的 Web 应用程序

这里学习Spring Web MVC，又被称为“Spring MVC”。Spring MVC 是“model view controller”的框架。专注 web 应用开发。我们快速的创建控制器（Controller），接受来自浏览器或其他客户端的请求。并将业务代码的处理结果返回给请求方。

Spring MVC 处理请求：

![image-20240707165448934](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071654991.png)

# 高效构建 Web 应用

创建 Web 应用，依赖选择 spring-web 包含了 Spring MVC , Restful, Tomcat, jackson 这些功能。再选择 Thymeleaf（视图技术，代替 jsp）,Lombok 依赖。

## HTML页面视图

创建一个controller包，包下创建一个WebController类：

```java
@Controller
public class WebController {
    @RequestMapping("/index")
    public String index(ModelMap modelMap) {
        modelMap.put("username", "占山");
        modelMap.put("password", "123456");

        return "index";
    }
}
```

+ @Controller：创建控制器对象，控制器能够接收请求，响应结果给浏览器，控制器也叫做处理器
+ 控制器中的方法是控制器方法
+ ModelMap表示模型，存储数，这个数据是存储在request域中的
+ return返回的是一个视图的名称

接下来编写视图，因为使用的是Thymeleaf视图引擎，所以要求视图文件放在resources下的templates目录之下，视图文件就是一个html文件，创建一个index.html：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>主页</title>
</head>
<body>
<h1 th:text="${username}"></h1>
<h1 th:text="${password}"></h1>
</body>
</html>
```

+ index这个名字和控制器返回的视图名字一样，就能正确显示该页面。

运行项目：

![image-20240707171717729](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071717772.png)

发送请求：http://localhost:8080/index：

![image-20240707171804361](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071718391.png)

## JSON视图

上面的例子以 Html 文件作为视图，可以编写复杂的交互的页面，CSS 美化数据。除了带有页面的数据，还有一种只需要数据的视图。比如手机应用 app，app 的数据来自服务器应用处理结果。app 内的数据显示和服务器无关，只需要数据就可以了。主流方式是服务器返回 json 格式数据给手机 app 应用。我们可以通过原始的HttpServletResponse 应该数据给请求方。 借助 Spring MVC 能够无感知的处理 json。

![image-20240707173357259](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071733296.png)

重新创建一个controller方法用来响应json数据：

```java
@RequestMapping("/json")
public void getJson(HttpServletResponse response) throws IOException {
    String json = """
    {
        "username":"zsm",
        "password":"123"
    }
    """;
    PrintWriter out = response.getWriter();
    out.print(json);
    out.flush();
    out.close();
}
```

启动项目，访问http://localhost:8080/json：

![image-20240707172457742](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071724770.png)

SpringMVC支持控制器方法返回一个Java对象，由框架使用jackson将这个对象转为json格式的字符串并输出给浏览器。

创建一个实体类：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private String username;
    private String password;
}
```

然后重新编写一个控制器方法返回一个User对象：

```java
@RequestMapping("/getUserInfo")
@ResponseBody
public User getUserInfo() {
    User user = new User("张仕茂", "hhhhhhh");
    return user;
}
```

+ @ResponseBody这个注解可以运用HttpServletResponse对象将对象输出

启动项目，访问http://localhost:8080/getUserInfo：

![image-20240707173058503](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071730537.png)

## 给项目加 favicon

favicon.ico 是网站的缩略标志,可以显示在浏览器标签、地址栏左边和收藏夹,是展示网站个性的 logo 标志。

我们自己的网站定制 logo。首先找一个在线工具创建 favicon.ico。比如 https://quanxin.org/favicon ， 用文字，图片生成我们需要的内容。生成的 logo 文件名称是 favicon.ico

将生成的 favicon.ico 拷贝项目的 resources/static/ 目录，然后在你的视图文件，加入对 favicon.ico 的引用：

```html
<link rel="icon" href="../favicon.ico" type="image/x-icon">
```

效果：

![image-20240707174222441](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071742473.png)



# Spring MVC

Spring MVC 是非常著名的 Web 应用框架，现在的大多数 Web 项目都采用 Spring MVC。它与 Spring 有着紧密的关系。是 Spring 框架中的模块，专注 Web 应用，能够使用 Spring 提供的强大功能，IoC , Aop 等等.

Spring MVC 框架是底层是基于 Servlet 技术。遵循 Servlet 规范，Web 组件 Servlet，Filter，Listener 在 SpringMVC中都能使用。同时 Spring MVC 也是基于 MVC 架构模式的，职责分离，每个组件只负责自己的功能，组件解耦。

Spring Boot 的自动配置、按约定编程极大简化、提高了 Web 应用的开发效率。

## 控制器Controller

控制器是一种有 Spring 管理的 Bean 对象，赋予角色是“控制器”。作用是处理请求，接收浏览器发送过来的参数，将数据和视图应答给浏览器或者客户端 app 等。

控制器是一个普通的 Bean，使用@Controller 或者@RestController 注释。@Controller 是 @Component 的别名， 所以他就是一个 Bean 对象。

如何创建控制器类对象？

+ 创建普通 Java 类，其中定义 public 方法。类上注解@Controller 或者@RestController。

控制器类中的方法作用：

+ Controller 类中的方法处理对应 uri 的请求， 一个（或多个）uri 请求交给一个方法处理。
+ 就是一个普通的方法，方有参数、返回值。方法上面加@RequestMapping("uri")注解，说明这个 uri 由这个方法处理。

![image-20240707192749068](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071928058.png)

@Controller 和 @RestController 的区别：

+ @RestController 包含了 @Controller的所有功能，同时加入了@ResponseBody的功能，表示当前类中的所有方法，都会通过HttpServletResponse输出数据到浏览器，而不会返回一个视图页面。

### 匹配请求路径到控制器方法

SpringMVC 支持多种策略，匹配请求路径到控制器方法：AntPathMatcher 、 PathPatternParser

![image-20240707212828343](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407072128413.png)

从 SpringBoot3 推荐使用 PathPatternParser 策略。比之前 AntPathMatcher 提升 6-8 倍吞吐量。

PathPatternParser 中有关 uri 的定义：

**通配符**

+ `?` : 一个字符
+ `*`： 0 或多个字符。在一个路径段中匹配字符，比如：/web/index，web 和 index 都是一个路径段
+ `**`：匹配 0 个或多个路径段，相当于是所有

**正则表达式**： 支持正则表达式

**RESTFul 的支持路径变量**：`{变量名}`

例子：

`?`：

```java
@GetMapping("/file/t?st.html")
？匹配只有一个字符
√ GET http://localhost:8080/file/test.html
× GET http://localhost:8080/file/teest.html

@GetMapping("/file/t?st.html")
public String path1(HttpServletRequest request){
	return "path 请求="+request.getRequestURI();
}
```

`*`：

```java
@GetMapping ("/images/*.gif")
*：匹配一个路径段中的 0 或多个字符
√ GET http://localhost:8080/images/user.gif
√ GET http://localhost:8080/images/cat.gif
√ GET http://localhost:8080/images/.gif
× GET http://localhost:8080/images/gif/header.gif
× GET http://localhost:8080/images/dog.jpg

@GetMapping ("/images/*.gif")
public String path2(HttpServletRequest request){
	return "* 请求="+request.getRequestURI();
}
```

`**`：

```java
@GetMapping ("/pic/**")
** 匹配 0 或多段路径， 匹配/pic 开始的所有请求
√ GET http://localhost:8080/pic/p1.gif
√ GET http://localhost:8080/pic/20222/p1.gif
√ GET http://localhost:8080/pic/user
√ GET http://localhost:8080/pic/

@GetMapping ("/pic/**")
public String path3(HttpServletRequest request){
	return "/pic/**请求="+request.getRequestURI();
}
```

RESTFul：

```java
@GetMapping("/order/{*id}")
{*id} 匹配 /order 开始的所有请求， id 表示 order 后面直到路径末尾的所有内容。
id 自定义路径变量名称。与@PathVariable 一样使用
√ GET http://localhost:8080/order/1001
√ GET http://localhost:8080/order/1001/2023-02-16

@GetMapping("/order/{*id}")
public String path4(@PathVariable("id") String orderId, HttpServletRequest request){
	return "/order/{*id}请求="+request.getRequestURI() + "，id="+orderId;
}
注意：@GetMapping("/order/{*id}/{*date}")无效的， {*..}后面不能在有匹配规则了
```

正则：

```java
@GetMapping("/pages/{fname:\\w+}.log")
:\\w+ 正则匹配， xxx.log
√ GET http://localhost:8080/pages/req.log
√ GET http://localhost:8080/pages/111.log
× GET http://localhost:8080/pages/req.txt
× GET http://localhost:8080/pages/###.log

@GetMapping("/pages/{fname:\\w+}.log")
public String path5(@PathVariable("fname") String filename, HttpServletRequest
request){
	return "/pages/{fname:\\w}.log 请求="+request.getRequestURI() + "，filename="+filename;
}
```

测试这些接口时，可以使用IDEA中的HttpClient工具，打开方式：

![image-20240707214553035](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407072145088.png)

或者：

![image-20240707214615466](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407072146516.png)

也可以自己创建一个文件：

![image-20240707215056895](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407072150951.png)

在里面可以测试接口：

![image-20240707215152497](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407072151597.png)

### @RequestMapping

@RequestMapping：用于将 web 请求映射到控制器类的方法。此方法处理请求。可用在类上或方法上，在类和方法同时组合使用。

重要的属性

+ value：别名 path 表示请求的 uri， 在类和方法方法同时使用 value，方法上的继承类上的 value 值。
+ method：请求方式，支持 GET, POST, HEAD, OPTIONS, PUT, PATCH, DELETE, TRACE。值为：RequestMethod[] method()， RequestMethod 是 enum 类型。

快捷注解

+ @GetMapping: 表示 get 请求方式的@RequestMapping
+ @PostMapping:表示 post 请求方式的@RequestMapping
+ @PutMapping：表示 put 请求方式的@RequestMapping
+ @DeleteMapping: 表示 delete 请求方式的@RequestMapping

对于请求方式 get，post，put，delete 等，能够用 HttpMethod 类来表示，Spring Boot3 之前他是 enum，Spring Boot3 他是 class。

### 控制器方法参数类型与可用返回值类型

参数类型：

![image-20240707221046892](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407072210976.png)

完整版：https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-arguments
以上参数若是想要使用，可以直接在参数列表中声明即可。SpringMVC负责给这些参数赋值。

返回值：

![image-20240707221152806](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407072211876.png)

完整版：https://docs.spring.io/spring-framework/docs/current/reference/html/web.html#mvc-ann-return-types

### 接收请求参数

用户在浏览器中点击按钮时，会发送一个请求给服务器，其中包含让服务器程序需要做什么的参数。这些参数发送给控制器方法。控制器方法的形参列表接受请求参数。

接受参数方式：

- 请求参数与形参一一对应，适用简单类型。形参可以有合适的数据类型，比如 String，Integer ，int 等。
- 对象类型，控制器方法形参是对象，请求的多个参数名与属性名相对应。 
- @RequestParam 注解，将查询参数，form 表单数据解析到方法参数，解析 multipart 文件上传。
- @RequestBody，接受前端传递的 json 格式参数。
- HttpServletRequest 使用 request 对象接受参数， request.getParameter(“...”)
- @RequestHeader ,从请求 header 中获取某项值

解析参数需要的值，SpringMVC 中专门有个接口来干这个事情，这个接口就是：HandlerMethodArgumentResolver，中文称呼：处理器方法参数解析器，说白了就是解析请求得到 Controller 方法的参数的值。

#### 接收 json

使用@RequestBody注解，接收前端传过来的请求体数据。从请求体中读取json数据，将数据转为形参对象的属性值。

```java
@PostMapping("/param/json")
public String json(@RequestBody User user) {
    return user.toString();
}
```

前端请求：
```
POST http://localhost:8080/param/json
Content-Type: application/json

{"username": "zsm", "password": "1234"}
```

+ 前端的请求头中要指定提交的数据类型是一个json

注意：不加@RequestBody的时候，使用对象接收数据也是可以的，但是那是以表单的形式提交，以json格式提交的话就需要用@RequestBody来接收。

#### Reader-InputStream

Reader 或 InputStream 读取请求体的数据， 适合 post 请求体的各种数据。具有广泛性。

控制器方法：

```java
@PostMapping("/param/json2")
public String json2(Reader in) throws IOException {
    StringBuffer content = new StringBuffer();
    BufferedReader bin = new BufferedReader(in);
    var line = "";
    while ((line = bin.readLine()) != null) {
        content.append(line);
    }
    return content.toString();
}
```

前端发送请求：

```java
POST http://localhost:8080/param/json2
Content-Type: application/json

{"username": "zsm1111", "password": "1211134"}
```

结果：

```java
HTTP/1.1 200 
Content-Type: text/plain;charset=UTF-8
Content-Length: 46
Date: Sun, 07 Jul 2024 15:10:09 GMT
Keep-Alive: timeout=60
Connection: keep-alive

{"username": "zsm1111", "password": "1211134"}
```

#### 数组参数接收多个值

数组作为形参，接受多个参数值 ，请求格式 参数名=值 1&参数名=值 2...

控制器：

```java
@GetMapping("/param/arr")
public String arr(Integer[] id) {
    return Arrays.toString(id);
}
```

+ 也可以这样写：

  ```java
  @GetMapping("/param/arr")
  public String arr(Integer[] id) {
      return Arrays.stream(id).toList().toString();
  }
  ```

前端请求：

```java
GET http://localhost:8080/param/arr?id=1&id=2&id=4444
GET http://localhost:8080/param/arr?id=12,23,34,45,56,67
```

返回结果：

```java
[1, 2, 4444]
[12, 23, 34, 45, 56, 67]
```

### 验证参数

服务器端程序，Controller 在方法接受了参数，这些参数是由用户提供的，使用之前必须校验参数是我们需要的吗，值是否在允许的范围内，是否符合业务的要求。比如年龄不能是负数，姓名不能是空字符串，email 必须有@符号，phone 国内的 11 位才可以。

验证参数

+ 编写代码，手工验证，主要是 if 语句，switch 等等。
+ Java Bean Validation : JSR-303 是 JAVA EE 6 中的一项子规范，叫做 Bean Validation, 是一个运行时的数据验证规范，为 JavaBean 验证定义了相应的元数据模型和 API。

#### Java Bean Validation

Spring Boot 使用 Java Bean Validation 验证域模型属性值是否符合预期，如果验证失败，立即返回错误信息。Java Bean Validation 将验证规则从 controller，service 集中到 Bean 对象。一个地方控制所有的验证。

Bean 的属性上，加入 JSR-303 的注解，实现验证规则的定义。JSR-303 是规范，hibernate-validator 是实现。

JSR-303: https://beanvalidation.org/

hibernate-validator：https://hibernate.org/validator/

#### JSR-303 注解

JSR-303 定义的常用注解：

![image-20240708073605369](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407080736523.png)

Hibernate 提供的部分注解：

![image-20240708073645196](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407080736260.png)

#### 快速上手

要使用Bean Validation，需要先加入一个依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

新建一个实体类Article，在属性上进行Bean验证：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Article {
    private Integer id;

    @NotNull(message = "作者不能为空")
    private Integer userId;

    @NotBlank(message = "标题不能为空")
    @Size(min = 3, max = 10, message = "标题最少3个字，最多10个字")
    private String title;

    @NotBlank(message = "摘要不能为空")
    @Size(min = 20, max = 200, message = "摘要字数必须在20到200之间")
    private String summary;

    @DecimalMin(value = "0", message = "阅读量最少为0")
    private Integer readCount;

    @Email(message = "邮箱格式不对")
    private String email;
}
```

+ @Size认为null也是有效值
+ 一个属性上可以使用多个注解

然后在controller中使用验证：

```java
@RestController
public class ArticleController {
    @PostMapping("/add")
    public Map<String, Object> addArticle(@Validated @RequestBody Article article, BindingResult br) {

        Map<String, Object> map = new HashMap<>();
        if (br.hasErrors()) {  // 有一项或多项bean的属性验证没通过
            List<FieldError> fieldErrors = br.getFieldErrors();  // 获取没有通过的属性，FieldError封装了属性验证出错的信息
            for (int i = 0; i < fieldErrors.size(); i++) {
                // 将出错信息存到map，getField()拿到字段，getDefaultMessage()拿到属性上注解中的message
                FieldError fieldError = fieldErrors.get(i);
                map.put(fieldError.getField() + "-" + i, fieldError.getDefaultMessage());
            }
        }
        return map;
    }
}
```

+ @Validated：Spring中的一个注解，表示要验证bean
+ 验证bean错误后的结果在BindingResult里面

 测试：

```java
POST http://localhost:8080/add
Content-Type: application/json

{
  "id": 0,
  "userId": 0,
  "title": "title_24f7ebba0faf",
  "summary": "summary_a97bef23f9d9",
  "readCount": 0,
  "email": "email_de6daec5033c"
}
```

结果：

```java
{
  "email-0": "邮箱格式不对",
  "title-1": "标题最少3个字，最多10个字"
}
```

#### 分组验证

上面的 Ariticle 用来新增文章， 新的文章主键 id 是系统生成的。现在要修改文章，此时 id 必须有值，修改这个 id 的文章。新增和修改操作对 id 有不同的要求约束要求。通过 group 来区分是否验证。

group 是 Class 作为表示， java 中包加类一定是唯一的， 这个标识没有其他实际意义。

给Article实体类的id属性添上验证，使用分组：

```java
public class Article {

    public static interface EditArticleGroup{};
    public static interface AddArticleGroup{};

    @NotNull(message = "主键不能为空", groups = {EditArticleGroup.class})
    @Min(value = 1, message = "ID必须大于0", groups = {EditArticleGroup.class})
    private Integer id;

    @NotNull(message = "作者不能为空")
    private Integer userId;

    @NotBlank(message = "标题不能为空")
    @Size(min = 3, max = 10, message = "标题最少3个字，最多10个字")
    private String title;

    @NotBlank(message = "摘要不能为空")
    @Size(min = 20, max = 200, message = "摘要字数必须在20到200之间")
    private String summary;

    @DecimalMin(value = "0", message = "阅读量最少为0")
    private Integer readCount;

    @Email(message = "邮箱格式不对")
    private String email;
}
```

+ 只指定了id属性的组

现在有一个修改的控制器方法，需要在方法上指明是哪一组：

```java
@PostMapping("/edit")
public Map<String, Object> editArticle(@Validated(Article.EditArticleGroup.class) @RequestBody Article article, BindingResult br) {

    Map<String, Object> map = new HashMap<>();
    if (br.hasErrors()) {  // 有一项或多项bean的属性验证没通过
        List<FieldError> fieldErrors = br.getFieldErrors();  // 获取没有通过的属性，FieldError封装了属性验证出错的信息
        for (int i = 0; i < fieldErrors.size(); i++) {
            // 将出错信息存到map，getField()拿到字段，getDefaultMessage()拿到属性上注解中的message
            FieldError fieldError = fieldErrors.get(i);
            map.put(fieldError.getField() + "-" + i, fieldError.getDefaultMessage());
        }
    }
    return map;
}
```

+ @Validated(Article.EditArticleGroup.class)指定是哪一个组
+ 指定组后，如果实体类的属性没有指定的组的话，不会进行验证

测试：

```java
POST http://localhost:8080/edit
Content-Type: application/json

{}
```

+ 什么值都没有传，相当于所有属性都是空

结果：

```java
{
  "id-0": "主键不能为空"
}
```

+ 这是因为只有id属性加了组，其他属性没有组，而控制器方法上有限制了组，所以其他属性是不会验证的

现在给所有属性的分好组：

```java
public class Article {

    public static interface EditArticleGroup{};
    public static interface AddArticleGroup{};

    @NotNull(message = "主键不能为空", groups = {EditArticleGroup.class})
    @Min(value = 1, message = "ID必须大于0", groups = {EditArticleGroup.class})
    private Integer id;

    @NotNull(message = "作者不能为空", 
             groups = {EditArticleGroup.class, AddArticleGroup.class})
    private Integer userId;

    @NotBlank(message = "标题不能为空", 
              groups = {EditArticleGroup.class, AddArticleGroup.class})
    @Size(min = 3, max = 10, message = "标题最少3个字，最多10个字", 
          groups = {EditArticleGroup.class, AddArticleGroup.class})
    private String title;

    @NotBlank(message = "摘要不能为空", 
              groups = {EditArticleGroup.class, AddArticleGroup.class})
    @Size(min = 20, max = 200, message = "摘要字数必须在20到200之间", 
          groups = {EditArticleGroup.class, AddArticleGroup.class})
    private String summary;

    @DecimalMin(value = "0", message = "阅读量最少为0", 
                groups = {EditArticleGroup.class, AddArticleGroup.class})
    private Integer readCount;

    @Email(message = "邮箱格式不对", groups = {EditArticleGroup.class, AddArticleGroup.class})
    private String email;
}
```

所有的属性都会验证：

```java
{
  "id-3": "主键不能为空",
  "summary-0": "摘要不能为空",
  "userId-1": "作者不能为空",
  "title-2": "标题不能为空"
}
```

#### ValidationAutoConfiguration

验证也有一个自动配置类。

spring-boot-starter-validation 引入了 jakarta.validation:jakarta.validation-api:3.0.2 约束接口、org.hibernate.validator:hibernate-validator:8.0.0.Final 约束注解的功能实现。

ValidationAutoConfiguration 自动配置类，创建了 LocalValidatorFactoryBean 对象，当有 class 路径中有 hibernate.validator，能够创建 hiberate 的约束验证实现对象。

## 模型Model

在许多实际项目需求中，后台要从控制层直接返回前端所需的数据，这时 Model 大家族就派上用场了。

Model 是模型的意思，是Spring MVC 中的“M”，用来传输数据。从控制层直接返回数据给前端，配置 jsp，模板技术能够展现 M 中存储的数据。

Model 简单理解就是给前端浏览器的数据，放在 Model 中，ModelAndView 里的任意值，还有 json 格式的字符串等都是 Model。

## 视图 View

Spring MVC 中的 View（视图）用于展示数据的，视图技术的使用是可插拔的。无论您决定使用 thymleaf、jsp 还是其他技术，classpath 有 jar 就能使用视图了。开发者主要就是配置更改。Spring Boot3 不推荐 FreeMarker、jsp 这些了。页面的视图技术有Thymeleaf ， Groovy Templates。

org.springframework.web.servlet.View 是视图的接口，实现此接口的都是视图类，视图类作为 Bean 被 Spring 管理。当然这些不需要开发者编写代码。

+ ThymeleafView：使用 thymeleaf 视图技术的视图类。
+ InternalResourceView：表示 jsp 的视图类。

控制器方法返回值和视图是有关系的。

+ String：如果项目中有 thymeleaf ， 这个 String 表示 xxx.html 视图文件（/resources 目录），除非用了@ResponeBody , @RestController 注解
+ ModelAndView: View 中就是表示视图。

@ResponeBody , @RestController 适合前后端分离项目

+ String : 表示一个字符串数据
+ Object：如果有 Jackson 库，将 Objet 转为 json 字符串

### 页面视图

Thymeleaf 作为代替 jsp 的视图技术，可以编写页面，排列数据。

一个控制器方法：

```java
@RequestMapping("/index")
public ModelAndView index(ModelMap modelMap) {
    ModelAndView mv = new ModelAndView();
    mv.addObject("name","李四");
    mv.addObject("age",20);
    mv.setViewName("index");
    return mv;
}
```

需要一个视图页面文件，文件名是index，在resources下的templates下创建一个index.html文件：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>主页</title>
    <link rel="icon" href="../favicon_zsm.ico" type="image/x-icon">
</head>
<body>
<h1 th:text="${name}"></h1>
<h1 th:text="${age}"></h1>
</body>
</html>
```

然后运行项目，访问链接：http://localhost:8080/index

![image-20240708104740746](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081047878.png)

可以在application.properties中设置Thymeleaf的前缀和后缀

+ 前缀：视图文件存放位置
+ 后缀：视图文件扩展名

默认情况下是：

```properties
spring.thymeleaf.prefix=classpath:/templates/
spring.thymeleaf.suffix=.html
```

所以需要在resources目录下的templates下创建一个扩展名为.html的文件，文件名就是控制器方法返回的那个名字。

### JSON视图

简单的JSON视图就是返回一个json数据，在浏览器上显示json数据：

```java
@RequestMapping("/getUserInfo")
@ResponseBody
public User getUserInfo() {
    User user = new User("张仕茂", "hhhhhhh");
    return user;
}
```

![image-20240708105235641](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081052744.png)

### 复杂JSON视图

在一个类中定义其他多个引用类型，或集合类型。构成复杂 json。

添加一个Role类：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Role {
    private Integer id;
    private String name;
    private String desc;
}
```

User类中添加一个属性：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private String username;
    private String password;
    private Role role;
}
```

控制器方法：

```java
@RequestMapping("/getUserInfo")
@ResponseBody
public User getUserInfo() {
    Role role = new Role(1, "班长", "牛逼");
    User user = new User("张仕茂", "hhhhhhh", role);
    return user;
}
```

访问结果：

![image-20240708105604861](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081056965.png)

### ResponseEntity

ResponseEntity 包含 HttpStatus Code 和 应答数据的结合体。 因为用 Http Code能表达标准的语义， 200 成功， 404 没有发现等。

使用ResponseEntity作为返回结果：

```java
@RequestMapping("/getEntity")
@ResponseBody
public ResponseEntity<User> getEntity() {
    Role role = new Role(1, "班长", "牛逼");
    User user = new User("张仕茂", "hhhhhhh", role);
    ResponseEntity<User> response = new ResponseEntity<>(user, HttpStatus.OK);
    return response;
}
```

测试：

![image-20240708111605002](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081116136.png)

### Map 作为返回值

Map 作为返回值数据时，能够自动转为 json。

```java
RequestMapping("/map")
    @ResponseBody
    public Map<String, Object> map() {
    Map<String, Object> map = new HashMap<>();
    map.put("username", "zs");
    map.put("password", "123");
    return map;
}
```

![image-20240708111857869](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081118973.png)

# SpringMVC 请求流程

Spring MVC 框架是基于 Servlet 技术的。以请求为驱动，围绕 Servlet 设计的。 Spring MVC 处理用户请求与访问一个 Servlet 是类似的，请求发送给 Servlet，执行 doService 方法，最后响应结果给浏览器完成一次请求处理。

## DispatcherServlet 是一个 Servlet

DispatcherServlet 是核心对象，称为中央调度器（前端控制器 Front Controller）。负责接收所有对 Controller的请求，调用开发者的 Controller 处理业务逻辑，将 Controller 方法的返回值经过视图处理响应给浏览器。

DispatcherServlet 作为 SpringMVC 中的 C,职责：

1. 是一个门面，接收请求，控制请求的处理过程。所有请求都必须有 DispatcherServlet 控制。SpringMVC
   对外的入口。可以看做门面设计模式。

2. 访问其他的控制器。 这些控制器处理业务逻辑
3. 创建合适的视图，将 2 中得到业务结果放到视图，响应给用户。
4. 解耦了其他组件，所有组件只与 DispatcherServlet 交互。彼此之间没有关联
5. 实现 ApplictionContextAware, 每个 DispatcherServlet 都拥自己的 WebApplicationContext，它继承了ApplicationContext。WebApplicationContext 包含了 Web 相关的 Bean 对象，比如开发人员注释@Controller的类，视图解析器，视图对象等等。 DispatcherServlet 访问容器中 Bean 对象。
6. Servlet + Spring IoC 组合

DispatcherServlet 继承关系图：

![image-20240708112544165](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081125306.png)

## Spring MVC 的完整请求流程

![image-20240708134843480](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081349102.png)

+ 红色 DispatherServlet 是框架创建的核心对象（可配置它的属性 contextPath）
+ 蓝色的部分框架已经提供多个对象。开发人员可自定义，替换默认的对象。
+ 绿色的部分是开发人员自己创建的对象，控制器 Conroller 和视图对象。

流程说明：

1、DispatcherServlet 接收到客户端发送的请求。判断是普通请求，上传文件的请求。
2、DispatcherServlet 收到请求调用 HandlerMapping 处理器映射器。
3、HandleMapping 根据请求 URI 找到对应的控制器以及拦截器，组装成 HandlerExecutionChain 读写。将此对象返回给 DispatcherServlet，做下一步处理。
4、DispatcherServlet 调用 HanderAdapter 处理器适配器。这里是适配器设计模式，进行接口转换，将对一个接口调用转换为其他方法。
5、HandlerAdapter 根据执行控制器方法，也就是开发人员写的 Controller 类中的方法，并返回一个 ModeAndView
6、HandlerAdapter 返回 ModeAndView 给 DispatcherServlet
7、DispatcherServlet 调用 HandlerExceptionResolver 处理异常，有异常返回包含异常的 ModelAndView
8、DispatcherServlet 调用 ViewResolver 视图解析器来 来解析 ModeAndView
9、ViewResolver 解析 ModeAndView 并返回真正的 View 给 DispatcherServlet
10、DispatcherServlet 将得到的视图进行渲染，填充 Model 中数据到 request 域
11、返回给客户端响应结果

# SpringMVC 自动配置

Spring MVC 自动配置会创建很多对象，重点的有：

+ ContentNegotiatingViewResolver 和 BeanNameViewResolver bean
+ 支持提供静态资源，包括对 WebJars 的支持
+ 自动注册 Converter、GenericConverter 和 Formatter bean。
+ 对 HttpMessageConverters 的支持
+ 自动注册 MessageCodesResolver
+ 静态 index.html 支持。
+ 自动使用 ConfigurableWebBindingInitializer bean

WebMvcAutoConfiguration 是 Spring MVC 自动配置类，源代码如下：

```java
@AutoConfiguration(after = { DispatcherServletAutoConfiguration.class,
                            TaskExecutionAutoConfiguration.class,
                            ValidationAutoConfiguration.class })
@ConditionalOnWebApplication(type = Type.SERVLET)
@ConditionalOnClass({ Servlet.class, DispatcherServlet.class,
                     WebMvcConfigurer.class })
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@ImportRuntimeHints(WebResourcesRuntimeHints.class)
public class WebMvcAutoConfiguration {
    //.....
} 
```

+ DispatcherServletAutoConfiguration.class 自动配置 DispatcherServlet
+ WebMvcConfigurationSupport.class 配置 SpringMVC 的组件
+ ValidationAutoConfiguration.class: 配置 JSR-303 验证器
+ @ConditionalOnWebApplication(type = Type.SERVLET) ：应用是基于 SERVET 的 web 应用时有效
+ @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })：当项目有 Servlet.class，
+ DispatcherServlet.lcass 时起作用

## DispatcherServletAutoConfiguration.class

web.xml 在 SpringMVC 中以 xml 文件来配置 DispatcherServlet：

```xml
<servlet>
    <servlet-name>dispatcher</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/spring/dispatcher.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>
<servlet-mapping>
    <servlet-name>dispatcher</servlet-name>
    <url-pattern>/</url-pattern>
</servlet-mapping>
```

现在有自动配置完成，DispatcherServletAutoConfiguration 自动配置 DispatcherServlet。

1、创建 DispatcherServlet，@Bean 创建 DispatcherServlet 对象，容器中的名称为 dispatcherServlet。作为 Servlet 的 url-pattern 为“/”：

```java
@Bean(name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
public DispatcherServlet dispatcherServlet(WebMvcProperties webMvcProperties) {
    DispatcherServlet dispatcherServlet = new DispatcherServlet();
    ....
    return dispatcherServlet;
}
```

2、将 DispatchServlet 注册成 bean，放到 Spring 容器，设置 load-on-startup = -1 

3、创建 MultipartResolver，用于上传文件

他的配置类 WebMvcProperties.class， 前缀 spring.mvc：

```java
@ConfigurationProperties(prefix = "spring.mvc")
public class WebMvcProperties {
}
```

## WebMvcConfigurationSupport

Spring MVC 组件的配置类，Java Config 方式创建 HandlerMappings 接口的多个对象、HandlerAdapters 接口多个对象、 HandlerExceptionResolver 相关多个对象 ，PathMatchConfigurer， ContentNegotiationManager，OptionalValidatorFactoryBean， HttpMessageConverters 等这些实例。

## ServletWebServerFactoryAutoConfiguration

ServletWebServerFactoryAutoConfiguration 配置嵌入式 Web 服务器。

+ EmbeddedTomcat
+ EmbeddedJetty
+ EmbeddedUndertow

Spring Boot 检测 classpath 上存在的类，从而判断当前应用使用的是 Tomcat/Jetty/Undertow 中的哪一个 Servlet Web服务器,从而决定定义相应的工厂组件，也就是 Web 服务器。

配置类：ServerProperties.class ，配置 web server 服务器

```java
@ConfigurationProperties(prefix = "server", ignoreUnknownFields = true)
public class ServerProperties {
}
```

application 文件配置服务器，现在使用 tomcat 服务器：

```properties
#服务器端口号
server.port=8001
#上下文访问路径
server.servlet.context-path=/api
#request，response 字符编码
server.servlet.encoding.charset=utf-8
#强制 request，response 设置 charset 字符编码
server.servlet.encoding.force=true
```

![image-20240708150436058](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081504234.png)

Tomcat日志配置：

```properties
#日志路径
server.tomcat.accesslog.directory=D:/TomcatLogs
#启用访问日志
server.tomcat.accesslog.enabled=true
#日志文件名前缀
server.tomcat.accesslog.prefix=tomcat
#日志文件日期时间
server.tomcat.accesslog.file-date-format=.yyyy-MM-dd
#日志文件名称后缀
server.tomcat.accesslog.suffix=.log
#post 请求内容最大值，默认 2M
server.tomcat.max-http-form-post-size=2000000
#服务器最大连接数
server.tomcat.max-connections=8192
```

这会在d盘下创建一个TomcatLogs目录，在该目录下创建日志文件：

![image-20240708151358072](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081513190.png)

SpringMVC 配置，配置DispatcherServlet

```properties
#访问中央调度器的路径
spring.mvc.servlet.path=/course
#Servlet 的加载顺序，越小创建时间越早
spring.mvc.servlet.load-on-startup=0
#时间格式，可以在接受请求参数使用
spring.mvc.format.date-time=yyyy-MM-dd HH:mm:ss
```

这样配置后，使用8001端口访问服务器，/api 访问项目，/course才能访问到DispatcherServlet，才能访问到接口：

![image-20240708151758305](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081518339.png)

有个控制器方法：

```java
@GetMapping("/date")
@ResponseBody
public String date(LocalDateTime time) {
    return time.toString();
}
```

然后访问：

```java
GET http://localhost:8001/api/course/date?time=2024-07-08 15:21:21
```

结果：

```java
2024-07-08T15:21:21
```

如果没有配置这句：

```properties
spring.mvc.format.date-time=yyyy-MM-dd HH:mm:ss
```

或者前端传的时间格式不正确，那么访问结果会是400错误。

如果使用LocalDateTime格式接收参数，那么就要设置格式，否则可以使用String类型接收。使用Date类型接收参数时，设置了这个格式也会报400。

### @DateTimeFormat

@DateTimeFormat注解用于格式化日期，可以在方法，参数，字段上使用。

有个控制器：

```java
@GetMapping("/date")
@ResponseBody
public String date(@DateTimeFormat(pattern = "yyyy-MM-dd HH:mm:ss") LocalDateTime time) {
    return time.toString();
}
```

这就无需设置：spring.mvc.format.date-time=yyyy-MM-dd HH:mm:ss

然后访问测试：

```java
GET http://localhost:8001/api/course/date?time=2024-07-08 15:21:21
```

使用这个注解时，参数类型也可以使用Date。

## 总结

![image-20240708153901184](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081539386.png)

# Servlets, Filters, and Listeners

Web 应用还会用到 Servlet、Filter 或 Listener。这些对象能够作为 Spring Bean 注册到嵌入式的 Tomcat 中。ServletRegistrationBean、FilterRegistrationBean 和 ServletListenerRegistrationBean 控制 Servlet，Filter，Listener。@Order 或 Ordered 接口控制对象的先后顺序。

Servlet 现在完全支持注解的使用方式，@WebServlet

新建一个项目。

## Servlets

### @WebServlet 使用 Servlet

写一个Servlet：

```java
@WebServlet(urlPatterns = "/hello", name = "HelloServlet")
public class HelloServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        PrintWriter out = response.getWriter();
        out.print("Hello Word");
        out.flush();
        out.close();
    }
}
```

在启动类上使用包扫描：

```java
@SpringBootApplication
@ServletComponentScan(basePackages = {"com.zsm.web.servlet"})
public class Springboot013ServletApplication {

    public static void main(String[] args) {
        SpringApplication.run(Springboot013ServletApplication.class, args);
    }

}
```

+ @ServletComponentScan 用于扫描 Servlet， Filter ，Listener 对象。

访问结果：

![image-20240708155302022](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081553144.png)

### ServletRegistrationBean

能够以编码方式控制 Servlet，不需要注解

创建一个不使用注解的Servlet：

```java
public class LoginServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.print("这是一个登录的Servlet");
        out.flush();
        out.close();
    }
}
```

创建一个配置类：

```java
@Configuration
public class WebAppConfig {
    @Bean
    public ServletRegistrationBean servletRegistrationBean() {
        // 创建ServletRegistrationBean对象，用来登记管理一个或多个Servlet
        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean();
        // 添加servlet
        servletRegistrationBean.setServlet(new LoginServlet());
        // 设置路径
        servletRegistrationBean.addUrlMappings("/login");
        servletRegistrationBean.setLoadOnStartup(1);
        return servletRegistrationBean;
    }
}
```

这样也不需要在启动类上使用包扫描了，然后访问：

![image-20240708160330060](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081603187.png)

## Filter

Filter 对象使用频率比较高，比如记录日志，权限验证，敏感字符过滤等等。Web 框架中包含内置的 Filter，SpringMVC 中也包含较多的内置 Filter，比如 CommonsRequestLoggingFilter，CorsFilter，FormContentFilter...

### @WebFilter 使用 Filter

@WebFilter 创建 Filter 对象，使用方式同@WebServlet.

创建过一个Filter：

```java
// 访问所有路径都会走这个过滤器
@WebFilter(urlPatterns = "/*")
public class LoginFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        String uri = request.getRequestURI();
        System.out.println("LoginFilter : uri is " + uri);
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
```

在启动类上，开启包扫描：

```java
@SpringBootApplication
@ServletComponentScan(basePackages = {"com.zsm.web.filter"})
public class Springboot013ServletApplication {

    public static void main(String[] args) {
        SpringApplication.run(Springboot013ServletApplication.class, args);
    }

}
```

访问测试，输出结果：

```java
LoginFilter : uri is /login
```

### FilterRegistrationBean

FilterRegistrationBean 与 ServletRegistrationBean 使用方式类似，无需注解。

在之前的WebAppConfig类中：

```java
@Bean
public FilterRegistrationBean filterRegistrationBean() {
    FilterRegistrationBean registrationBean = new FilterRegistrationBean();
    registrationBean.setFilter(new LoginFilter());
    registrationBean.addUrlPatterns("/*");
    return registrationBean;
}
```

然后可以将LoginFilter上的@WebFilter注解去掉，或者去掉启动类上的包扫描，然后测试，输出结果：

```java
LoginFilter : uri is /login
```

### Filter排序

多个 Filter 对象如果要排序，有两种途径：

+ 过滤器类名称，按字典顺序排列， AuthFilter - > LogFilter
+ FilterRegistrationBean 登记 Filter，设置 order 顺序，数值越小，先执行。

#### 按名字

创建一个AuthFilter，一个LogFilter

```java
@WebFilter(urlPatterns = "/*")
public class AuthFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        String uri = request.getRequestURI();
        System.out.println("AuthFilter : uri is " + uri);
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
```

```java
@WebFilter(urlPatterns = "/*")
public class LogFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        HttpServletRequest request = (HttpServletRequest) servletRequest;
        String uri = request.getRequestURI();
        System.out.println("LogFilter : uri is " + uri);
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
```

启动类上的包扫描要开启，WebAppConfig类中的FilterRegistrationBean配置要注释掉，然后启动项目，访问一个servlet，查看控制台的输出顺序：

```java
AuthFilter : uri is /login
LogFilter : uri is /login
```

可以将AuthFilter改名为MuthFilter，输出结果是：

```java
LogFilter : uri is /login
MuthFilter : uri is /login
```

说明按过滤器的名字字典序排序。

#### 按设置

将LogFilter和MuthFilter的@WebFilter注解去掉（或者去掉启动类上的包扫描），然后在WebAppConfig类中进行配置：

```java
@Bean
public FilterRegistrationBean addLogFilter() {
    FilterRegistrationBean log = new FilterRegistrationBean();
    log.setFilter(new LogFilter());
    log.addUrlPatterns("/*");
    log.setOrder(2);
    return log;
}
@Bean
public FilterRegistrationBean addMuthFilter() {
    FilterRegistrationBean muth = new FilterRegistrationBean();
    muth.setFilter(new MuthFilter());
    muth.addUrlPatterns("/*");
    muth.setOrder(1);
    return muth;
}
```

+ setOrder设置顺序，数字越小，优先级越高

输出结果：

```java
MuthFilter : uri is /login
LogFilter : uri is /login
```

### 使用框架中的 Filter

Spring Boot 中有许多已经定义好的 Filter，这些 Filter 实现了一些功能，如果我们需要使用他们。可以像自己的 Filter 一样，通过 FilterRegistrationBean 注册 Filter 对象。

现在我们想记录每个请求的日志。CommonsRequestLoggingFilter 就能完成简单的请求记录。

在WebApplication类中：

```java
@Bean
public FilterRegistrationBean addCommonsRequestLoggingFilter() {
    FilterRegistrationBean filter = new FilterRegistrationBean();
    CommonsRequestLoggingFilter commonsRequestLoggingFilter = new CommonsRequestLoggingFilter();
    // 设置开启记录请求的uri地址
    commonsRequestLoggingFilter.setIncludeQueryString(true);
    filter.setFilter(commonsRequestLoggingFilter);
    filter.addUrlPatterns("/*");
    return filter;
}
```

查看CommonsRequestLoggingFilter的源码，说明他记录的日志都是debug级别的

![image-20240708163914127](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081639274.png)

所以只有debug级别的日志才能看见，打开application.properties文件，设置日志为debug：

```java
logging.level.web=debug
```

![image-20240708164120101](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081641262.png)

然后启动项目，访问http://localhost:8080/login?username=admin，输出结果：

```java
2024-07-08T16:42:49.930+08:00 DEBUG 6608 --- [springboot013-servlet] [nio-8080-exec-4] o.s.w.f.CommonsRequestLoggingFilter      : Before request [GET /login?username=admin]
2024-07-08T16:42:49.931+08:00 DEBUG 6608 --- [springboot013-servlet] [nio-8080-exec-4] o.s.w.f.CommonsRequestLoggingFilter      : After request [GET /login?username=admin]
```

框架中还有一个CharacterEncodingFilter过滤器默认启用，用来对请求的字符集进行设置。

## Listener

和过滤器的使用一样，两种方式，注解和手动编码注册。

@WebListener 用于注释监听器，监听器类必须实现下面的接口：

+ jakarta.servlet.http.HttpSessionAttributeListener
+ jakarta.servlet.http.HttpSessionListener
+ jakarta.servlet.ServletContextAttributeListener
+ jakarta.servlet.ServletContextListener
+ jakarta.servlet.ServletRequestAttributeListener
+ jakarta.servlet.ServletRequestListener
+ jakarta.servlet.http.HttpSessionIdListener

```java
@WebListener("Listener 的描述说明")
public class MySessionListener
    implements HttpSessionListener {
    @Override
    public void sessionCreated(HttpSessionEvent se) {
        HttpSessionListener.super.sessionCreated(se);
    }
}
```

另一种方式用 ServletListenerRegistrationBean 登记 Listener 对象。

# WebMvcConfigurer

WebMvcConfigurer 作为配置类，采用 JavaBean 的形式来代替传统的 xml 配置文件形式进行针对框架个性化定制，就是 Spring MVC XML 配置文件的JavaConfig（编码）实现方式。自定义 Interceptor，ViewResolver，MessageConverter。WebMvcConfigurer 就是 JavaConfig 形式的 Spring MVC 的配置文件。

WebMvcConfigurer 是一个接口，需要自定义某个对象，实现接口并覆盖某个方法。主要方法功能介绍一下：

```java
public interface WebMvcConfigurer {
    //帮助配置 HandlerMapping
    default void configurePathMatch(PathMatchConfigurer configurer) {
    }
    //处理内容协商
    default void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
    }//异步请求
    default void configureAsyncSupport(AsyncSupportConfigurer configurer) {
    }
    //配置默认 servlet
    default void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
    }
    //配置内容转换器
    default void addFormatters(FormatterRegistry registry) {
    }
    //配置拦截器
    default void addInterceptors(InterceptorRegistry registry) {
    }
    //处理静态资源
    default void addResourceHandlers(ResourceHandlerRegistry registry) {
    }
    //配置全局跨域
    default void addCorsMappings(CorsRegistry registry) {
    }
    //配置视图页面跳转
    default void addViewControllers(ViewControllerRegistry registry) {
    }
    //配置视图解析器
    default void configureViewResolvers(ViewResolverRegistry registry) {
    }
    //自定义参数解析器，处理请求参数
    default void addArgumentResolvers(List<HandlerMethodArgumentResolver> resolvers) {
    }
    //自定义控制器方法返回值处理器
    default void addReturnValueHandlers(List<HandlerMethodReturnValueHandler> handlers) {}
    //配置 HttpMessageConverters
    default void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
    }
    //配置 HttpMessageConverters
    default void extendMessageConverters(List<HttpMessageConverter<?>> converters) {
    }
    //配置异常处理器
    default void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
    }
    //扩展异常处理器
    default void extendHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {
    }
    //JSR303 的自定义验证器
    default Validator getValidator() {
        return null;
    }
    //消息处理对象
    default MessageCodesResolver getMessageCodesResolver() {
        return null;
    }
}
```

新建一个项目，依赖 SpringWeb，Thymeleaf，Lombok。

## 页面跳转控制器

springmvc.xml中的视图控制器`<mvc:view-controller>`。

Spring Boot 中使用页面视图，比如 Thymeleaf。要跳转显示某个页面，必须通过 Controller 对象。也就是我们需要创建一个 Controller，转发到一个视图才行。 如果我们现在需要显示页面，可以无需这个 Controller，使用addViewControllers() 完成从请求到视图跳转。

创建一个类实现WebMvcConfigurer接口，重写其中的addViewControllers方法：

```java
@Configuration
public class WebMvcSettings implements WebMvcConfigurer {
    @Override
    public void addViewControllers(ViewControllerRegistry registry) {
        // 将路径/index跳转到页面index
        registry.addViewController("/index").setViewName("index");
    }
}
```

+ addViewController("请求uri")
+ setViewName("视图页面名称")

新建index.html：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>主页</title>
</head>
<body>
<h1>Hello World</h1>
</body>
</html>
```

然后启动项目，直接访问http://localhost:8080/index就会跳转index页面：

![image-20240708171953596](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407081719747.png)

## 数据格式化

Formatter<T>是数据转换接口，将一种数据类型转换为另一种数据类型。与 Formatter<T>功能类型的还有Converter<S，T>。本节研究 Formatter<T>接口。

Formatter<T>只能将 String 类型转为其他数据数据类型。这点在Web 应用适用更广。因为 Web 请求的所有参数都是 String，我们需要把 String 转为 Integer ，Long，Date 等等。

Spring 中内置了一下 Formatter<T>：

+ DateFormatter ： String 和 Date 之间的解析与格式化
+ InetAddressFormatter ：String 和 InetAddress 之间的解析与格式化
+ PercentStyleFormatter ：String 和 Number 之间的解析与格式化，带货币符合
+ NumberFormat ：String 和 Number 之间的解析与格式化

在使用@ DateTimeFormat, @NumberFormat 注解时，就是通过 Formatter<T>解析 String 类型到我们期望的Date 或 Number 类型

Formatter<T>也是 Spring 的扩展点，我们处理特殊格式的请求数据时，能够自定义合适的 Formatter<T>，将请求的 String 数据转为我们的某个对象，使用这个对象更方便我们的后续编码。

接口原型：

```java
public interface Formatter<T> extends Printer<T>, Parser<T> {
}
```

Formatter<T>是一个组合接口，没有自己的方法。内容来自 Printer<T>和 Parser<T>

+ Printer<T>：将 T 类型转为 String，格式化输出
+ Parser<T>：将 String 类型转为期望的 T 对象。

我们项目开发，可能面对多种类型的项目，复杂程度有简单，有难一些。特别是与硬件打交道的项目，数据的格式与一般的 name: lisi, age:20 不同。数据可能是一串“1111; 2222; 333,NF; 4; 561” 。

需求：将“1111；2222；333,NF；4；561”接收，在代码中用 DeviceInfo 存储参数值。

先创建一个DeviceInfo类：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class DeviceInfo {
    private String item1;
    private String item2;
    private String item3;
    private String item4;
    private String item5;
}
```

然后自定义一个DeviceFormatter实现Formatter接口：

```java
public class DeviceFormatter implements Formatter<DeviceInfo> {
    // text表示请求参数的值
    @Override
    public DeviceInfo parse(String text, Locale locale) throws ParseException {
        DeviceInfo res = null;
        if (!text.isEmpty()) {
            String[] items = text.split(";");
            res = new DeviceInfo(items[0], items[1], items[2], items[3], items[4]);
        }
        return res;
    }

    @Override
    public String print(DeviceInfo object, Locale locale) {
        StringJoiner joiner = new StringJoiner("#");
        joiner.add(object.getItem1())
                .add(object.getItem2())
                .add(object.getItem3())
                .add(object.getItem4())
                .add(object.getItem5());
        return joiner.toString();
    }
}
```

然后需要将这个DeviceFormatter告诉框架，在 WebMvcSettings 中，重写addFormatters方法：

```java
@Override
public void addFormatters(FormatterRegistry registry) {
    registry.addFormatter(new DeviceFormatter());
}
```

然后重建一个controller测试：

```java
@RestController 
public class TestController {
    @PostMapping("/info")
    public String info(@RequestParam("device")DeviceInfo deviceInfo) {
        return deviceInfo.toString();
    }  
}
```

+ 框架会去转换器中寻找有没有适合DeviceInfo数据的转换器

发送请求：

```java
POST http://localhost:8080/info
Content-Type: application/x-www-form-urlencoded

device=1111; 2222; 333,NF; 4; 561
```

返回结果：

```java
DeviceInfo(item1=1111, item2= 2222, item3= 333,NF, item4= 4, item5= 561)
```

## 拦截器

HandlerInterceptor 接口和它的实现类称为拦截器，是 SpringMVC 的一种对象。拦截器是 Spring MVC 框架的对象，与 Servlet 无关。拦截器能够预先处理发给 Controller 的请求。可以决定请求是否被 Controller 处理。用户请求是先由 DispatcherServlet 接收后，在 Controller 之前执行的拦截器对象。

根据拦截器的特点，类似权限验证，记录日志，过滤字符，登录 token 处理都可以使用拦截器。

一个项目中有众多的拦截器：框架中预定义的拦截器， 自定义拦截器。

拦截器定义步骤：

+ 声明类实现 HandlerInterceptor 接口，重写三个方法（需要那个重写那个）
+ 登记拦截器

### 一个拦截器

需求：zhangsan 操作员用户，只能查看文章，不能修改，删除。

定义控制器方法：

```java
@RestController
public class ArticleController {
    @PostMapping("/article/add")
    public String addArticle(){
        return "发布新的文章";
    }
    @PostMapping("/article/edit")
    public String editArticle(){
        return "修改文章";
    }
    @DeleteMapping("/article/delete")
    public String removeArticle() {
        return "删除文章";
    }
    @GetMapping("/article/query")
    public String query(){
        return "查询文章";
    }
}
```

然后定义拦截器，在拦截器中判断用户名是否是zhangsan，是的话只能查看文章，不能进行其他操作：

```java
public class AuthInterceptor implements HandlerInterceptor {
    private static final String USER = "zhangsan";
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("权限拦截器执行了");
        String user = request.getParameter("user");
        String uri = request.getRequestURI();
        if (USER.equals(user) &&
                (uri.startsWith("/article/add") ||
                 uri.startsWith("/article/delete") ||
                 uri.startsWith("/article/edit")))
            return false;
        return ture;
    }
}
```

定义好拦截器后，需要登记拦截器，在WebMvcSettings配置类中，实现addInterceptors方法：

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new AuthInterceptor())
        .addPathPatterns("/article/**")
        .excludePathPatterns("/article/query");
}
```

+ addPathPatterns添加要拦截的路径
+ excludePathPatterns不拦截的路径

然后测试：

```java
POST http://localhost:8080/article/add
Content-Type: application/x-www-form-urlencoded

user=lisi
```

![image-20240708222519901](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407082226899.png)

![image-20240708222641348](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407082226473.png)

### 多个拦截器

增加一个验证登录用户的拦截器，只有 zhangsan，lisi，admin 能够登录系统。其他用户不可以。两个拦截器登录的拦截器先执行，权限拦截器后执行，order()方法设置顺序，整数值越小，先执行。

实现登录拦截器，创建一个用户列表，包含三个可登录系统的用户：

```java
public class LoginInterceptor implements HandlerInterceptor {
    private List<String> users = new ArrayList<>();
    public LoginInterceptor() {
        users = Arrays.asList("zhangsan", "lisi", "admin");
    }
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("登录拦截器执行了");
        String user = request.getParameter("user");
        if (user.isEmpty() || !users.contains(user)) return false;
        return true;
    }
}
```

然后将LoginIntercepto登记，在WebMvcSettings配置类中，还是在addInterceptors方法中进行登记：

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new AuthInterceptor())
        .addPathPatterns("/article/**")
        .excludePathPatterns("/article/query");

    registry.addInterceptor(new LoginInterceptor())
        .addPathPatterns("/**")
        .excludePathPatterns("/article/query");
}
```

此时没有设置顺序，先看看哪个拦截器会先执行：

![image-20240708224139793](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407082241911.png)

现在要登录拦截器先执行，使用order设置顺序，数字越小越靠前：

```java
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(new AuthInterceptor())
        .order(2)
        .addPathPatterns("/article/**")
        .excludePathPatterns("/article/query");

    registry.addInterceptor(new LoginInterceptor())
        .order(1)
        .addPathPatterns("/**")
        .excludePathPatterns("/article/query");
}
```

重新测试：

![image-20240708224733190](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407082247309.png)

# 文件上传

Spring Boot 上传文件现在变得非常简单。提供了封装好的处理上传文件的接口 MultipartResolver，用于解析上传文件的请求，他的内部实现类是 StandardServletMultipartResolver。

StandardServletMultipartResolver 内部封装了读取 POST 其中体的请求数据，也就是文件内容。我们现在只需要在 Controller 的方法加入形参@RequestParam MultipartFile。 MultipartFile 表示上传的文件，提供了方便的方法保存文件到磁盘。

MultipartFile API：

![image-20240708225011636](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407082250754.png)

创建一个新项目。

## MultipartResolver

先创建两个页面，一个是上传文件的页面，一个上传文件后显示上传成功的页面。这两个页面都是静态页面，所以在resources下的static下创建。

upload.html：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>上传文件</title>
</head>
<body>
<h3>上传文件</h3>
<form action="files" enctype="multipart/form-data" method="post">
    选择文件：<input type="file" name="upfile"> <br/>
    <input type="submit" value="上传文件">
</form>
</body>
</html>
```

+ enctype="multipart/form-data"：这是必须的
+ method="post"：请求方式一定是post

success.html：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>上传成功</title>
</head>
<body>
<h1>上传文件成功！</h1>
</body>
</html>
```

然后创建一个controller，定义上传文件的方法：

```java
@Controller
public class UploadController {
    @PostMapping("/upload")
    public String upload(MultipartFile multipartFile) {
        System.out.println("开始上传文件");
        Map<String, Object> map = new HashMap<>();
        try {
            // 上传了文件
            if (!multipartFile.isEmpty()) {
                // 获取文件名
                String fileName = multipartFile.getOriginalFilename();

                // 获取扩展名
                String ext = fileName.substring(fileName.lastIndexOf(".") + 1);
                // 生成服务器上的文件名，UUID防止重名
                String newFileName = UUID.randomUUID() + "." + ext;

                // 文件保存的路径
                String path = "D:/MyCode/SpringBoot/upload/" + newFileName;
                // 保存文件
                multipartFile.transferTo(new File(path));

                map.put("文件的名称", fileName);
                map.put("文件内容类型", multipartFile.getContentType());
                map.put("新文件名称", newFileName);
                map.put("新文件地址", path);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(map);

        // 重定向到success页面
        return "redirect:/success.html";
    }
}
```

然后要在D盘下MyCode下的SpringBoot下创建一个目录upload，然后运行项，选择文件上传，查看控制台输出：

```
开始上传文件
{文件的名称=b.gif, 文件内容类型=image/gif, 新文件名称=fe0838d0-8371-455d-bdc4-51892d7b082c.gif, 新文件地址=D:/MyCode/SpringBoot/upload/fe0838d0-8371-455d-bdc4-51892d7b082c.gif}
```

然后去D盘目录下查看这个文件：

![image-20240709075859552](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407090759716.png)

Spring Boot 默认单个文件最大支持 1M，一次请求最大 10M。改变默认值，需要 application 修改配置项：

```properties
# 单个文件最大
spring.servlet.multipart.max-file-size=100KB
# 一次请求最大
spring.servlet.multipart.max-request-size=5MB
spring.servlet.multipart.file-size-threshold=0KB
```

file-size-threshold 超过指定大小，直接写文件到磁盘，不在内存处理。配置改为以上配置后，上传一个大于100KB的图片测试：

![image-20240709080415345](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407090804486.png)

可以在resources下static下配置一个错误页面，在static下新建一个error目录，里面创建一个4xx.html，表示4xx的错误都走这个错误页面：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>4xx错误</title>
</head>
<body>
<h1>文件上传失败</h1>
</body>
</html>
```

框架会默认去跳转这个页面，可以在application.properties中配置server.error.path，这个路径从resources/static/下开始找起。

## Servlet 规范

Servlet3.0 规范中，定义了 jakarta.servlet.http.Part 接口处理 multipart/form-data POST 请求中接收到表单数据。有了 Part 对象，其 write()方法将上传文件保存到服务器本地磁盘目录。

在 HttpServletRequest 接口中引入的新方法：

+ getParts():返回 Part 对象的集合
+ getPart(字符串名称):检索具有给定名称的单个 Part 对象。

Spring Boot 3 使用的 Servlet 规范是基于 5 的，所以上传文件使用的就是 Part 接口。StandardServletMultipartResolver 对 Part 接口进行的封装，实现基于 Servlet 规范的文件上传。

原生的 Serlvet 规范的文件上传：

```java
@Controller
public class UploadAction {
    @PostMapping("/files")
    public String upload(HttpServletRequest request){
        try {
            for (Part part : request.getParts()) {
                String fileName = extractFileName(part);
                // 将文件写入服务器的目录，目录在application中配置
                part.write(fileName);
            }
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (ServletException e) {
            throw new RuntimeException(e);
        }
        return "redirect:/index.html";
    }
    private String extractFileName(Part part) {
        String contentDisp = part.getHeader("content-disposition");
        String[] items = contentDisp.split(";");
        for (String s : items) {
            if (s.trim().startsWith("filename")) {
                return s.substring(s.indexOf("=") + 2, s.length()-1);
            }
        }
        return "";
    }
}
```

上传文件包含 header 头 content-disposition，类似下面的内容, 可获取文件原始名称：

```java
form-data; name="dataFile"; filename="header.png"
```

application 文件，可配置服务器存储文件位置，例如：

```properties
spring.servlet.multipart.location=E://files/
```

## 多文件上传

多文件上传，在接收文件参数部分有所改变： MultiPartFile [] files 。循环遍历数组解析每个上传的文件。

前端请求页面：

```html
<form action="upload" enctype="multipart/form-data" method="post">
    选择文件-1：<input type="file" name="multipartFile"> <br/>
    选择文件-2：<input type="file" name="multipartFile"> <br/>
    <input type="submit" value="上传文件">
</form>
```

控制器：

```java
@Controller
public class UploadController {
    @PostMapping("/upload")
    public String upload(@RequestParam("multipartFile") MultipartFile[] multipartFiles) {
        System.out.println("开始上传文件");

        Map<String, Object> map = new HashMap<>();
        try {
            for (MultipartFile multipartFile : multipartFiles) {
                // 上传了文件
                if (!multipartFile.isEmpty()) {
                    // 获取文件名
                    String fileName = multipartFile.getOriginalFilename();

                    // 获取扩展名
                    String ext = fileName.substring(fileName.lastIndexOf(".") + 1);
                    // 生成服务器上的文件名，UUID防止重名
                    String newFileName = UUID.randomUUID() + "." + ext;

                    // 文件保存的路径
                    String path = "D:/MyCode/SpringBoot/upload/" + newFileName;
                    // 保存文件
                    multipartFile.transferTo(new File(path));

                    map.put("文件的名称", fileName);
                    map.put("文件内容类型", multipartFile.getContentType());
                    map.put("新文件名称", newFileName);
                    map.put("新文件地址", "/upload/" + path);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        System.out.println(map);

        // 重定向到success页面
        return "redirect:/success.html";
    }
}
```

# 全局异常处理

在 Controller 处理请求过程中发生了异常，DispatcherServlet 将异常处理委托给异常处理器（处理异常的类）。实现 HandlerExceptionResolver 接口的都是异常处理类。

项目的异常一般集中处理，定义全局异常处理器。在结合框架提供的注解，诸如：@ExceptionHandler，@ControllerAdvice ,@RestControllerAdvice 一起完成异常的处理。

@ControllerAdvice 与@RestControllerAdvice 区别在于：@RestControllerAdvice 加了@RepsonseBody。

新建一个项目，加入依赖：Spring Web，Lombok，Thymeleaf

## 全局异常处理器

需求：应用计算两个数字相除，当除数为 0 ，发生异常。使用自定义异常处理器代替默认的异常处理程序。

创建一个页面：

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form action="divide" method="get">
    被除数：<input name="n1" /> <br/>
    除&nbsp;&nbsp;&nbsp;数：<input name="n2" /> <br/>
    <input type="submit" value="计算">
</form>
</body>
</html>
```

创建一个负责除法的控制器：

```java
@RestController
public class NumberController {
    @PostMapping("/divide")
    public String divide(Integer n1, Integer n2) {
        return n1 + " / " + n2 + " = " + (n1 / n2);
    }
}
```

正常情况：

![image-20240709102658801](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407091026942.png)

异常情况：

![image-20240709102717431](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407091027553.png)

这是默认错误页面。

创建自定义异常处理器，要在类上加上@ControllerAdvice或这@RestControllerAdvice，方法上加上@ExceptionHandler：

```java
@ControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler({ArithmeticException.class})
    public String handleArithmeticException(ArithmeticException e, Model model) {
        String message = e.getMessage();
        model.addAttribute("error", message);
        return "exp";
    }
}
```

+ 这个方法的两个参数都是框架传过来的，最后返回一个视图页面
+ @ExceptionHandler表示这个方法可以处理异常，处理异常的范围是ArithmeticException异常，可以声明多个异常类。

现在跳转自定义异常页面：

![image-20240709104839072](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407091048194.png)

建议在参数签名中尽可能具体异常类，以减少异常类型和原因异常之间不匹配的问题，考虑创建多个@ExceptionHandler 方法的，每个方法通过其签名匹配单个特定的异常类型。最后增加一个根异常，考虑没有匹配的其他情况。

异常处理器也可以返回数据，而不是页面：

```java
@ExceptionHandler({ArithmeticException.class})
@ResponseBody
public Map<String, String> handleArithmeticException(ArithmeticException e) {
    Map<String, String> map = new HashMap<>();
    map.put("err", e.getMessage());
    map.put("tip", "除数要大于0");
    return map;
}
```

要在方法上使用@ResponseBody注解，或者在整个类上使用@RestControllerAdvice：

![image-20240709110646128](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407091106252.png)

## BeanValidator 异常处理

使用 JSR-303 验证参数时，我们是在 Controller 方法的参数中声明 BindingResult 对象获取校验结果。Controller 的方法很多，每个方法都加入 BindingResult 处理检验参数比较繁琐。 校验参数失败抛出异常给框架，异常处理器能够捕获到 MethodArgumentNotValidException，它是 BindException 的子类。

![image-20240709110910738](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407091109876.png)

BindException 异常实现了 BindingResult 接口，异常类能够得到 BindingResult 对象，进一步获取 JSR303 校验的异常信息。

需求：全局处理 JSR-303 校验异常

加入 JSR-303 依赖：

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-validation</artifactId>
</dependency>
```

创建一个实体类Order：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Order {
    @NotBlank(message = "订单名称不能为空")
    private String name;
    @NotNull(message = "商品数量不能为空")
    @Range(min = 1, max = 99, message = "数量最小为{min}，最大{max}")
    private Integer amount;
    @NotNull(message = "用户id不能为空")
    @Min(value = 1, message = "用户id从1开始")
    private Integer userId;
}
```

+ 可以使用{}占位符

创建一个控制器方法，来生成订单：

```java
@RestController
public class OrderController {
    @PostMapping("/order/new")
    public String createOrder(@Validated @RequestBody Order order) {
        return order.toString();
    }
}
```

创建异常处理器，处理JSR303（检验参数）的异常：

```java
@ExceptionHandler({BindException.class})
@ResponseBody
public Map<String, String> handlerJSR303Exception(BindException e) {
    Map<String, String> map = new HashMap<>();
    BindingResult br = e.getBindingResult();
    if (br.hasErrors()) {
        List<FieldError> errors = br.getFieldErrors();
        for (int i = 0; i < errors.size(); i++) {
            FieldError fieldError = errors.get(i);
            map.put(i + fieldError.getField(), fieldError.getDefaultMessage());
        }
    }
    return map;
}
```

测试：

```java
POST http://localhost:8080/order/new
Content-Type: application/json

{
  "name": "name_f99c21263d88",
  "amount": 0,
  "userId": 0
}
```

返回结果：

```json
{
  "0userId": "用户id从1开始",
  "1amount": "数量最小为1，最大99"
}
```

## ProblemDetail [SpringBoot 3]

Spring Boot 默认的异常反馈内容比较单一，包含 Http Status Code、时间、异常信息。但具体异常原因没有体现。

这就是SpringBoot默认的异常信息：

```
{
  "timestamp": "2024-07-09T06:36:12.458+00:00",
  "status": 400,
  "error": "Bad Request",
  "path": "/order/new"
}
```

这次 Spring Boot3 对错误信息增强了。

### RFC 7807

RFC 7807（Problem Details for HTTP APIs）: [RFC 7807: Problem Details for HTTP APIs (rfc-editor.org)](https://www.rfc-editor.org/rfc/rfc7807)

RESTFul 服务中通常需要在响应体中包含错误详情，Spring 框架支持”Problem Details“。定义了 Http 应答错误的处理细节，增强了响应错误的内容，包含标准和非标准的字段，同时支持 json 和 xml 两种格式。

基于 Http 协议的请求，可通过 Http Status Code 分析响应结果，200 为成功， 4XX 为客户端错误，500 是服务器程序代码异常。status code 过于简单，不能进一步说明具体的错误原因和解决途径。比如 http status code 403,但并不能说明 ”是什么导致了 403“，以及如何解决问题。Http 状态代码可帮助我们区分错误和成功状态，但没法区分得太细致。RFC 7807 中对这些做了规范的定义。

”Problem Details“ 的 JSON 应答格式：

```json
{
    "type": "https://example.com/probs/out-of-credit",
    "title": "You do not have enough credit.",
    "detail": "Your current balance is 30, but that costs 50.",
    "instance": "/account/12345/transactions/abc"
}
```

![image-20240709144017757](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407091441250.png)

![image-20240709144122964](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407091441114.png)

除了以上字段，用户可以扩展字段。采用 key：value 格式。增强对问题的描述。

### MediaType

RFC 7807 规范增加了两种媒体类型: `application/problem+json`或`application/problem+xml`。返回错误的HTTP 响应应在其`Content-Type`响应标头中包含适当的内容类型，并且客户端可以检查该标头以确认格式.

### Spring 支持 Problem Detail

Spring 支持 ProblemDetail

+ ProblemDetail 类: 封装标准字段和扩展字段的简单对象
+ ErrorResponse ：错误应答类，完整的 RFC 7807 错误响应的表示，包括 status、headers 和 RFC 7807 格式的ProblemDetail 正文
+ ErrorResponseException ：ErrorResponse 接口一个实现，可以作为一个方便的基类。扩展自定义的错误处理类。
+ ResponseEntityExceptionHandler：它处理所有 Spring MVC 异常，与@ControllerAdvice 一起使用。

以上类型作为异常处理器方法的返回值，框架将返回值格式化 RFC 7807 的字段。

### 自定义异常处理器 ProblemDetail

需求：我们示例查询某个 isbn 的图书。 在 application.yml 中配置图书的初始数据。 用户访问一个 api 地址，查询某个 isbn 的图书， 查询不到抛出自定义异常 BootNotFoundException。 自定义异常处理器捕获异常。ProblemDetail 作为应答结果。支持 RFC 7807

创建新的项目。

在application.yml中配置图书的初始数据：

```yaml
books:
  - isbn: B001
    author: Tom
    name: JavaSE
  - isbn: B002
    author: Jimi
    name: MySQL
  - isbn: B003
    author: Steve
    name: JavaEE
```

创建一个Record类型来保存数据：

```java
public record Book(String isbn, String name, String author) {
}
```

创建一个数据配置类，要读取核心配置文件，读取到数据，代替数据库的操作：

```java
@Setter
@Getter
@ConfigurationProperties
public class BookContainer {
    private List<Book> books;
}
```

+ application.yml中的数据就是books开头，所以不需要指定前缀了

然后还要在启动类上，启动：

```java
@SpringBootApplication
@EnableConfigurationProperties(BookContainer.class)
public class Springboot017ProblemdetailApplication {

    public static void main(String[] args) {
        SpringApplication.run(Springboot017ProblemdetailApplication.class, args);
    }

}
```

自定义一个异常类：

```java
public class BookNotFoundException extends RuntimeException{
    public BookNotFoundException() {
        super();
    }

    public BookNotFoundException(String message) {
        super(message);
    }
}
```

创建一个控制器：

```java
@RestController
public class BookController {
    @Autowired
    private BookContainer bookContainer;

    @GetMapping("/book")
    public Book getBook(String isbn) {
        Optional<Book> first = bookContainer.getBooks().stream().filter(book -> book.isbn().equals(isbn)).findFirst();
        if (first.isEmpty()) throw new BookNotFoundException("没有找到这本书");
        return first.get();
    }
}
```

+ 注入BookContainer，获取到所有的Book数据
+ 遍历所有的Book，查找isbn号相等的Book
+ 如果没有，则抛出异常

接下来定义一个全局的异常处理器：

```java
@RestControllerAdvice
public class GlobalExceptionHandler{
    @ExceptionHandler(BookNotFoundException.class)
    public ProblemDetail handlerBookNotFoundException(BookNotFoundException e) {
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, e.getMessage());
        problemDetail.setType(URI.create("/api/book/not-found"));
        problemDetail.setTitle("图书不存在");
        return problemDetail;
    }
}
```

+ 设置了状态码、详细信息、类型（是一个uri，表示通过这个uri可以找到解决异常的问题）、标题

测试：

```http
GET http://localhost:8080/book?isbn=B001
```

返回结果：

```java
{
  "isbn": "B001",
  "name": "JavaSE",
  "author": "Tom"
}
```

测试：

```http
GET http://localhost:8080/book?isbn=B0011
```

返回结果：

```java
{
  "type": "/api/book/not-found",
  "title": "图书不存在",
  "status": 404,
  "detail": "没有找到这本书",
  "instance": "/book"
}
```

+ type：是一个地址，表示一种错误类型，这个地址应该是这个错误的详细解释描述，访问这个地址可能了解更多关于这个问题的信息
+ instance：表示错误出现的源头地址

### 扩展 ProblemDetail

修改异常处理方法，增加 ProblemDetail 自定义字段，自定义字段以 Map<String,Object>存储，调用setProperty(name,value)将自定义字段添加到 ProblemDetail 对象。

```java
@RestControllerAdvice
public class GlobalExceptionHandler{
    @ExceptionHandler(BookNotFoundException.class)
    public ProblemDetail handlerBookNotFoundException(BookNotFoundException e) {
        ProblemDetail problemDetail = ProblemDetail.forStatusAndDetail(HttpStatus.NOT_FOUND, e.getMessage());
        problemDetail.setType(URI.create("/api/book/not-found"));
        problemDetail.setTitle("图书不存在");
        
        // 增加自定义字段
        problemDetail.setProperty("时间", "2024-07-09");
        problemDetail.setProperty("客服", "zsm@123.com");
        return problemDetail;
    }
}
```

测试结果：

```java
{
  "type": "/api/book/not-found",
  "title": "图书不存在",
  "status": 404,
  "detail": "没有找到这本书",
  "instance": "/book",
  "时间": "2024-07-09",
  "客服": "zsm@123.com"
}
```

### ErrorResponse

Spring Boot 识别 ErrorResponse 类型作为异常的应答结果。可以直接使用 ErrorResponse 作为异常处理方法的返回值，ErrorResponseException 是 ErrorResponse 的基本实现类。

返回ErrorResponse对象的异常处理方法：

```java
@ExceptionHandler(BookNotFoundException.class)
public ErrorResponse handlerBookNotFoundException(BookNotFoundException e) {
    ErrorResponse errorResponse = new ErrorResponseException(HttpStatus.NOT_FOUND, e);
    return errorResponse;
}
```

然后用之前的测试，返回结果：

```json
{
  "type": "about:blank",
  "title": "Not Found",
  "status": 404,
  "instance": "/book"
}
```

### 扩展 ErrorResponseException

自定义异常可以扩展 ErrorResponseException， SpringMVC 将处理异常并以符合 RFC 7807 的格式返回错误响应。ResponseEntityExceptionHandler 能够处理大部分 SpringMVC 的异常的，

可以创建自定义异常类，继承 ErrorResponseException，当这个异常抛出后，就会被框架中已存在的异常处理器处理。

创建新的异常类继承 ErrorResponseException：

```json
public class IsbnNotFoundException extends ErrorResponseException {
    public IsbnNotFoundException(HttpStatus status, String detail) {
        super(status, createProblemDetail(status, detail), null);
    }

    private static ProblemDetail createProblemDetail(HttpStatus status, String detail) {
        ProblemDetail problemDetail = ProblemDetail.forStatus(status);
        problemDetail.setType(URI.create("/api/probs/not-found"));
        problemDetail.setTitle("图书异常");
        problemDetail.setDetail(detail);
        //增加自定义字段
        problemDetail.setProperty("严重程度", "低");
        problemDetail.setProperty("客服邮箱", "sevice@bjpowernode.com");
        return problemDetail;
    }
}
```

然后要在application配置文件中配置开启支持RFC7807：

```yaml
spring:
  mvc:
    problemdetails:
      enabled: true
```

在controller里面，修改一下代码，抛出异常IsbnNotFoundException：

```java
@GetMapping("/book")
public Book getBook(String isbn) {
    Optional<Book> first = bookContainer.getBooks().stream().filter(book -> book.isbn().equals(isbn)).findFirst();
    if (first.isEmpty()) throw new IsbnNotFoundException(HttpStatus.NOT_FOUND, "没有找到这本书");
    return first.get();
}
```

重启 项目，测试，返回结果：

```json
{
  "type": "/api/probs/not-found",
  "title": "图书异常",
  "status": 404,
  "detail": "没有找到这本书",
  "instance": "/book",
  "严重程度": "低",
  "客服邮箱": "sevice@bjpowernode.com"
}
```

