Spring Boot 框架为 SQL 数据库提供了广泛的支持，既有用 JdbcTemplate 直接访问 JDBC，同时支持“object relational mapping”技术(如 Hibernate，MyBatis)。Spring Data 独立的项目提供对多种关系型和非关系型数据库的访问支持。比如 MySQL, Oracle , MongoDB , Redis, R2DBC，Apache Solr，Elasticsearch...

Spring Boot 也支持嵌入式数据库比如 H2, HSQL, and Derby。这些数据库只需要提供 jar 包就能在内存中维护
数据。我们这章访问关系型数据库。

# DataSource

通常项目中使用 MySQL,Oracle,PostgreSQL 等大型关系数据库。Java 中的 jdbc 技术支持了多种关系型数据库的访问。在代码中访问数据库，我们需要知道数据库程序所在的 ip，端口，访问数据库的用户名和密码以及数据库的类型信息。以上信息用来初始化数据源，数据源也就是 DataSource。数据源表示数据的来源，从某个 ip 上的数据库能够获取数据。javax.sql.DataSource 接口表示数据源，提供了标准的方法获取与数据库绑定的连接对象（Connection）。

java.sql.Connection 是连接对象，在 Connection 上能够从程序代码发送查询命令，更新数据的语句给数据库；同时从 Connection 获取命令的执行结果。Connection 很重要，像一个电话线把应用程序和数据库连接起来。

![image-20240705164036727](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407051640768.png)

DataSource 在 application 配置文件中以 spring.datasource.*作为配置项。类似下面的代码：

```properties
spring.datasource.url=jdbc:mysql://localhost/mydb
spring.datasource.username=dbuser
spring.datasource.password=dbpass
```

以上的配置项来自于自动配置中的DataSourceProperties.java，他是数据源的配置类，更多配置参考这个类的属性。

```java
@ConfigurationProperties(prefix = "spring.datasource")
public class DataSourceProperties implements BeanClassLoaderAware,
InitializingBean { 
}
```

查看自动配置类DataSourceAutoConfiguration：

![image-20240705164458589](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407051644624.png)

点进去这个DataSourceProperties类中：

![image-20240705164606774](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407051646820.png)

这个类中有一个驱动器的名字driverClassName，这个属性一般不用我们赋值，Spring Boot 能够从 spring.datasource.url 推断所使用的数据驱动类，如果需要特殊指定请设置spring.datasource.driver-class-name 为驱动类的全限定名称。

在自动配置类DataSourceAutoConfiguration中，有一个@Import注解导入连接池的配置。Spring Boot 支持多种数据库连接池，优先使用 HikariCP，其次是 Tomcat pooling，再次是 Commons DBCP2，如果以上都没有，最后会使用 Oracle UCP 连接池。当项目中 starter 依赖了 spring-boot-starter-jdbc 或者spring-boot-starter-data-jpa 默认添加 HikariCP 连接池依赖，也就是默认使用 HikariCP 连接池。

#  轻量的 JdbcTemplate

使用 JdbcTemplate 给我们提供自定义 SQL, Spring 执行这些 SQL 得到记录结果集。JdbcTemplate 和NamedParameterJdbcTemplate 类是自动配置的，您可以@Autowire 注入到自己的 Bean 中。开箱即用。

JdbcTemplate 执行完整的 SQL 语句，我们将 SQL 语句拼接好，交给 JdbcTemplate 执行，JdbcTemplate 底层就是使用 JDBC 执行 SQL 语句。是 JDBC 的封装类而已。

NamedParameterJdbcTemplate 可以在 SQL 语句部分使用“`:命名参数`”作为占位符, 对参数命名，可读性更好。

NamedParameterJdbcTemplate 包装了 JdbcTemplate 对象，“`:命名参数`”解析后，交给 JdbcTemplate 执行 SQL语句。

JdbcTemplateAutoConfiguration 自动配置了 JdbcTemplate 对象，交给 JdbcTemplateConfiguration 创建了JdbcTemplate 对象。并对 JdbcTemplate 做了简单的初始设置（QueryTimeout，maxRows 等）。

这个自动配置类：

```java
@AutoConfiguration(
    after = {DataSourceAutoConfiguration.class}
)
@ConditionalOnClass({DataSource.class, JdbcTemplate.class})
@ConditionalOnSingleCandidate(DataSource.class)
@EnableConfigurationProperties({JdbcProperties.class})
@Import({DatabaseInitializationDependencyConfigurer.class, JdbcTemplateConfiguration.class, NamedParameterJdbcTemplateConfiguration.class})
public class JdbcTemplateAutoConfiguration {
    public JdbcTemplateAutoConfiguration() {
    }
}
```

这个JdbcProperties是配置模板类的，这个JdbcTemplateConfiguration就是模板类：

![image-20240705165534483](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407051655530.png)

这个JdbcTemplate类就是一个jdbc的封装类。

## 准备环境

可以自己在数据库中创建好表，也可以让SpringBoot创建。SpringBoot 能够自动执行 DDL，DML 脚本。两个脚本文件名称默认是
schema.sql 和 data.sql，脚本文件在类路径中，在启动项目时自动执行。

自动执行脚本还涉及到 spring.sql.init.mode 配置项：

+ always：总是执行数据库初始化脚本
+ never：禁用数据库初始化

> Spring Boot 处理特定的数据库类型，为特定的数据库定制 script 文件。首先设置 spring.sql.init.platform=hsqldb、h2、oracle、mysql、postgresql 等等，其次准备 schema-\${platform}. sql 、 data-\$​{platform}. sql 脚本文件。

创建项目，加入依赖：Lombok，MySQL Driver, JDBC API

查看一下pom.xml文件：

```xml
<dependencies>
    <!--        JdbcTemplate, 连接池使用：HikariCP-->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>

    <!--        mysql驱动-->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

当使用Lombok时，右小角可能会有警告 ：

![image-20240705171351013](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407051713049.png)

点击Enable annotation processing解决，或在设置中解决：

![image-20240705171441824](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407051714898.png)

然后先创建一个数据库：blog。

再准备两个脚本，在项目的resources目录下直接创建两个sql文件，schema.sql：

```sql
CREATE TABLE `article` (
	`id` INT ( 11 ) NOT NULL AUTO_INCREMENT COMMENT '主键',
	`user_id` INT ( 11 ) NOT NULL COMMENT '作者 ID',
	`title` VARCHAR ( 100 ) NOT NULL COMMENT '文章标题',
	`summary` VARCHAR ( 200 ) DEFAULT NULL COMMENT '文章概要',
	`read_count` INT ( 11 ) UNSIGNED ZEROFILL NOT NULL COMMENT '阅读读数',
	`create_time` datetime NOT NULL COMMENT '创建时间',
`update_time` datetime NOT NULL COMMENT '最后修改时间',
PRIMARY KEY ( `id` )) ENGINE = INNODB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4;
```

data.sql：

```sql
INSERT INTO `article`
VALUES ('1', '2101', 'SpringBoot 核心注解', '核心注解的主要作用', '00000008976', '2023-01-16 12:11:12', '2023-01-16 12:11:19');
INSERT INTO `article`
VALUES ('2', '356752', 'JVM 调优', 'HotSpot 虚拟机详解', '00000000026', '2023-01-16 12:15:27', '2023-01-16 12:15:30');
```

IDEA提示没有数据源，点击右边的数据库图标，点击加号，添加一个数据源：

![image-20240705172503364](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407051725430.png)

然后要在sql文件的上面进行选择：

![image-20240705172617234](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407051726279.png)

接下来在application.properties中配置数据库数据源和设置执行数据库脚本：

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/springboot009-blog
spring.datasource.username=root
spring.datasource.password=1234

spring.sql.init.mode=always
```

+ 不需要指定驱动器名字，因为可以从url中推断出来

然后可以启动项目，数据库中应该就会有一张表和两个数据：

![image-20240705173136082](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407051731144.png)

成功之后，就可以将application.properties中的spring.sql.init.mode=always改为never了，否则每次启动项目都会初始化一遍，可能导致数据被覆盖。

## JdbcTemplate 访问 MySQL

项目中依赖了 spring-jdbc 6.0.3，JdbcTemplate 对象会自动创建好。把 JdbcTemplate 对象注入给你的 Bean，再调用 JdbcTemplate 的方法执行查询，更新，删除的 SQL。

JdbcTemplate 上手快，功能非常强大。提供了丰富、实用的方法，归纳起来主要有以下几种类型的方法：
（1）execute 方法：可以用于执行任何 SQL 语句，常用来执行 DDL 语句。
（2）update、batchUpdate 方法：用于执行新增、修改与删除等语句。
（3）query 和 queryForXXX 方法：用于执行查询相关的语句。
（4）call 方法：用于执行数据库存储过程和函数相关的语句。

创建实体类Article：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Article {
    private Integer id;
    private Integer userId;
    private String title;
    private String summary;
    private Integer readCount;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}
```

### 查询

进行测试，查询数据库中有多少条数据：

```java
@SpringBootTest
class Springboot009JdbctemplateApplicationTests {
    @Autowired
    private JdbcTemplate jdbcTemplate;

    @Test
    void test01() {
        String sql = "select count(*) from article";
        Long cnt = jdbcTemplate.queryForObject(sql, Long.class);
        System.out.println(cnt);
    }
}
```

输出结果：2

测试占位符 ？：

```java
@Test
void test01() {
    String sql = "select * from article where id= ? ";
    Article cnt = jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper<>(Article.class), 1);
    System.out.println(cnt);
}
```

+ 使用 BeanPropertyRowMapper 将查询结果集转为实体对象，需要列名与属性名称匹配，像列名为a，属性名也为a，就有个setA方法；像列名为a_b，属性名为aB，就有个setAB方法。
+ 如果有多个占位数，需要多个参数，可以在queryForObject方法的第二个参数后面继续添加

输出结果：

```java
Article(id=1, userId=2101, title=SpringBoot 核心注解, summary=核心注解的主要作用, readCount=8976, createTime=2023-01-16T12:11:12, updateTime=2023-01-16T12:11:19)
```

如果输入一个错误的id，那么queryForObject找不到数据或者找出多个数据就会报错，queryForObject只期望一个数据。

其中这个 BeanPropertyRowMapper 类实现了一个接口RowMapper：

![image-20240706204339950](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407062043041.png)

这个接口是一个函数接口，只有一个方法：

```java
@FunctionalInterface
public interface RowMapper<T> {
    @Nullable
    T mapRow(ResultSet rs, int rowNum) throws SQLException;
}
```

作用是将结果集rs，转换为对应的对象T，代表的是一行记录。那么看这个方法在 BeanPropertyRowMapper 中的实现：

![image-20240706204858228](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407062048304.png)

那么我们可以自定义一个实现类实现rowMapper接口，来处理结果集像实体类的转换。查看queryForObject这个方法：

```java
@Nullable
public <T> T queryForObject(String sql, RowMapper<T> rowMapper, @Nullable Object... args) throws DataAccessException {
    List<T> results = (List)this.query((String)sql, (Object[])args, (ResultSetExtractor)(new RowMapperResultSetExtractor(rowMapper, 1)));
    return DataAccessUtils.nullableSingleResult(results);
}
```

可以看到，只需要实现第二个参数就可以了：

```java
@Test
void test02() {
    String sql = "select * from article where id = 1";
    Article article = jdbcTemplate.queryForObject(sql, (res, rowNumber) -> {
        int id = res.getInt("id");
        int userId = res.getInt("user_id");
        String title = res.getString("title");
        String summary = res.getString("summary");
        int readCount = res.getInt("read_count");
        var createTime = new Timestamp(res.getTimestamp("create_time").getTime()).toLocalDateTime();
        var updateTime = new Timestamp(res.getTimestamp("update_time").getTime()).toLocalDateTime();
        return new Article(id, userId, title, summary, readCount, createTime, updateTime);
    });
    System.out.println(article);
}
```

如果要查询多条记录，可以使用queryForList方法，得到的是一个List集合，集合中放的是Map<String, Object>，对应着<列，值>，一个map对象就是一行记录。queryForList不论是零行记录还是多行记录都不会报错：

```java
@Test
void test03() {
    String sql = "select * from article";
    List<Map<String, Object>> maps = jdbcTemplate.queryForList(sql);
    // 遍历所有记录
    maps.forEach(map -> {
        // 遍历记录的每一列
        map.forEach((key, value) -> {
            System.out.println(key + " : "  + value);
        });
        System.out.println("==============");
    });
}
```

输出结果：

```java
id : 1
user_id : 2101
title : SpringBoot 核心注解
summary : 核心注解的主要作用
read_count : 8976
create_time : 2023-01-16T12:11:12
update_time : 2023-01-16T12:11:19
==============
id : 2
user_id : 356752
title : JVM 调优
summary : HotSpot 虚拟机详解
read_count : 26
create_time : 2023-01-16T12:15:27
update_time : 2023-01-16T12:15:30
==============
```

### 添加删除更新

添加删除更新操作都用update方法，该方法返回影响的行数。

更新id为1的文章的标题为“哈哈哈hi哈”：

```java
@Test
void test04() {
    String sql = "update article set title = ? where id = ?";
    int cnt = jdbcTemplate.update(sql, "哈哈哈hi哈", 1);
    System.out.println(cnt);
}
```

## NamedParameterJdbcTemplate

NamedParameterJdbcTemplate 能够接受命名的参数，通过具名的参数提供代码的可读性，JdbcTemplate 使用的是参数索引的方式，就是按照sql语句中的？位置来依次赋值。NamedParameterJdbcTemplate 使用除了命名参数外，和 JdbcTemplate 一样。

通过NamedParameterJdbcTemplate的源码可以看到，他其实还是JdbcTemplate ：

```java
public NamedParameterJdbcTemplate(DataSource dataSource) {
    Assert.notNull(dataSource, "DataSource must not be null");
    this.classicJdbcTemplate = new JdbcTemplate(dataSource);
}
```

在使用模板的位置注入 NamedParameterJdbcTemplate 对象，编写 SQL 语句，在 SQL 中 WHERE 部分“:命名参数”。调用 NamedParameterJdbcTemplate 的诸如 query，queryForObject, execute,update 等时，将参数封装到Map 中，map的key就是参数的名字，value就是参数的值：

```java
@Autowired
NamedParameterJdbcTemplate namedParameterJdbcTemplate;
@Test
void test05() {
    String sql = "select count(*) from article where id = :uid and read_count > :num";
    Map<String, Object> param = new HashMap<>();
    param.put("uid", 2101);
    param.put("num", 10);
    Long cnt = namedParameterJdbcTemplate.queryForObject(sql, param, Long.class);
    System.out.println(cnt);
}
```

## 多表查询

多表查询关注的是将查询结果如何映射为 Java Object。常用两种方案：一种是将查询结果转为 Map。列名是 key，列值是 value，这种方式比较通用，适合查询任何表。第二种是根据查询结果中包含的列，创建相对的实体类。属性和查询结果的列对应。将查询结果自定义 RowMapper、ResultSetExtractor 映射为实体类对象。

### 使用rowMapper

先新建一张表 article_dettail 存储文章内容，与 article 表是一对一关系：

![image-20240707081416071](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407070814197.png)

```sql
CREATE TABLE `article_detail` (
	`id` INT ( 11 ) NOT NULL AUTO_INCREMENT COMMENT '注解',
	`article_id` INT ( 11 ) NOT NULL COMMENT '文章 ID',
`content` text NOT NULL COMMENT '文章内容',
PRIMARY KEY ( `id` )) ENGINE = INNODB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8mb4;
```

现在要查询某个文章的全部属性，包括文章内容。

先创建一个实体对应article_detail：

```java
@AllArgsConstructor
@NoArgsConstructor
@Data
public class ArticleDetail {
    private Integer id;
    private Integer articleId;
    private String content;
}
```

然后要在Article实体类中添加一个ArticleDetail的属性：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Article {
    private Integer id;
    private Integer userId;
    private String title;
    private String summary;
    private Integer readCount;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private ArticleDetail detail;
}
```

测试查询：

```java
@Test
void test06() {
    String sql = """
        select a.*, b.id as detail_id, b.content, b.article_id 
        from article a join article_detail b
        on a.id = b.article_id 
        where a.id = :id
        """;
    Map<String, Object> param = new HashMap<>();
    param.put("id", 1);
    List<Article> list = namedParameterJdbcTemplate.query(sql, param, (res, rowNumber) -> {
        var id = res.getInt("id");
        var userId = res.getInt("user_id");
        var title = res.getString("title");
        var summary = res.getString("summary");
        var readCount = res.getInt("read_count");
        var createTime = new Timestamp(res.getTimestamp("create_time").getTime()).toLocalDateTime();
        var updateTime = new Timestamp(res.getTimestamp("update_time").getTime()).toLocalDateTime();
        var detailId = res.getInt("detail_id");
        var content = res.getString("content");

        ArticleDetail articleDetail = new ArticleDetail(detailId, id, content);

        return new Article(id, userId, title, summary, readCount, createTime, updateTime, articleDetail);
    });
    list.forEach(System.out::println);
}
```

输出结果：

```java
Article(id=1, userId=2101, title=哈哈哈hi哈, summary=核心注解的主要作用, readCount=8976, createTime=2023-01-16T12:11:12, updateTime=2023-01-16T12:11:19, detail=ArticleDetail(id=1, articleId=1, content=哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈))
```

总结：

+ JdbcTemplate 的优点简单，灵活，上手快，访问多种数据库。对数据的处理控制能力比较强，RowMapper, ResultSetExtractor 能够提供按需要灵活定制记录集与实体类的关系。

  缺点：对 SQL 要求高，适合对 SQL 比较了解，自定义查询结果比较多，调优需求的。

+ JdbcTemplate 对象的调整参数，比较少。可设置 spring.jdbc.template.开头的配置项目，比如设置超时为 10 秒，spring.jdbc.template.query-timeout=10。

# MyBatis

数据库访问 MyBatis，MyBatis-Plus 国内很常用，掌握了 MyBatis，MyBatis-Plus 就会了大部分了。MyBatis-Plus附加的功能需要单独学习。我们以 MyBatis 来自介绍 Spring Boot 集成 ORM 框架。

MyBatis 使用最多的是 mapper.xml 文件编写 SQL 语句。本章使用 MyBatis 的注解，JDK 新特性文本块，以及 Record 完成 java 对象和表数据的处理。

创建一个新的项目，集成mybatis框架，他的依赖项有：

```xml
<dependencies>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>3.0.3</version>
    </dependency>

    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter-test</artifactId>
        <version>3.0.3</version>
        <scope>test</scope>
    </dependency>
</dependencies>
```

然后写配置文件，给定数据库的数据源：

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/springboot009-blog
spring.datasource.username=root
spring.datasource.password=1234
```

创建一个bean包，在bean包下创建文章对应的实体类：

```java
@Data
public class Article {
    private Integer id;
    private Integer userId;
    private String title;
    private String summary;
    private Integer readCount;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
}
```

然后创建一个mapper包，在mapper包下创建mapper文件：

```java
public interface ArticleMapper {
}
```

## 单表CRUD

### 查询

在ArticleMapper中添加方法：

```java
public interface ArticleMapper {
    @Select("""
                select * from article where id = #{id}
            """)
    Article selectById(@Param("id") Integer id);
}
```

然后要在启动类上使用扫描mapper的注解@MapperScan指定需要扫描的包名：

```java
@MapperScan(basePackages = "com.zsm.mapper")
@SpringBootApplication
public class Springboot010MyBtaisApplication {

    public static void main(String[] args) {
        SpringApplication.run(Springboot010MyBtaisApplication.class, args);
    }

}
```

然后在test下创建一个mybatis包，包下创建一个MybatisTest类，测试：

```java
@SpringBootTest
public class MybatisTest {
    @Autowired
    ArticleMapper articleMapper;
    
    @Test
    void testSelectById() {
        Article article = articleMapper.selectById(1);
        System.out.println(article);
    }
}
```

+ @SpringbootTest注解是SpringBoot提供的一个测试注解，他帮助能够加载Spring容器，让我们能够使用这个对象

输出结果：

```java
Article(id=1, userId=null, title=哈哈哈hi哈, summary=核心注解的主要作用, readCount=null, createTime=null, updateTime=null)
```

可以看到除了id、title、summary外，其他属性的值都没有，这是因为查询的结果集的列名和实体类的属性名不一致导致的，所以要开启Mybatis的驼峰映射，就是让以下划线命名的列名转为驼峰命名模式。

需要在application.properties文件中开启配置：

```properties
mybatis.configuration.map-underscore-to-camel-case=true
```

然后再测试，输出结果：

```java
Article(id=1, userId=2101, title=哈哈哈hi哈, summary=核心注解的主要作用, readCount=8976, createTime=2023-01-16T12:11:12, updateTime=2023-01-16T12:11:19)
```

#### @Results

如果查询的结果集的列名既不是和实体类的属性名相同，也没有驼峰命名之间的关系，那么可以使用ResultMap做一个结果映射，使用@Results注解，这个注解源码：

```java
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.METHOD})
public @interface Results {
    String id() default "";

    Result[] value() default {};
}
```

+ id是属性映射的名字
+ value是一个Result数组，代表每个列的一一映射规则
+ 这个注解相当于在MyBatis的mapper.xml文件中使用<ResultMap>

在ArticleMapper接口的方法上使用@Results：

```java
public interface ArticleMapper {
    @Select("""
                select * from article where id = #{id}
            """)
    @Results(id = "ArticleResult", value = {
            @Result(id = true, column = "id", property = "id"),
            @Result(column = "title", property = "title"),
            @Result(column = "summary", property = "sumamry"),
            @Result(column = "read_count", property = "readCount"),
            @Result(column = "user_id", property = "userId"),
            @Result(column = "create_time", property = "createTime"),
            @Result(column = "update_time", property = "updateTime")
    })
    Article selectById(@Param("id") Integer id);
}
```

+ 这个@Result注解：

  ```java
  @Documented
  @Retention(RetentionPolicy.RUNTIME)
  @Target({ElementType.METHOD})
  @Repeatable(Results.class)
  public @interface Result {
      boolean id() default false;  // 表示是不是主键列
  
      String column() default "";  // 列名
  
      String property() default "";  // 属性值
  
      Class<?> javaType() default void.class;  // 属性的类型
  
      JdbcType jdbcType() default JdbcType.UNDEFINED;  // 数据库类型
  
      Class<? extends TypeHandler> typeHandler() default UnknownTypeHandler.class;
  
      One one() default @One;
  
      Many many() default @Many;
  }
  ```

然后关掉驼峰命名映射，重新测试，输出结果：

```java
Article(id=1, userId=2101, title=哈哈哈hi哈, summary=核心注解的主要作用, readCount=8976, createTime=2023-01-16T12:11:12, updateTime=2023-01-16T12:11:19)
```

#### @ResultMap

@Results 用于定义结果映射，每个列和 Java 对象属性的一一对应。

@ResultMap 用来指定使用哪个结果映射。

比如有过个查询方法，返回的类型都是一种，使用@ResultMap注解就不需要写多次@Resutls：

```java
public interface ArticleMapper {
    @Select("""
                select * from article where id = #{id}
            """)
    @Results(id = "ArticleResult", value = {
            @Result(id = true, column = "id", property = "id"),
            @Result(column = "title", property = "title"),
            @Result(column = "summary", property = "summary"),
            @Result(column = "read_count", property = "readCount"),
            @Result(column = "user_id", property = "userId"),
            @Result(column = "create_time", property = "createTime"),
            @Result(column = "update_time", property = "updateTime")
    })
    Article selectById(@Param("id") Integer id);

    @Select("""
                select * from article where id = #{id}
            """)
    @ResultMap("ArticleResult")
    Article selectById2(@Param("id") Integer id);

}
```

### 添加

添加insert语句会返回一个int值，表示影响的行数。

在ArticleMapper中添加一个方法：

```java
@Insert("""
        insert into article(user_id, title, summary, read_count, create_time, update_time)
        values(#{userId}, #{title}, #{summary}, #{readCount}, #{createTime}, #{updateTime})
        """)
int insert(Article article);
```

然后测试：

```java
@Test
void testInsert() {
    Article article = new Article(null, 2101, "第三篇文章", "mybtais插入", 123, LocalDateTime.now(), LocalDateTime.now());
    int count = articleMapper.insert(article);
    System.out.println(count);
}
```

输出结果为1，查看数据库数据：

![image-20240707104620119](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071046258.png)

### 更新

更新某个文章的数量。

在ArticleMapper中添加一个方法：

```java
@Update("""
        update article  set read_count = #{cnt} where id = #{id}
        """)
int update(Integer id, Integer cnt);
```

测试：

```java
@Test
void testUpdate() {
    articleMapper.update(1, 4000);
}
```

结果：

![image-20240707105217503](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071052611.png)

### 删除

```java
@Delete("delete from article where id = #{id}")
int deleteById(Integer id);
```

```java
@Test
void testDeleteById() {
    articleMapper.deleteById(1);
}
```

## 结果映射

将查询结果中的列和实体类的属性一一对应起来。

在MyBatis的mapper.xml文件中使用<resultMap>标签来定义映射关系，在<select>标签中可以使用某个resultMap：

```xml
<resultMap id="carResultMap" type="car">
  <!--对象的唯一标识，官方解释是：为了提高mybatis的性能。建议写上。-->
  <id property="id" column="id"/>
  <result property="carNum" column="car_num"/>
  <!--当属性名和数据库列名一致时，可以省略。但建议都写上。-->
  <!--javaType用来指定属性类型。jdbcType用来指定列类型。一般可以省略。-->
  <result property="brand" column="brand" javaType="string" jdbcType="VARCHAR"/>
  <result property="guidePrice" column="guide_price"/>
  <result property="produceTime" column="produce_time"/>
  <result property="carType" column="car_type"/>
</resultMap>

<!--resultMap属性的值必须和resultMap标签中id属性值一致，用来指定使用哪个结果集 。-->
<select id="selectAllByResultMap" resultMap="carResultMap">
  select * from t_car
</select>
```

使用注解开发的话就用@Resuls、@Result、@ResultMap三个注解

+ @Resuls相当于<resultMap>标签
+ @Result相当于<result>标签
+ @ResultMap相当于<select>标签中的resultMap属性

@ResultMap的用法：

+ 先使用@Result定义映射关系，然后使用：@ResultMap("@Results的id")。
+ 在xml文件中定义<resultMap id="xxx">，然后在代码中使用：@ResultMap("xml文件中的id")。

在resources下创建一个目录mapper，在mapper目录下创建一个ArticleMapper.xml文件：

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!--指定命名空间，一般和mapper接口的全限定名称一样-->
<mapper namespace="com.zsm.mapper.ArticleMapper">
    <resultMap id="ArticleResultXML" type="com.zsm.bean.Article">
        <id column="id" property="id"/>
        <result column="user_id" property="userId" />
        <result column="read_count" property="readCount" />
        <result column="create_time" property="createTime" />
        <result column="update_time" property="updateTime" />
    </resultMap>
</mapper>
```

然后要在application.properties文件中配置mapper.xml文件的路径：

```properties
mybatis.mapper-locations=classpath:mapper/**/*.xml
```

+ 表示类路径下mapper目录下的任意子目录的任意.xml文件

然后在查询方法上使用@ResultMap注解指定这个resutlMap：

```java
@Select("""
        select * from article where id = #{id}
        """)
@ResultMap("ArticleResultXML")
Article selectById2(Integer id);
```

然后测试：

```java
@Test
void testSelectById2() {
    Article article = articleMapper.selectById2(2);
    System.out.println(article);
}
```

输出结果：

```java
Article(id=2, userId=356752, title=JVM 调优, summary=HotSpot 虚拟机详解, readCount=26, createTime=2023-01-16T12:15:27, updateTime=2023-01-16T12:15:30)
```

## SQL提供者

我们能在方法上面直接编写 SQL 语句。使用 Text Block 编写长的语句。但是方法上编写 SQL 显的不够简洁。

MyBatis 提供了 SQL 提供者的功能。将 SQL 以方法的形式定义在单独的类中。 Mapper 接口通过引用 SQL 提供者中的方法名称，表示要执行的 SQL。

首先要先创建一个类，作为提供者类，在这个类中定义静态方法，方法的返回值就是sql语句，比如：

```java
public static String selectById() {
	return "SELECT * FROM users WHERE id = #{id}";
}
```

SQL 提供者有四个注解：

+ @SelectProvider，提供查询语句
+ @InsertProvider，
+ @UpdateProvider，
+ @DeleteProvider。

需要在mapper接口的方法上面使用某一个注解，像：`@SelectProvider(type=提供者类.class, method="方法名称")`。

创建一个provider包，包下创建一个SqlProvider类：

```java
public class SqlProvider {
    public static String selectById() {
        return "select * from  article where id = #{id}";
    }

    public static String updateUpdateTime() {
        return "update article set update_time = #{updateTime}";
    }
}
```

+ 方法返回的就是sql语句
+ 方法有没有参数都可以
+ sql语句中的参数来自mapper接口的方法

然后新建一个mapper接口：

```java
public interface NewArticleMapper {
    @Select("select * from article")
    @Results(id = "NewArticleResult", value = {
            @Result(id = true, column = "id", property = "id"),
            @Result(column = "title", property = "title"),
            @Result(column = "summary", property = "summary"),
            @Result(column = "read_count", property = "readCount"),
            @Result(column = "user_id", property = "userId"),
            @Result(column = "create_time", property = "createTime"),
            @Result(column = "update_time", property = "updateTime")
    })
    Article newArticleMapper();

    @SelectProvider(type = SqlProvider.class, method = "selectById")
    @ResultMap("NewArticleResult")
    Article selectById(Integer id);
}
```

+ 可以在一个不会被调用的方法上定义@Results，但是必须要要和@Select一起使用，而且@Select中不能有空的语句，必须要有语句

测试：

```java
@Autowired
NewArticleMapper articleMapper;

@Test
void testSelectById() {
    Article article = articleMapper.selectById(2);
    System.out.println(article);
}
```

输出结果：

```java
Article(id=2, userId=356752, title=JVM 调优, summary=HotSpot 虚拟机详解, readCount=26, createTime=2023-01-16T12:15:27, updateTime=2023-01-16T12:15:30)
```

其他的提供者用法都是一样的。

## @One一对一查询

MyBatis 支持一对一，一对多，多对多查询。XML 文件和注解都能实现关系的操作。我们使用注解表示 article 和 article_detail 的一对一关系。 MyBatis 维护这个关系， 开发人员自己也可以维护这种关系。

+ @One: 一对一
+ @Many: 一对多

两个实体：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Article {
    private Integer id;
    private Integer userId;
    private String title;
    private String summary;
    private Integer readCount;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private ArticleDetail detail;
}
```

```java
@AllArgsConstructor
@NoArgsConstructor
@Data
public class ArticleDetail {
    private Integer id;
    private Integer articleId;
    private String content;
}
```

现在要查询一篇文章的话，也要将其中的detail查到，那就需要两次查找，一次查找文章，一次查找详情。

创建mapper接口文件：

```java
public interface OneToOneMapper {
    @Select("select * from article_detail where article_id = #{id}")
    @Results({
            @Result(column = "id", property = "id"),
            @Result(column = "article_id", property = "articleId"),
            @Result(column = "content", property = "content"),
    })
    ArticleDetail selectArticleDetailById(Integer id);

    @Select("select * from article where id = #{id}")
    @Results(id = "ArticleResult", value = {
            @Result(id = true, column = "id", property = "id"),
            @Result(column = "title", property = "title"),
            @Result(column = "summary", property = "summary"),
            @Result(column = "read_count", property = "readCount"),
            @Result(column = "user_id", property = "userId"),
            @Result(column = "create_time", property = "createTime"),
            @Result(column = "update_time", property = "updateTime"),
            @Result(column = "id", property = "detail",
                    one = @One(select = "com.zsm.mapper.OneToOneMapper.selectArticleDetailById",
                            fetchType = FetchType.LAZY)
            ),
    })
    Article selectArticleById(Integer id);
}
```

+ one属性表示这是一对一关系
+ @One注解表示另一方，指定了一个查询接口，会将该接口的查询结果赋值给当前property，并且启用了懒加载

然后测试：

```java
@Autowired
OneToOneMapper mapper;
@Test
public void test01() {
    Article article = mapper.selectArticleById(2);
    System.out.println(article);
}
```

在application.properties中可以开启mybatis的默认的日志框架，记录日志：

```properties
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
```

然后运行测试代码，查看日志：

![image-20240707141129953](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071411099.png)

输出结果：

```java
Article(id=2, userId=356752, title=JVM 调优, summary=HotSpot 虚拟机详解, readCount=26, createTime=2023-01-16T12:15:27, updateTime=2023-01-16T12:15:30, detail=ArticleDetail(id=1, articleId=2, content=哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈))
```

## @Many一对多查询

一对多查询使用@Many 注解，步骤与一对一基本相同。

创建comment评论表，article与comment存在一对多关系。

![image-20240707141545295](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071415409.png)

然后创建comment实体：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class comment {
    private Integer id;
    private Integer articleId;
    private String content;
}
```

修改Article实体，添加评论属性，使用List集合：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Article {
    private Integer id;
    private Integer userId;
    private String title;
    private String summary;
    private Integer readCount;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private List<Comment> comments;
}
```

在mapper接口中添加方法，查询某一个文章的评论：

```java
@Select("select * from comment where article_id = #{id}")
@Results({
    @Result(column = "id", property = "id"),
    @Result(column = "article_id", property = "articleId"),
    @Result(column = "content", property = "content")
})
List<Comment> selectComments(Integer id);
```

查询某一个文章的接口：

```java
@Select("select * from article where id = #{id}")
@Results(id = "ArticleResult", value = {
    @Result(id = true, column = "id", property = "id"),
    @Result(column = "title", property = "title"),
    @Result(column = "summary", property = "summary"),
    @Result(column = "read_count", property = "readCount"),
    @Result(column = "user_id", property = "userId"),
    @Result(column = "create_time", property = "createTime"),
    @Result(column = "update_time", property = "updateTime"),
    @Result(column = "id", property = "comments",
            many = @Many(select = "com.zsm.mapper.OneToManyMapper.selectComments",
                         fetchType = FetchType.LAZY)
           )
})
Article selectById(Integer id);
```

测试：

```java
@Autowired
OneToManyMapper dao;
@Test
void test02() {
    Article article = dao.selectById(2);
    System.out.println(article);
}
```

输出结果：

```java
Article(id=2, userId=356752, title=JVM 调优, summary=HotSpot 虚拟机详解, readCount=26, createTime=2023-01-16T12:15:27, updateTime=2023-01-16T12:15:30, detail=null, comments=[Comment(id=1, articleId=2, content=good), Comment(id=2, articleId=2, content=还不错)])
```

![image-20240707143033400](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071430541.png)

## 常用配置参数

MyBatis 的项设置，在 application 文件中“mybatis”开头进行设置。

## MybatisAutoConfiguration
MyBatis 框架在 Spring Boot 中的自动配置类是 MybatisAutoConfiguration.class：

![image-20240707144204099](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071442262.png)

该类注解上有一个配置类MybatisProperties，点击过去：

![image-20240707144432232](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071444403.png)

+ configLocation：用来配置mybatis主配置文件的
+ mapperLocation：用来配置mapper文件的
+ typeAliasesPackage，用来配置别名包的

# 适合的连接池

HikariCP 连接池
https://github.com/brettwooldridge/HikariCP/wiki

连接池配置：
https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing

MySQL 连接池配置建议
https://github.com/brettwooldridge/HikariCP/wiki/MySQL-Configuration

prepStmtCacheSize：这将设置 MySQL 驱动程序将缓存每个连接的预准备语句数。默认值为保守的 25。我们建议将其设置为 250-500 之间。

prepStmtCacheSqlLimit：这是驱动程序将缓存的准备好的 SQL 语句的最大长度。MySQL 默认值为 256。根据我们的经验，特别是对于像 Hibernate 这样的 ORM 框架，这个默认值远低于生成的语句长度的阈值。我们推荐的设置为 2048。

cachePrepStmts：如果缓存实际上被禁用，则上述参数都没有任何影响，因为默认情况下是禁用的。必须将此参数设置为 true

useServerPrepStmts：较新版本的 MySQL 支持服务器端准备语句，这可以提供实质性的性能提升。将此属性设置为 true

application.yml：

```yaml
spring:
	datasource:
		type: com.zaxxer.hikari.HikariDataSource
		driver-class-name: com.mysql.cj.jdbc.Driver
		url: jdbc:mysql://localhost:3306/blog?serverTimezone=Asia/Shanghai
		username: root
		password: 123456
        hikari:
            auto-commit: true
            # # connections = ((cpu 核心数 * 2) + 磁盘数量) 近似值。 默认 10
            maximum-pool-size: 10
            #最小连接数，默认 10，不建议设置。默认与 maximum-pool-size 一样大小。推荐使用
            固定大小的连接池
            minimum-idle: 10
            #获取连接时，检测语句
            connection-test-query: select 1
            ###
            # 连接超时，默认 30 秒。
            # 控制客户端在获取池中 Connection 的等待时间，
            # 如果没有连接可用的情况下超过该时间，则抛出 SQLException 异常，
            ###
            connection-timeout: 20000
            #其他属性
            data-source-properties:
                cachePrepStmts: true
                dataSource.cachePrepStmtst: true
                dataSource.prepStmtCacheSize: 250
                dataSource.prepStmtCacheSqlLimit: 2048
                dataSource.useServerPrepStmts: true
```

# 声明式事务

事务分为全局事务与本地事务，本地事务是特定于资源的，例如与 JDBC 连接关联的事务。本地事务可能更容易使用，但有一个显著的缺点:它们不能跨多个事务资源工作。比如在方法中处理连接多个数据库的事务，本地事务是无效的。

Spring 解决了全局和本地事务的缺点。它允许应用程序开发人员在任何环境中使用一致的编程模型。只需编写一次代码，就可以从不同环境中的不同事务管理策略中获益。Spring 框架同时提供声明式和编程式事务管理。推荐声明式事务管理

Spring 事务抽象的关键是事务策略的概念，org.springframework.transaction.PlatformTransactionManager 接口定义了事务的策略。

事务控制的属性：

+ Propagation : 传播行为。代码可以继续在现有事务中运行(常见情况)，也可以暂停现有事务并创建新事务
+ Isolation: 隔离级别。此事务与其他事务的工作隔离的程度。例如，这个事务能看到其他事务未提交的写吗?
+ Timeout 超时时间:该事务在超时和被底层事务基础结构自动回滚之前运行的时间。
+ Read-only 只读状态:当代码读取但不修改数据时，可以使用只读事务。在某些情况下，例如使用 Hibernate时，只读事务可能是一种有用的优化。

Spring Framework 的声明式事务管理是通过 Spring 面向方面编程(AOP)实现的。事务方面的代码以样板的方式使用，及时不了解 AOP 概念，仍然可以有效地使用这些代码。事务使用 AOP 的环绕通知（TransactionInterceptor）。

声明式事务的方式：

+ XML 配置文件：全局配置
+ @Transactional 注解驱动 ：和代码一起提供，比较直观。和代码的耦合比较高。【Spring 团队建议您只使用@Transactional 注释具体类(以及具体类的方法)，而不是注释接口。当然，可以将@Transactional 注解放在接口(或接口方法)上，但这只有在使用基于接口的代理时才能正常工作】

方法的可见性：

公共(public)方法应用@Transactional 注解。如果使用@Transactional 注释了受保护的、私有的或包可见的方法，则不会引发错误，但注释的方法不会显示配置的事务设置，事务不生效。如果需要受保护的、私有的方法具有事务考虑使用 AspectJ。而不是基于代理的机制。

## 准备环境

新建项目，添加MyBatis、MySqlDriver、Lombok的依赖。使用之前的数据库的article、article_detail表。

在启动类上添加@MapperScan注解。在application.properties中配置数据源。

创建两个实体类：

```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Article {
    private Integer id;
    private Integer userId;
    private String title;
    private String summary;
    private Integer readCount;
    private LocalDateTime createTime;
    private LocalDateTime updateTime;
    private ArticleDetail detail;
}
```

```java
@AllArgsConstructor
@NoArgsConstructor
@Data
public class ArticleDetail {
    private Integer id;
    private Integer articleId;
    private String content;
}
```

现在向article表中插入一条数据，article_detail表中也要同时插入一条数据，需要事务控制两个表的insert操作。

创建一个mapper接口：

```java
public interface ArticleMapper {

    @Insert("""
                insert into article values(#{id}, #{userId}, #{title}, #{summary}, #{readCount}, #{createTime}, #{updateTime}, #{detail})
            """)
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "id")
    int addArticle(Article article);

    @Insert("""
                insert into article_detial values(#{articleId}, #{content})
            """)
    int addArticleDetail(ArticleDetail articleDetail);
}
```

其中向article_detail表中插入数据时，需要赋值article_id，这个id就需要在数据插入article表中之后才能拿到，所以需要使用一个注解@Options，@Options(useGenerateKeys = true)就能获取数据库自动增长的那个值，将数据库的id列的值映射到实体类的id属性。

然后创建业务类：

```java
public interface ArticleService {
    boolean postArticle(Article article, String content);
}
```

实现类：

```java
@Service
public class ArticleServiceImpl implements ArticleService {
    @Autowired
    ArticleMapper mapper;
    @Override
    public boolean postArticle(Article article, String content) {
        int cnt = mapper.addArticle(article);

        ArticleDetail articleDetail = new ArticleDetail(null, article.getId(), content);

        cnt += mapper.addArticleDetail(articleDetail);

        return cnt >= 2;
    }
}
```

当前只能判断两次新增操作是否成功。

测试：

```java
@Autowired
private ArticleServiceImpl dao;
@Test
void test01() {
    String content = "不能睡觉不能睡觉，好好学习天天向上";
    Article article = new Article(null, 2102, "我想睡觉", "不能睡", 1234, LocalDateTime.now(), LocalDateTime.now(),null);
    boolean ok = dao.postArticle(article, content);
    System.out.println("" + ok);
}
```

现在业务方法正常执行，添加数据到两个表，但是事务没有 Spring 参与。 postArticle()方法没有事务管理：

![image-20240707160706738](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071607907.png)

## 添加事务注解

给这个业务方法加上事务控制，在postArticle方法上加上注解@Transactional：

```java
@Transactional
@Override
public boolean postArticle(Article article, String content) {
    int cnt = mapper.addArticle(article);

    // 抛出异常
    if (article.getReadCount() < 1) throw new RuntimeException("异常");

    ArticleDetail articleDetail = new ArticleDetail(null, article.getId(), content);

    cnt += mapper.addArticleDetail(articleDetail);

    return cnt >= 2;
}
```

+ @Transactional：事务控制注解，可以放在方法上，也可以放在类上。放在类上的话，该类中的所有方法都会有事务控制
+ 为了能看到事务是否起了作用，要在程序中手动抛出一个异常模拟业务中失败的情况，当碰到一个运行时异常时，Spring默认会回滚事务。

还要在启动类上开启事务管理器@EnableTransactionManagement（可选的，不加这个注解也可以开启事务管理器）。

然后重新测试：

```java
@Test
void test02() {
    String content = "=======不能睡觉不能睡觉，好好学习天天向上======";
    Article article = new Article(null, 2102, "我想睡觉=====", "=====不能睡", 0, LocalDateTime.now(), LocalDateTime.now(),null);
    boolean ok = dao.postArticle(article, content);
    System.out.println("" + ok);
}
```

注意阅读量属性是0，结果抛出了异常：

![image-20240707161550892](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071615045.png)

查看数据库中的数据，这条新的数据没有被插入到任何一张表。

还可以通过@Transactional来指定需要回滚的异常列表：

```java
@Transactional(rollbackFor = {IOException.class})
```

+ rollbackFor指定需要回滚的异常列表，当前程序如果抛出IO异常，则会回滚事务。

## 无效的事务

### 无效事务1

Spring 事务处理是 AOP 的环绕通知，只有通过代理对象调用具有事务的方法才能生效。类中有 A 方法，通过A方法调用带有事务的 B 方法时，运行 A 方法的时候事务无效，因为AOP只拦截了A方法。当然 protected, private 方法默认是没有事务功能的。

在mapper接口中新增一个方法：

```java
boolean addArticle(Article article, String content);
```

实现这个方法，在方法中调用具有事务的postArticle方法：

```java
@Override
public boolean addArticle(Article article, String content) {
    return postArticle(article, content);
}
```

测试：

```java
@Test
void test03() {
    String content = "+++++++不能睡觉不能睡觉，好好学习天天向上======";
    Article article = new Article(null, 2102, "我想睡觉=====", "=====不能睡", 0, LocalDateTime.now(), LocalDateTime.now(),null);
    boolean ok = dao.addArticle(article, content);
}
```

这个测试会抛出异常，因为readCount是0，那么article和article_detail两张表都不会插入数据，但是是通过没有事务的addArticle方法调用的有事务的postArticle方法，所以事务是无效的：

![image-20240707163122462](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071631622.png)

在article表中有了数据：

![image-20240707163149726](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071631866.png)

### 无效事务2

方法在线程中运行的，在同一线程中方法具有事务功能， 新的线程中的代码事务无效。

在有事务的postArticle方法中开启一个新的线程，那么在这个新的线程中，事务是无效的：

```java
@Transactional
@Override
public boolean postArticle(Article article, String content) {
    System.out.println("Start 主线程" + Thread.currentThread().threadId());

    Thread thread = new Thread(() -> {
        System.out.println("Start 子线程" + Thread.currentThread().threadId());
        int cnt = mapper.addArticle(article);

        // 抛出异常
        if (article.getReadCount() < 1) throw new RuntimeException("========异常-==========");

        ArticleDetail articleDetail = new ArticleDetail(null, article.getId(), content);

        cnt += mapper.addArticleDetail(articleDetail);
        System.out.println("End 子线程" + Thread.currentThread().threadId());
    });
    thread.start();
    try {
        thread.join();
    } catch (InterruptedException e) {
        e.printStackTrace();
    }
    
    System.out.println("End 主线程" + Thread.currentThread().threadId());
    return true;
}
```

测试：

```java
@Test
void test02() {
    String content = "=======不能睡觉不能睡觉，好好学习天天向上======";
    Article article = new Article(null, 2102, "我想睡觉=====", "=====不能睡", 0, LocalDateTime.now(), LocalDateTime.now(),null);
    boolean ok = dao.postArticle(article, content);
    System.out.println("" + ok);
}
```

结果：

![](https://gitee.com/LowProfile666/image-bed/raw/master/img/202407071644640.png)

数据库中的article表中还是多了条数据。

## 事务回滚规则

+ 碰到 RuntimeException 的实例或子类时回滚事务；
+ Error 会导致回滚；
+ 已检查异常不会回滚。默认提交事务；

@Transactional 注解的属性控制回滚

+ rollbackFor
+ noRollbackFor
+ rollbackForClassName
+ noRollbackForClassName

