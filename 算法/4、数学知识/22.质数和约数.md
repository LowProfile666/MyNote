# 质数

质数是针对所有大于 1 的自然数来说的。所有小于 等于 1 的数既不是质数也不是合数。

质数：在大于 1 的整数中，如果只包含 1 和本身这个两个约数，就被称为质数，或者叫素数。

## 质数的判定

试除法，$O(sqrt(n))$

暴力枚举的方法：

```java
boolean isPrime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x; i ++ )  
        if (x % i == 0)
            return false;
    return true;
}
```

但是我们知道，如果有一个数 d 可以整除数 n，那么一定也会有一个数 n/d 也可以整除 n，因为约数都是成对出现的，所以我们可以只枚举较小的一个数，假如 d <= n/d，那么就有 d^2^ <= n，就有 $d \le \sqrt{n}$ 。

所以有模板：

```java
boolean isPrime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )  // (1)
        if (x % i == 0)
            return false;
    return true;
}
```

关于（1）的位置有很多种写法：

+ `i * i <= n` ：有可能会发生溢出
+ `i <= Math.sqrt(n)` ：每次循环都会调用一次 sqrt 方法，浪费时间

## 分解质因数

试除法，$O(logn)--O(sqrt(n))$，从小到大枚举所有的 n 的因数，求出这个因数的个数。

n 中最多只包含一个大于 $\sqrt{n}$ 的质因子，因为如果有两个的话，乘一起就大于 n 了，所以只需要枚举到 n/i 就行了。

模板：

```java
void divide(int x) {
    for (int i = 2; i <= x / i; i ++ )
        if (x % i == 0) {
            int s = 0;  // 记因数的个数
            while (x % i == 0) {
                x /= i;   // x 会改变，所以一定不会枚举到合数因数
                s ++ ;
            }
            System.out.println(i + " " + s);
        }
    if (x > 1) System.out.println(x + " " + 1);
}
```

## 筛素数

埃氏筛法：把所有的数都写到一个数表中，然后从前往后看，把所有数的倍数删掉，比如看到 2 的时候，就删掉 4、6、8、10、……，看到 3 的时候，就删掉 9、12、……，其中 3 的倍数 6 已经被删掉了。这样删完之后，所有的剩下的数都是质数，因为假如一个数 p 没有被删掉的话，那说明 p 不是从 2 到 p-1 的所有数的倍数，那他就是个质数。

模板：

```java
int primes = new int[N];  // primes[]存储所有素数
int cnt;     
boolean f = new boolean[N];  // f[x]存储x是否被筛掉

void getPrimes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (f[i]) continue;
        primes[cnt ++ ] = i;
        for (int j = i + i; j <= n; j += i)
            f[j] = true;
    }
}
```

线性筛法：把每个合数，用它的素因子筛掉它。

模板：

```java
int[] primes = new int[N];  // primes[]存储所有素数
int cnt;     
boolean f = new boolean[N];  // f[x]存储x是否被筛掉

void getPrimes(int n) {
    for (int i = 2; i <= n; i ++ ) {
        if (!f[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ ) {
            f[primes[j] * i] = true;
            if (i % primes[j] == 0) break;  // 这句话成立的时候，prims[j]一定是i的最小质因子
        }
    }
}
```

核心：n 只会被最小的质因子筛掉

+ `i % primes[j] == 0`：primes[j] 一定是 i 的最小质因子，primes[j] 一定是 primes[j] \* i 的最小质因子
+ `i % primes[j] != 0`：primes[j] 一定小于 i 的所有质因子，primes[j] 也一定是 primes[j] \* i 的最小质因子

# 约数

## 试除法求约数

从小到大判断，如果当前数可以整除这个数 n 的话，当前数就是 n 的约数。

枚举的时候也是可以只枚举较小的约数的，因为约数都成对出现的，求出一个约数，另一个约数是可以直接算出来的。

模板：

```java
List<Integer> getDivisors(int x) {
    List<Integer> res = new ArrayList<>();
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0) {
            res.add(i);
            if (i != x / i) res.add(x / i);
        }
    res.
    return res;
}
```

