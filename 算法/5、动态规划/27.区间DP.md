# 石子合并

> 设有 N 堆石子排成一排，其编号为 1,2,3,…,N
>
> 每堆石子有一定的质量，可以用一个整数来描述，现在要将这 N 堆石子合并成为一堆。
>
> 每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

状态表示的时候，$f[i,j]$ 是表示某一个区间，第 i 堆石子到第 j 堆石子的这段区间。$f[i,j]$​ 表示的是这个区间 中所有的合并方式的最小值。

所以最后的答案就是 $f[1,N]$ ，将第 1 堆石子合并到第 N 堆石子需要的最小代价。

![image-20240314082217650](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403140822767.png)

合并石子的最后一步，一定是将两堆合并为一堆，可以以最后一次合并的分界线的位置来分类。将分界线左边的合成一堆，将分界线右边的合成一堆，最后将分界线两边的合成一堆。

假设区间中有 k 堆石子，这样分类：

+ 左边 1 堆，右边 k-1 堆，分界线的位置是 1
+ 左边 2 堆，右边 k-2 堆，分界线的位置是 2
+ ……
+ 左边 k-1 堆，右边 1 堆，分界线的位置是 k-1

假如此时分界线是 k，那么最终将第 i 堆石子合并到第 j 堆石子的最小代价为：

$f[i,j]=f[i,k]+f[k+1,j]+s[j]-s[i-1]$​​ ，

+ 此时的区间 $[i,j]$ 中分为了两部分，左边是 $[i,k]$ ，右边是 $[k+1,j]$ ，那么合并 $[i,j]$ 区间中的石子的最小代价就是等于合并左边部分的最小代价加上合并右边部分的最小代价，再加上合并这两部分所需要的代价，也就是所有的石子重量之和。
+ s 表示前缀和数组。

[合并石子](https://www.acwing.com/problem/content/284/)

代码中按照区间长度来枚举，因为计算每一种状态时都要提前将它依赖的状态算好。

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] s = new int[n + 1];
        int[][] f = new int[n + 1][n + 1];
        
        for (int i = 1; i <= n; i++) s[i] = sc.nextInt();
        for (int i = 1; i <= n; i++) s[i] += s[i - 1];  // 处理前缀和
        
        for (int len = 2; len <= n; len++)  // 枚举区间长度，长度为 1 时不需要合并
            for (int i = 1; i + len - 1 <= n; i++) {  // 枚举起点
                int j = i + len - 1;  // 终点
                f[i][j] = (int)1e9;  // 初始化，否则是 0
                for (int k = i; k < j; k++)  // 枚举分界线
                    f[i][j] = Math.min(f[i][j], f[i][k] + f[k + 1][j] + s[j] - s[i - 1]);
            }
            
        System.out.println(f[1][n]);
    }
}
```

