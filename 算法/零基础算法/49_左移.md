# 左移

## 1. 概念定义

### 1）按位左移

左移也就是按位左移，顾名思义就是按二进制位进行“左移”操作。



按位左移运算符 `<<` 是一个双目运算符，其功能是将一个数的二进制位全部左移若干位，移动的位数由右操作数决定，右操作数必须是非负值，其右边空出的位用 0 填补，高位左移溢出则舍弃该高位。



比如：3 << 5 = 96

```
3 ：00000011
      01100000
```



### 2）左移的结果

一个数左移 1 位就相当于扩大 2 倍，左移 n 位就是扩大 2^n^ 倍。即：`x << n` 等价于 $x\times 2^n$ 。



比如：3 << 5 = 3 \* 2^5^ = 96。



这一特性经常用于快速求出 2 的 n 次幂：`1 << n`。比如：2^31^ = 1 << 31。



### 3）负数的左移

负数的左移是指 `x << n` 中 x 为负数的情况。



比如：-3 << 5 = -96

```
-3 ：11111101（补码）
        10100000（左移 5 位后补码）
        11011111（反码）
        11100000（原码）
```



可以发现，负数的左移和正数的左移没有区别，结果依旧为 $x\times 2^n$ 。也可以理解为 `(-x) << n` 等价于 `-(x << n)` 。



### 4）应用

#### a. 取模

对于 x 模上一个 2 的次幂数 y，可以转换成 x 位与上 2^y^-1。

即，$x \ mod\ 2^y$ 等价于 `x & ((1 << y) - 1)` 



比如：3 mod 8 = 3

```
3 ：      00000011
7 ： &  00000111
      ----------------
      	  00000011
```



#### b. 与其他位运算混合运算

使用左移运算就可以代替一些冗长的数字写法。比如 `0b100000` 就可以写成 `1 << 5` 。



**判断 x 低位第 5 位是否为 1**

```
x & (1 << 5)
```



**将 x 低位第 5 位变为 1**

```
x | (1 << 5)
```



**将 x 低位第 5 位变为 0**

```
x & (~(1 << 5))
```

`~` 是取反操作符，将 0 变 1，1 变 0。



**将 x 低位第 5 位取反**

```
x ^ (1 << 5)
```

## 2. 题目练习

| 题目链接                                                     | 备注 |
| ------------------------------------------------------------ | ---- |
| [十进制整数的反码](https://leetcode.cn/problems/complement-of-base-10-integer/description/) |      |
| [数字的补数](https://leetcode.cn/problems/number-complement/description/) |      |
| [比特位计数](https://leetcode.cn/problems/counting-bits/description/) |      |

## 3. 解题报告

[十进制整数的反码](https://leetcode.cn/problems/complement-of-base-10-integer/description/)

**题目描述**

> 每个非负整数 `N` 都有其二进制表示。例如， `5` 可以被表示为二进制 `"101"`，`11` 可以用二进制 `"1011"` 表示，依此类推。注意，除 `N = 0` 外，任何二进制表示中都不含前导零。
>
> 二进制的反码表示是将每个 `1` 改为 `0` 且每个 `0` 变为 `1`。例如，二进制数 `"101"` 的二进制反码为 `"010"`。
>
> 给你一个十进制数 `N`，请你返回其二进制表示的反码所对应的十进制整数。

**解题思路**

为了去除前导零，先找到数的高位第一个 1 的位置，然后往后依次取反。将第 i 位取反可用 `n ^= 1 << i` 。需要考虑特殊情况 0，0 的二进制中没有 1。

**Java代码**

```java
class Solution {
    public int bitwiseComplement(int n) {
        if (n == 0)
            return 1;
        int i = 0;
        for (i = 31; i >= 0; i--)
            if ((n & (1 << i)) != 0)
                break;
        for ( ; i >= 0; i--)
            n ^= 1 << i;
        return n;
    }
}
```

[比特位计数](https://leetcode.cn/problems/counting-bits/description/)

**题目描述**

> 给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 **`1` 的个数** ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

**解题思路**

判断每一个数字的每一位是否为 1，记录下 1 的个数即可。

**Java代码**

```java
class Solution {
    public int[] countBits(int n) {
        int[] res = new int[n+1];
        for (int i = 0; i <= n; i++) {
            res[i] = myBitCount(i);
        }
        return res;
    }
    public int myBitCount(int n) {
        int res = 0;
        for (int i = 0; i < 32; i++) {
            if ((n & (1 << i)) != 0)
                res++;
        }
        return res;
    }
}
```

