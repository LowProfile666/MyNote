## 水题

| 题目链接                                                     | 评分（等级） | 备注                   |
| ------------------------------------------------------------ | ------------ | ---------------------- |
| [对数组执行操作](https://leetcode.cn/problems/apply-operations-to-an-array/description/) | 1124         | LeetCode，模拟         |
| [子数组和排序后的区间和](https://leetcode.cn/problems/range-sum-of-sorted-subarray-sums/description/?envType=featured-list&envId=gQg42xUz) | 1402         | LeetCode，排序，前缀和 |
| [找出给定方程的正整数解](https://leetcode.cn/problems/find-positive-integer-solution-for-a-given-equation/description/?envType=featured-list&envId=gQg42xUz) | 1405         | LeetCode，枚举         |
|                                                              |              |                        |



## 二分

| 题目链接                                                     | 评分（等级） | 备注               | 题解           |
| ------------------------------------------------------------ | ------------ | ------------------ | -------------- |
| [\5017. 垦田计划](https://www.acwing.com/problem/content/description/5020/) | 简单         | AcWing，二分或差分 | [题解](#二分1) |





## 降维

| 题目链接                                                     | 评分（等级） | 备注     | 题解 |
| ------------------------------------------------------------ | ------------ | -------- | ---- |
| [三数之和](https://leetcode-cn.com/problems/3sum/)           | 中等         | LeetCode |      |
| [LCR 007. 三数之和](https://leetcode.cn/problems/1fGaJU/)    | 中等         | LeetCode |      |
| [16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/) | 中等         | LeetCode |      |
| [18. 四数之和](https://leetcode.cn/problems/4sum/)           | 中等         | LeetCode |      |
| [1442. 形成两个异或相等数组的三元组数目](https://leetcode.cn/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/) | 1525         | LeetCode |      |



## 排序

| 题目链接                                                     | 评分（等级） | 备注     | 题解           |
| ------------------------------------------------------------ | ------------ | -------- | -------------- |
| [2679. 矩阵中的和](https://leetcode.cn/problems/sum-in-a-matrix/description/) | 1333         | LeetCode | [题解](#排序1) |





## 链表

| 题目链接                                                     | 评分（等级） | 备注               | 题解           |
| ------------------------------------------------------------ | ------------ | ------------------ | -------------- |
| [445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/description/) | 中等         | LeetCode，反转链表 | [题解](#链表1) |





## 队列

| 题目链接 | 评分（等级） | 备注 | 题解 |
| -------- | ------------ | ---- | ---- |
|          |              |      |      |





## 模拟

| 题目链接                                                     | 评分（等级） | 备注                   | 题解           |
| ------------------------------------------------------------ | ------------ | ---------------------- | -------------- |
| [无限区域](https://www.acwing.com/problem/content/4446/)     | 简单         | AcWing，数学           | [题解](#模拟1) |
| [狗和猫](https://www.acwing.com/problem/content/description/4121/) | 简单         | AcWing                 | [题解](#模拟2) |
| [1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/description/) | 1173         | LeetCode               | [题解](#模拟3) |
| [860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/) | 1286         | LeetCode，计数法、贪心 | [题解](#模拟4) |
| [1281. 整数的各位积和之差](https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer/) | 1141         | LeetCode               | [题解](#模拟5) |
| [3709. 单链表节点交换](https://www.acwing.com/problem/content/description/3712/) | 简单         | AcWing                 | [题解](#模拟6) |
| [3708. 求矩阵的鞍点](https://www.acwing.com/problem/content/description/3711/) | 简单         | AcWing                 | [题解](#模拟7) |





## 数列

| 题目链接                                                     | 评分（等级） | 备注               | 题解           |
| ------------------------------------------------------------ | ------------ | ------------------ | -------------- |
| [2485. 找出中枢整数](https://leetcode.cn/problems/find-the-pivot-integer/description/) | 1207         | LeetCode，等差数列 | [题解](#数列1) |





## 枚举

| 题目链接                                                     | 评分（等级） | 备注                     | 题解           |
| ------------------------------------------------------------ | ------------ | ------------------------ | -------------- |
| [饥饿的牛](https://www.acwing.com/problem/content/description/4911/) | 简单         | AcWing                   |                |
| [垃圾桶](https://www.acwing.com/problem/content/description/4117/) | 简单         | AcWing，有点前缀和、递推 | [题解](#枚举2) |
| [最大硬币数](https://www.acwing.com/problem/content/description/3329/) | 简单         | AcWing                   | [题解](#枚举3) |



## 哈希表

| 题目链接                                                     | 评分（等级） | 备注     | 题解             |
| ------------------------------------------------------------ | ------------ | -------- | ---------------- |
| [相等行列对](https://leetcode.cn/problems/equal-row-and-column-pairs/description/) | 1286         | LeetCode |                  |
| [5081. 重复局面](https://www.acwing.com/problem/content/description/5084/) | 简单         | AcWing   | [题解](#哈希表2) |



## 贪心

| 题目链接                                                     | 评分（等级） | 备注     | 题解           |
| ------------------------------------------------------------ | ------------ | -------- | -------------- |
| [划分字母区间](https://leetcode.cn/problems/partition-labels/description/?envType=featured-list&envId=gQg42xUz) | 1443         | LeetCode |                |
| [照相](https://www.acwing.com/problem/content/4443/)         | 中等         | AcWing   |                |
| [1253. 重构 2 行二进制矩阵](https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/description/) | 1506         | LeetCode | [题解](#贪心3) |
| [2600. K 件物品的最大和](https://leetcode.cn/problems/k-items-with-the-maximum-sum/description/) | 1434         | LeetCode | [题解](#贪心4) |
| [2178. 拆分成最多数目的正偶数之和](https://leetcode.cn/problems/maximum-split-of-positive-even-integers/description/) | 1538         | LeetCode | [题解](#贪心5) |



## 后缀和

| 题目链接                                                     | 评分（等级） | 备注     |
| ------------------------------------------------------------ | ------------ | -------- |
| [比较字符串最小字母出现频次](https://leetcode.cn/problems/compare-strings-by-frequency-of-the-smallest-character/description/) | 中等         | LeetCode |



## 字符串

| 题目链接                                                     | 评分（等级） | 备注                     |                  |
| ------------------------------------------------------------ | ------------ | ------------------------ | ---------------- |
| [快速打字](https://www.acwing.com/problem/content/description/4385/v) | 简单         | AcWing，字符串遍历、比较 |                  |
| [字符串转换](https://www.acwing.com/problem/content/4125/)   | 简单         | AcWingf，遍历、转换      |                  |
| [2490. 回环句](https://leetcode.cn/problems/circular-sentence/description/) | 1263         | LeetCode，分隔，比较     | [题解](#字符串3) |
| [递增子串](https://www.acwing.com/problem/content/description/3751/) | 简单         | AcWing，比较，前缀和     | [题解](#字符串4) |
| [Kick_Start](https://www.acwing.com/problem/content/description/3328/) | 简单         | AcWing，枚举             | [题解](#字符串5) |



## 二叉树

| 题目链接                                                     | 评分（等级） | 备注               | 题解             |
| ------------------------------------------------------------ | ------------ | ------------------ | ---------------- |
| [面试题 04.03. 特定深度节点链表](https://leetcode.cn/problems/list-of-depth-lcci/description/) | 中等         | LeetCode，层次遍历 | [题解](#二叉树1) |
| [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/description/) | 中等         | LeetCode           | [题解](#二叉树2) |
| [113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/description/) | 中等         | LeetCode           | [题解](#二叉树3) |
| [1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/description/) | 1360         | LeetCode           | [题解](#二叉树4) |





## DFS && BFS

| 题目链接                                                     | 评分（等级） | 备注           | 题解               |
| ------------------------------------------------------------ | ------------ | -------------- | ------------------ |
| [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/description/) | 中等         | LeerCode，搜索 | [题解](#DFS&&BFS1) |
| [841.钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/description/) | 1412         | LeetCode，DFS  | [题解](#DFS&&BFS2) |
| [面试题 04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/description/) | 中等         | LeetCode，BFS  | [题解](#DFS&&BFS3) |



## DP

| 题目链接                                                     | 评分（等级） | 备注               | 题解         |
| ------------------------------------------------------------ | ------------ | ------------------ | ------------ |
| [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/) | 困难         | LeetCode，DP + DFS | [题解](#DP1) |
| [LCP 07. 传递信息](https://leetcode.cn/problems/chuan-di-xin-xi/description/) | 简单         | LeetCoder          | [题解](#DP2) |







## 题解报告

### 二分

<span id=二分1>[\5017. 垦田计划](https://www.acwing.com/problem/content/description/5020/)</span>

> 顿顿总共选中了 n 块区域准备开垦田地，由于各块区域大小不一，开垦所需时间也不尽相同。
>
> 据估算，其中第 i 块（1≤i≤n）区域的开垦耗时为 ti 天。
>
> 这 n 块区域可以同时开垦，所以总耗时 t~Total~ 取决于耗时最长的区域，即：
>
> 
>
> t~Total~=max{t1,t2,…,tn}
>
> 
>
> 为了加快开垦进度，顿顿准备在部分区域投入额外资源来缩短开垦时间。
>
> 具体来说：
>
> - 在第 i 块区域**每**投入 ci 单位资源，便可将其开垦耗时缩短 1 天；
> - 耗时缩短天数以整数记，即第 i 块区域投入资源数量必须是 ci 的整数倍；
> - 在第 i 块区域最多可投入 ci×(ti−k) 单位资源，将其开垦耗时缩短为 k 天；
> - 这里的 k 表示开垦一块区域的最少天数，满足 0<k≤min{t1,t2,…,tn}；换言之，如果无限制地投入资源，所有区域都可以用 k 天完成开垦。
>
> 现在顿顿手中共有 m 单位资源可供使用，试计算开垦 n 块区域最少需要多少天？
>
> #### 输入格式
>
> 输入共 n+1 行。
>
> 输入的第一行包含空格分隔的三个正整数 n,m,k，分别表示待开垦的区域总数、顿顿手上的资源数量和每块区域的最少开垦天数。
>
> 接下来 n 行，每行包含空格分隔的两个正整数 ti 和 ci，分别表示第 i 块区域开垦耗时和将耗时缩短 1 天所需资源数量。
>
> #### 输出格式
>
> 输出一个整数，表示开垦 n 块区域的最少耗时。

使用二分。可以从 k 到 10^5^ 枚举答案，也就是满足条件的最少的天数。

这个天数满足二段性，因为天数越大，所用的资源数量就越少；天数越小，所用的资源数量就越大。而我们要找的就是天数最少的情况，即是使用资源数量最多的情况。二分就是为了找到这个分界点。

在二分天数时，只有原本需要天数大于当前天数时，才会使用资源，最后将所有田地使用的资源数量加起来，判断是否小于等于 m。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int k = sc.nextInt();
        int[] t = new int[n];
        int[] c = new int[n];
        for (int i = 0; i < n; i++) {
            t[i] = sc.nextInt();
            c[i] = sc.nextInt();
        }
        
        int l = k, r = (int)1e5;
        while (l < r) {
            int mid = l + r >> 1;
            if (check(t, c, k, m, mid))
                r = mid;
            else
                l = mid + 1;
        }
        System.out.println(r);
    }
    public static boolean check(int[] t, int[] c, int k, int m, int mid) {
        long sum = 0;
        for (int i = 0; i < t.length; i++) {
            if (t[i] > mid) {
                sum += (t[i] - mid) * c[i];
                if (sum > m)
                    return false;
            } 
        }
        return true;
    }
}
```





### 枚举

<span id=枚举2>[垃圾桶](https://www.acwing.com/problem/content/description/4117/)</span>

> 一条很长的街道上有 N 个房子。
>
> 第一个房子在位置 1，第二个房子在位置 2，以此类推。
>
> 任意一对房子 i 和 j 之间的距离为 |i−j|。
>
> 一些房子的位置处有垃圾桶。
>
> 每个房子的主人都要倒垃圾。
>
> 如果自己房子前面有垃圾桶，则无需移动，直接倒垃圾即可。
>
> 如果自己房子前面没有垃圾桶，则前往距离自己最近的垃圾桶处倒垃圾，如果这样的垃圾桶不唯一，则任意前往一个即可。
>
> 请计算，所有房子的主人倒垃圾需要行走的总距离之和。

从左往右遍历，记录每个房子离左边垃圾桶最近的距离；

再左右往左遍历，记录每个房子力右边垃圾桶最近的距离，同时与离左边的距离进行比较，保留较小的距离。

最后加上所有的距离。

**Java代码**

```java
import java.util.*;
import java.io.*;

public class Main{
    public static void main (String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));
        int t = Integer.parseInt(in.readLine());
        for (int cases = 1; cases <= t; cases++) {
            int n = Integer.parseInt(in.readLine());
            char[] s = in.readLine().toCharArray();
            int[] dp = new int[n];
            dp[0] = (s[0] == '1' ? 0 : n);
            for (int i = 1; i < n; i++) {
                dp[i] = s[i] == '1' ? 0 : dp[i-1] + 1;
            }
            for (int i = n-2; i >= 0; i--) {
                dp[i] = Math.min(dp[i], dp[i+1]+1);
            }
            long res = 0;
            for (int i = 0; i < n; i++) {
                res += dp[i];
            }
            out.write("Case #" + cases + ": " + res + "\n");
        }
        out.flush();
    }
}
```



<span id=枚举3>[最大硬币数](https://www.acwing.com/problem/content/description/3329/)</span>

> Mike 有一个 N 行 N 列的方格矩阵。
>
> 位于第 i 行第 j 列的方格的位置坐标表示为 (i,j)。
>
> 矩阵左上角方格的坐标即为 (1,1)。
>
> 每个方格中都包含一定数量的硬币，Mike 只有到达一个方格内时，方可收集方格中的硬币。
>
> Ci,j 表示第 i 行第 j 列的方格中的硬币数量。
>
> 当 Mike 处于方格 (i,j) 时，他可以选择移动至方格 (i−1,j−1) 或方格 (i+1,j+1) 中，前提是所选择的方格位于矩阵边界内，且之前没有到达过。
>
> Mike 可以选择从任意方格开始移动，也可以选择在移动至任意方格时结束移动。
>
> Mike 希望尽可能多的收集硬币。
>
> 请帮助他确定他可以收集的最大硬币数量。

因为只能在一条对角线上向两个方向移动，要想得到最多的硬币，那么只有这跟对角线上的上下两顶点处才能得到最多，因为这时候整条对角线上的数都会被计算，所以本题答案只需要枚举第一行和第一列，计算对应对角线上的总和即可。

**Java代码**

```java
import java.util.*;
import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(in.readLine());
        for (int cases = 1; cases <= t; cases++) {
            int n = Integer.parseInt(in.readLine());
            long[][] c = new long[n+10][n+10];
            for (int i = 1; i <= n; i++) {
                String[] nums = in.readLine().split(" ");
                for (int j = 1; j <= n; j++) {
                    c[i][j] = Integer.parseInt(nums[j-1]);
                }
            }
            long res = 0, num1 = 0, num2 = 0;
            for (int i = 1; i <=n; i++) {
                num1 = solve(c, 1, i, n);
                if (i >= 2)
                    num2 = solve(c, i, 1, n);
                res = res > num1 ? (res > num2 ? res : num2) : (num1 > num2 ? num1 : num2);
            }
            System.out.println("Case #" + cases + ": " + res);
        }
    }
    public static long solve(long[][] c, int x, int y, int n) {
        long res = c[x][y];
        for (int i = x+1, j = y+1; i <= n && j <= n; i++, j++)
            res += c[i][j];
        return res;
    }
}
```



### 哈希表

<span id=哈希表2>[5081. 重复局面](https://www.acwing.com/problem/content/description/5084/)</span>

>
>
>国际象棋在对局时，同一局面连续或间断出现 3 次或 3 次以上，可由任意一方提出和棋。
>
>国际象棋每一个局面可以用大小为 8×8 的字符数组来表示，其中每一位对应棋盘上的一个格子。
>
>六种棋子王、后、车、象、马、兵分别用字母 k、q、r、b、n、p 表示，其中大写字母对应白方、小写字母对应黑方。
>
>棋盘上无棋子处用字符 `*` 表示。
>
>两个字符数组的每一位均相同则说明对应同一局面。
>
>现已按上述方式整理好了每步棋后的局面，试统计每个局面分别是第几次出现。
>
>![1.png](https://gitee.com/LowProfile666/image-bed/raw/master/img/202308212218685.png)
>
>注意：判断重复局面仅涉及字符串比较，无需考虑国际象棋实际行棋规则。

一个局面是由 8 行字符串组成的，可以将 8 行字符串连接成一行，那其实就是判断这个字符串一共出现了几次即可。

使用 map 集合，存下字符串以及字符串的出现次数。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        Map<String, Integer> map = new HashMap<>();
        for (int i = 0; i < n; i++) {
            StringBuffer sb = new StringBuffer();
            for (int j = 0; j < 8; j++)
                sb.append(sc.next());
            String s = String.valueOf(sb);
            int cnt = map.getOrDefault(s, 0) + 1;
            map.put(s, cnt);
            System.out.println(cnt);
        }
    }
}
```



### 排序

<span id=排序1>[2679. 矩阵中的和](https://leetcode.cn/problems/sum-in-a-matrix/description/)</span>

> 给你一个下标从 **0** 开始的二维整数数组 `nums` 。一开始你的分数为 `0` 。你需要执行以下操作直到矩阵变为空：
>
> 1. 矩阵中每一行选取最大的一个数，并删除它。如果一行中有多个最大的数，选择任意一个并删除。
> 2. 在步骤 1 删除的所有数字中找到最大的一个数字，将它添加到你的 **分数** 中。
>
> 请你返回最后的 **分数** 。

将矩阵中的每一行从小到大排序，然后从右往左遍历每一列，选出一列中的最大值，累加到分数中。

**Java代码**

```java
class Solution {
    public int matrixSum(int[][] nums) {
        int res = 0;
        for (int[] arr : nums)
            Arrays.sort(arr);
        for (int i = nums[0].length-1; i >=0; i--) {
            int max = nums[0][i];
            for (int j = 1; j < nums.length; j++) {
                if (max < nums[j][i])
                    max = nums[j][i];
            }
            res += max;
        }
        return res;
    }
}
```





### 链表

<span id=链表1>[445. 两数相加 II](https://leetcode.cn/problems/add-two-numbers-ii/description/)</span>

> 给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。
>
> 你可以假设除了数字 0 之外，这两个数字都不会以零开头。

整数的存储方式和我们平常习惯的相反，所以先将两个链表反转以下，然后进行相加操作，最后将结果也反转一下即可。

**Java代码**

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        l1 = reverse(l1);
        l2 = reverse(l2);
     
        ListNode head = new ListNode(0);
        ListNode dummy = new ListNode(-1, head);
        while (l1 != null || l2 != null) {
            if (l1 != null) {
                head.val += l1.val;
                l1 = l1.next;
            }                
            if (l2 != null) {
                head.val += l2.val;
                l2 = l2.next;
            }
            head.next = new ListNode();
            head.next.val = head.val / 10;
            if (head.next.val == 0 && l1 == null && l2 == null)
                head.next = null;
            head.val = head.val % 10;
            head = head.next;
        }
        return reverse(dummy.next);
    }
    public ListNode reverse(ListNode l) {
        ListNode pre = null, left = l, right = l.next;
        while (right != null) {
            left.next = pre;
            pre = left;
            left = right;
            right = right.next;
        }
        left.next = pre;
        return left;
    }
}
```









### 字符串

<span id=字符串3>[2490. 回环句](https://leetcode.cn/problems/circular-sentence/description/)</span>

> **句子** 是由单个空格分隔的一组单词，且不含前导或尾随空格。
>
> - 例如，`"Hello World"`、`"HELLO"`、`"hello world hello world"` 都是符合要求的句子。
>
> 单词 **仅** 由大写和小写英文字母组成。且大写和小写字母会视作不同字符。
>
> 如果句子满足下述全部条件，则认为它是一个 **回环句** ：
>
> - 单词的最后一个字符和下一个单词的第一个字符相等。
> - 最后一个单词的最后一个字符和第一个单词的第一个字符相等。
>
> 例如，`"leetcode exercises sound delightful"`、`"eetcode"`、`"leetcode eats soul"` 都是回环句。然而，`"Leetcode is cool"`、`"happy Leetcode"`、`"Leetcode"` 和 `"I like Leetcode"` 都 **不** 是回环句。
>
> 给你一个字符串 `sentence` ，请你判断它是不是一个回环句。如果是，返回 `true` ；否则，返回 `false` 。

遍历，找到字符串中的空格，比较空格前后的两个字符是否相等。还要比较整个字符串的首尾两字符是否相等。

```java
class Solution {
    public boolean isCircularSentence(String sentence) {
        if (sentence.charAt(sentence.length() - 1) != sentence.charAt(0)) {
            return false;
        }
        for (int i = 0; i < sentence.length(); i++) {
            if (sentence.charAt(i) == ' ' 
             && sentence.charAt(i + 1) != sentence.charAt(i - 1)) {
                return false;
            } 
        }
        return true;
    }
}
```

<span id=字符串4>[递增子串](https://www.acwing.com/problem/content/description/3751/)</span>

> 你的朋友约翰刚刚度假归来，他迫不及待地想要跟你分享他了解到的关于字符串的一个新性质。
>
> 他了解到，如果一个长度为 L 的大写字母构成的字符串 C，满足对于每对索引 i,j（1≤i≤j≤L，索引编号 1∼L），位置 i 处的字符均小于位置 j 处的字符，则该字符串是严格递增的。
>
> 例如，字符串 `ABC` 和 `ADF` 是严格递增的，而字符串 `ACC` 和 `FDA` 则不是。
>
> 在教给你这个关于字符串的新性质后，他打算考一考你：
>
> 给定一个长度为 N 的字符串 S，请你计算对于每个位置 i（1≤i≤N），以该位置结束的最长严格递增子串的长度是多少？

求的是以当前字符为结尾的最长递增子串，那么以第一个字符结束的最长子串长度只能是 1。

暴力解法就是从当前字符往前遍历，计算有多少个满足严格递增的字符。

然而，可以发现，当前位置的最长严格递增子串长度是直接由上一个位置的长度加 1 来的，所以可以直接使用前缀和而不用再遍历。

**C代码**

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int t = 0, cases = 0;
    scanf("%d", &t);
    for (cases = 1; cases <= t; cases++) {
        int n = 0;
        scanf("%d", &n);
        char* s = (char*)malloc(sizeof(char) * (n+1));
        scanf("%s", s);
        int res[n];
        res[0] = 1;
        for (int i = 1; i < n; i++) {
            res[i] = 1;
            if (s[i] > s[i-1])
                res[i] += res[i-1];
        }
        printf("Case #%d: ", cases);
        for (int i = 0; i < n; i++) {
            printf("%d ", res[i]);
        }
        printf("\n");
    }
    return 0;
}
```



<span id=字符串5>[Kick_Start](https://www.acwing.com/problem/content/description/3328/)</span>

>Ksenia 非常喜欢读书，因此每天她都会从自己最喜欢的书中选取一段内容进行阅读，然后再开始她早晨的其他活动。
>
>一段内容可以看作是整个文本中的一个子字符串。
>
>Ksenia 有点迷信，她坚信如果阅读的这段内容是以字符串 `KICK` 开头，然后中间包含 0 个或更多个字符，最后以字符串 `START` 结尾，即使这段内容没什么意义，她的一天也会非常的幸运。
>
>给定这本书的全部文本内容，请你数一数在这本书变得破旧不堪，Ksenia 不得不再买新书之前，共有多少个幸运片段可供她阅读。
>
>只要两个片段的起始位置或结束位置不同，就认为这两个片段是不同的，即使它们包含的内容完全相同。
>
>还需注意，不同片段之间可能会有重叠部分。

第一想法：分别记录下每个 KICK 和 START 的起始下标，然后一个 KICK 可以对应其之后的所有 START，只需遍历判断每个 KICK 的下标之后有多少个 START 即可，累加上就是答案。

换个思路也可以这样，统计每个 START 前的 KICK 的数目，当碰到 START 时，答案就累加上其前面的 KICK 数目。

**Java代码**

```java
import java.util.*;
import java.io.*;

public class Main{
    public static void main(String[] args) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        int t = Integer.parseInt(in.readLine());
        for (int cases = 1; cases <= t; cases++) {
            String s = in.readLine();
            int res = 0;
            int len = s.length();
            int k = 0;
            for (int i = 0; i < len-4; i++) {
                if (s.substring(i, i+4).equals("KICK")) {
                    k++;
                    i += 2;
                }
                else if (i+5 <= len && s.substring(i, i+5).equals("START")) {
                    res += k;
                    i += 3;
                }
            }
            System.out.println("Case #" + cases + ": " + res);
        }
    }
}
```









### 模拟

<span id=模拟1>[无限区域](https://www.acwing.com/problem/content/4446/)</span>

> 给定一个无限大的二维平面，设点 S 为该平面的中心点。
>
> 设经过点 S 的垂直方向的直线为 P，如果直线 P 是一个圆的切线，且切点恰好为点 S，那么：
>
> - 如果该圆位于直线 P 的右侧，则称之为右圆。
> - 如果该圆位于直线 P 的左侧，则称之为左圆。
>
> 现在，给定三个整数 R,A,B，你需要按照右圆、左圆、右圆、左圆…的顺序不断画圆，具体要求如下：
>
> - 第一个右圆的半径等于 R。
> - 每个左圆的半径等于你画的**上一个圆**的半径乘以 A。
> - 每个右圆（第一个除外）的半径等于你画的**上一个圆**的半径除以 B（向下取整）。
> - 当你要画的圆的半径等于 0 时，绘画停止。
>
> ![InfinityAreaImage.png](https://cdn.acwing.com/media/article/image/2022/05/09/19_51ca0c24cf-InfinityAreaImage.png)
>
> 请你计算，所有画出的圆的面积之和。
>
> 保证绘画会在有限数量的步骤后停止。

直接模拟 R 的变化即可。

**Java代码**

```java
import java.util.*;
public class Main{
    static double PI = 3.1415926;
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int t = sc.nextInt();
        for (int i = 1; i <= t; i++) {
            int r = sc.nextInt();
            int a = sc.nextInt();
            int b = sc.nextInt();
            double s = PI * r * r;
            boolean f = false;
            while (r != 0) {
                if (!f) {
                    f = true;
                    r *= a;
                }
                else {
                    f = false;
                    r /= b;
                }
                s += PI * r * r;
            }
            System.out.println("Case #" + i + ": " + s);
        }
    }
}
```



<span id=模拟2>[狗和猫](https://www.acwing.com/problem/content/description/4121/)</span>

> 你在动物收容所工作，负责喂养动物。
>
> 你一共准备了 D 份狗粮和 C 份猫粮。
>
> 一共有 N 只动物排队等候用餐，有的是狗，有的是猫。
>
> 当然，也有可能全都是狗或者全都是猫。
>
> 我们可以用一个长度为 N 的由大写字母 C 和 D 组成的字符串 S 来表示队列中猫狗的顺序。
>
> 如果队列中第 i 只动物是猫，则第 i 个字符为 C。
>
> 如果队列中第 i 只动物是狗，则第 i 个字符为 D。
>
> 动物们严格按照排队顺序依次进食。
>
> 每只狗吃一份狗粮，每只猫吃一份猫粮。
>
> 此外，你还有额外的猫粮。
>
> 每当一条狗吃完一份狗粮，你就会为猫多提供 M 份猫粮。
>
> 每只动物都只会在排在其前面的所有动物都进食完毕后，才肯进食。
>
> 这也就意味着，当轮到某只动物进食，但是却没有相应的食物时，它和排在它后面的所有动物都会因此无法进食。
>
> 请问，在这种情况下，队列中的**所有狗**能否都得到喂食。

模拟进食的过程，遍历字符串，碰到 D 字符就将狗粮减一，且将猫粮加 M；碰到 C 字符就将猫粮减一。

同时要判断猫粮狗粮的数量是否为 0，

+ 当狗粮的数量为 0 后，就需判断剩下未遍历的字符中是否还有 D，有则 NO，无则 YES。
+ 当猫粮的数量为 0 后且碰到 C 字符，也需要判断剩下字符中是否存在 D，因为当前的 C 已经过不去了。

如果能将所有的字符都遍历到，那说明能喂完所有的狗。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for (int cases = 1; cases <= T; cases++) {
            int n = sc.nextInt();  // 猫狗总数
            int d = sc.nextInt();  // 狗粮
            int c = sc.nextInt();  // 猫粮
            int m = sc.nextInt();  // 猫粮增量
            char[] s = sc.next().toCharArray();
            int f = 0;
            while (f != n && d != 0) {
                if (s[f++] == 'D') {
                    d--;
                    c += m;
                } else if (c != 0) {
                    c--;
                } else if (c == 0)
                    break;
            }
            String res = "YES";
            while (f != n) {
                if (s[f++] == 'D') {
                    res = "NO";
                    break;
                }
            }
            System.out.println("Case #" + cases + ": " + res);
        }
    }
}
```

<span id=模拟3>[1046. 最后一块石头的重量](https://leetcode.cn/problems/last-stone-weight/description/)</span>

> 有一堆石头，每块石头的重量都是正整数。
>
> 每一回合，从中选出两块 **最重的** 石头，然后将它们一起粉碎。假设石头的重量分别为 `x` 和 `y`，且 `x <= y`。那么粉碎的可能结果如下：
>
> - 如果 `x == y`，那么两块石头都会被完全粉碎；
> - 如果 `x != y`，那么重量为 `x` 的石头将会完全粉碎，而重量为 `y` 的石头新重量为 `y-x`。
>
> 最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 `0`。

模拟碎石的过程，每次将石头的重量排序，粉碎掉最大和次大的石头，然后将最大的石头剩下的放在次大的位置，进行下一次排序。

**Java代码**

```java
class Solution {
    public int lastStoneWeight(int[] stones) {
        int n = stones.length;
        while (n > 1) {
            bubbleSort(stones, n);
            stones[n-2] = stones[n-1] - stones[n-2];
            n--;
        }
        return stones[0];
    }
    public void bubbleSort(int[] nums, int n) {
        for (int i = n-1; i > 0; i--) {
            for (int j = 0; j < i; j++) {
                if (nums[j] > nums[j+1]) {
                    int t = nums[j];
                    nums[j] = nums[j+1];
                    nums[j+1] = t;
                }
            }
        }
    }
}
```



<span id=模拟4>[860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)</span>

> 在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。
>
> 每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。
>
> 注意，一开始你手头没有任何零钱。
>
> 给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

记录下我们手上拥有的 5 元的个数和 10 元的个数，收钱时分为三种情况：

+ 当收到一张 5 元时，不用找零；
+ 当收到一张 10 元时，需要找零 5 元，如果此时 5 元的个数为 0，则不能正确找零；
+ 当收到一张 20 元时，需要找零 15 元，而此时可以找 3 张 5 元的或 1 张 10 元加 1 张 5 元的，显然我们应该尽可能保留 5 元的数量，来保证可以满足更多的找零，所以应该优先选择找零 1 张 10 元加 1 张 5 元的。如果此时 5 元的个数为 0 或手上的总钱小于 15 时，则不能正确找零；

Java代码

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        if (bills[0] > 5)
            return false;
        int cnt5 = 0, cnt10 = 0;
        for (int i = 0; i < bills.length; i++) {
            if (bills[i] == 5)
                cnt5++;
            else if (bills[i] == 10) {
                if (cnt5 > 0)
                    cnt5--;
                else 
                    return false;
                cnt10++;
            }
            else {
                if (cnt5 <= 0 || cnt5 * 5 + cnt10 * 10 < 15)
                    return false;
                if (cnt10 > 0) {
                    cnt10--;
                    cnt5--;
                } else {
                    cnt5 -= 3;
                }
            }
        }
        return true;
    }
}
```



<span id=模拟5>[1281. 整数的各位积和之差](https://leetcode.cn/problems/subtract-the-product-and-sum-of-digits-of-an-integer/)</span>

> 给你一个整数 `n`，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。

只要拿到每位数字即可。

**Java代码**

```java
class Solution {
    public int subtractProductAndSum(int n) {
        int a = 0;
        int b = 1;
        while (n != 0) {
            a += n % 10;
            b *= n % 10;
            n /= 10;
        }
        return b - a;
    }
}
```



<span id=模拟6>[3709. 单链表节点交换](https://www.acwing.com/problem/content/description/3712/)</span>

> 输入一个单链表，依次交换前2个数，第3、4个数，第5、6个数，…，以此类推，直到操作完整个链表。
> 如果链表长度是奇数，则最后一个数不用操作。
>
> 输出交换之后的链表。

用数组保存输入的数据，在保存数据的时候，可以根据当前是第奇数个还是第偶数个数据，奇数个的话就保存在后一个位置，偶数个的话就保存在前一个位置。比如第 1 个数据保存在第 2 个位置，第 2 个数据保存在第 1 个位置。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] nums = new int[n+10];
        for (int i = 1; i <= n; i++) {
            if (i % 2 == 0) {
                nums[i-2] = sc.nextInt();
            } else {
                nums[i] = sc.nextInt();
            }
        }
        if (n % 2 != 0)
            nums[n-1] = nums[n];
        for (int i = 0; i < n; i++) {
            System.out.print(nums[i] + " ");
        }
    }
}
```

<span id=模拟7>[3708. 求矩阵的鞍点](https://www.acwing.com/problem/content/description/3711/)</span>

> 给定一个 n×m 的整数矩阵，行的编号为 1∼n，列的编号为 1∼m，求矩阵中的所有鞍点。
>
> 鞍点，即该位置上的元素在该行上最大，在该列上最小。
>
> 有可能有多个鞍点，也可能没有鞍点。

模拟即可，找出元素所在的行的最大值，所在列的最小值，然后比较是否相等。

**Java代码**

```java
import java.util.*;

public class Main{
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int m = sc.nextInt();
        int[][] mat = new int[n][m];
        boolean f = false;
        for (int i = 0; i < n; i++)
            for (int j = 0; j < m; j++)
                mat[i][j] = sc.nextInt();
                
        for (int i = 0; i < n; i++) {
            int rMax = mat[i][0];
            for (int j = 1; j < m; j++) {
                rMax = Math.max(rMax, mat[i][j]);
            }
            for (int j = 0; j < m; j++) {
                int cMin = mat[0][j];
                for (int k = 1; k < n; k++) {
                    cMin = Math.min(cMin, mat[k][j]);
                }
                if (cMin  == rMax) {
                    f = true;
                    System.out.println((i+1) + " " + (j+1) + " " + cMin);
                }
            }
         
        }
        if (!f)
            System.out.println("NO");
    }
}
```



### 贪心

<span id=贪心3>[1253. 重构 2 行二进制矩阵](https://leetcode.cn/problems/reconstruct-a-2-row-binary-matrix/description/)</span>

>给你一个 `2` 行 `n` 列的二进制数组：
>
>- 矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 `0` 就是 `1`。
>- 第 `0` 行的元素之和为 `upper`。
>- 第 `1` 行的元素之和为 `lower`。
>- 第 `i` 列（从 `0` 开始编号）的元素之和为 `colsum[i]`，`colsum` 是一个长度为 `n` 的整数数组。
>
>你需要利用 `upper`，`lower` 和 `colsum` 来重构这个矩阵，并以二维整数数组的形式返回它。
>
>如果有多个不同的答案，那么任意一个都可以通过本题。
>
>如果不存在符合要求的答案，就请返回一个空的二维数组。

先考虑到上下两行都有 1 的情况，也就是 colsum 中等于 2 的位置。使用一个变量 numOfTwo 记录下来又多少个这样的位置，然后和 upper、lower 中的最小值进行比较：

+ 如果 numOfTwo 大于 min(upper, lower)，那么不能构成一个满足要求的二维数组

在统计 2 的同时，用一个 sum 来记录二进制数组中总共的 1 的个数，再和 upper、lower 的和进行比较：

+ 如果 sum 不等于 upper + lower，那么不能构成一个满足要求的二维数组

之后用 upper、lower 减去 numOfTwo， 再根据 colsum 的内容来构造二维数组。

**Java代码**

```java
class Solution {
    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {
        List<List<Integer>> res = new ArrayList<>();
        List<Integer> l1 = new ArrayList<>();
        List<Integer> l2 = new ArrayList<>();
        int sum = 0, numOfTwo = 0;
        for (int i = 0; i < colsum.length; i++) {
            if (colsum[i] == 2)
                numOfTwo++;
            sum += colsum[i];
        }
        if (upper + lower != sum || Math.min(upper, lower) < numOfTwo)
            return res;
        upper -= numOfTwo;
        lower -= numOfTwo;
        for (int i = 0; i < colsum.length; i++) {
            if (colsum[i] == 2) {
                l1.add(1);
                l2.add(1);
            } else if (colsum[i] == 1) {
                if (upper != 0) {
                    l1.add(1);
                    l2.add(0);
                    upper--;
                } else if (lower != 0) {
                    l1.add(0);
                    l2.add(1);
                    lower--;
                }
            } else {
                l1.add(0);
                l2.add(0);
            }
        }
        res.add(l1);
        res.add(l2);
        return res;
    }
}
```



<span id=贪心4>[2600. K 件物品的最大和](https://leetcode.cn/problems/k-items-with-the-maximum-sum/description/)</span>

> 袋子中装有一些物品，每个物品上都标记着数字 `1` 、`0` 或 `-1` 。
>
> 给你四个非负整数 `numOnes` 、`numZeros` 、`numNegOnes` 和 `k` 。
>
> 袋子最初包含：
>
> - `numOnes` 件标记为 `1` 的物品。
> - `numZeroes` 件标记为 `0` 的物品。
> - `numNegOnes` 件标记为 `-1` 的物品。
>
> 现计划从这些物品中恰好选出 `k` 件物品。返回所有可行方案中，物品上所标记数字之和的最大值。

当 k 小于等于 numOnes 时，最大值就是 k 的值；

当 k 大于 numOnes 且小于 numOnes+numZeroes 时，最大值就是 numOnes 的值；

否则，最大值就是 numOnes 减去 k-numOnes-numZeroes（即为剩下的-1的个数）。

**Java代码**

```java
class Solution {
    public int kItemsWithMaximumSum(int numOnes, int numZeros, int numNegOnes, int k) {
        if (k <= numOnes)
            return k;
        else if (k <= numOnes + numZeros)
            return numOnes;
        else 
            return numOnes - (k - numOnes - numZeros);
    }
}
```



<span id=#贪心5>[2178. 拆分成最多数目的正偶数之和](https://leetcode.cn/problems/maximum-split-of-positive-even-integers/description/)</span>

> 给你一个整数 `finalSum` 。请你将它拆分成若干个 **互不相同** 的正偶数之和，且拆分出来的正偶数数目 **最多** 。
>
> - 比方说，给你 `finalSum = 12` ，那么这些拆分是 **符合要求** 的（互不相同的正偶数且和为 `finalSum`）：`(2 + 10)` ，`(2 + 4 + 6)` 和 `(4 + 8)` 。它们中，`(2 + 4 + 6)` 包含最多数目的整数。注意 `finalSum` 不能拆分成 `(2 + 2 + 4 + 4)` ，因为拆分出来的整数必须互不相同。
>
> 请你返回一个整数数组，表示将整数拆分成 **最多** 数目的正偶数数组。如果没有办法将 `finalSum` 进行拆分，请你返回一个 **空** 数组。你可以按 **任意** 顺序返回这些整数。

首先，奇数是不可能满足条件的，直接返回空数组。

其次，我们希望拆分成尽可能多的偶数，我们应该尽可能拆份成最小的若干个偶数。从最小的偶整数 2 开始依次尝试拆分，直到剩余的数值小于等于当前被拆分的最大偶整数为止。此时，我们已经拆分成尽可能多的偶数，不可能拆分出更多的互不相同的偶数。如果此时拆分后剩余的 finalSum 大于零，则将这个数值加到最大的偶整数上，从而保证所有的数互不相同。

**Java代码**

```java
class Solution {
    public List<Long> maximumEvenSplit(long finalSum) {
        List<Long> res = new ArrayList<>();
        if (finalSum % 2 > 0) {
            return res;
        }
        for (long i = 2; i <= finalSum; i += 2) {
            res.add(i);
            finalSum -= i;
        }
        res.set(res.size() - 1, res.get(res.size() - 1) + finalSum);
        return res;
    }
}
```







### 数列

<span id=数列1>[2485. 找出中枢整数](https://leetcode.cn/problems/find-the-pivot-integer/description/)</span>

> 给你一个正整数 `n` ，找出满足下述条件的 **中枢整数** `x` ：
>
> - `1` 和 `x` 之间的所有元素之和等于 `x` 和 `n` 之间所有元素之和。
>
> 返回中枢整数 `x` 。如果不存在中枢整数，则返回 `-1` 。题目保证对于给定的输入，至多存在一个中枢整数。

这是一个首项为 1，公差为 1 ，项数为 n 的等差数列，而 1 到 x 和 x 到 n 也分别是两个等差数列，于是该题就是求一个 x 使`[1, x]` 和 `[x. n]` 这两等差数列的前 n 项和相等。

等差数列的求和公式：$Sn = \frac{n(a1+an)}{2}$ 

所以有：

$S(1,x)=S(x,n)$ 

$\frac{x(1+x)}{2}=\frac{(n-x+1)(x+n)}{2}$ 

$x=\sqrt{\frac{n^2+n}{2}}$

所以求出 $\frac{n^2+n}{2}$ 的平方根，判断这个根的平方是否等于它，是则返回，否则返回 -1。

**Java代码**

```java
class Solution {
    public int pivotInteger(int n) {
        int sum = (n * n + n) / 2;
        int x = (int)Math.sqrt(sum);
        if (x * x == sum)
            return x;
        return -1;
    }
}
```





### DP

<span id = DP1>[329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/description/)</span>

> 给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。
>
> 对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。
>
> **示例 1：**
>
> ![image-20230624132652262](https://gitee.com/LowProfile666/image-bed/raw/master/img/image-20230624132652262.png)
>
> ```
> 输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
> 输出：4 
> 解释：最长递增路径为 [1, 2, 6, 9]。
> ```

该题可以使用动态规划，用 `dp[i][j]` 来表示以 (i, j) 这个点为终点的最长递增路径长度，那么 `dp[i][j]` 就是由 (i, j) 的四周的点的最长递增路径中的最大值加 1 来的，也就是：$dp[i][j] = max(dp[i-1][j],dp[i][j-1],dp[i][j+1],dp[i+1][j])+1$ 。

Java代码

```java
class Solution {
    public int longestIncreasingPath(int[][] matrix) {
        int m = matrix.length;
        int n = matrix[0].length;
        int res = 0;
        int[][] dp = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (dp[i][j] == 0) {
                    dp[i][j] = dfs(matrix, m, n, i, j, dp);
                }
                res = res > dp[i][j] ? res : dp[i][j];
            }
        }
        return res;
    }
    int[][] dir = {
        {-1, 0}, {1, 0}, {0, -1}, {0, 1}
    };
    public int dfs(int[][] a, int m, int n, int x, int y, int[][] dp) {
        int res = 1;
        for (int i = 0; i < 4; i++) {
            int tx = x + dir[i][0];
            int ty = y + dir[i][1];
            if (tx < 0 || tx >= m || ty < 0 || ty >= n)
                continue;
            if (a[x][y] > a[tx][ty]) {
                if (dp[tx][ty] == 0)
                    dp[tx][ty] = dfs(a, m, n, tx, ty, dp);
                dp[x][y] = dp[tx][ty] + 1;
                res = Math.max(res, dp[x][y]);
            }
        }
        return res;
    }
}
```

<span id = DP2>[LCP 07. 传递信息](https://leetcode.cn/problems/chuan-di-xin-xi/description/)</span>

> 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：
>
> 1. 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
> 2. 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
> 3. 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人
>
> 给定总玩家数 `n`，以及按 `[玩家编号,对应可传递玩家编号]` 关系组成的二维数组 `relation`。返回信息从小 A (编号 0 ) 经过 `k` 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。
>
> **示例 1：**
>
> > 输入：`n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3`
> >
> > 输出：`3`
> >
> > 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。

该题可以将 relation 数组中的关系看作是一个有向图，那么可以使用一个邻接矩阵 mat 来表示每个点之间的边，使用动态规划，用数组 dp 表示每一轮到每个点的方案数，`dp[i][j]` 表示第 i 轮到 j 这个点的方案数，`dp[i][j]` 是由上一轮（i-1轮）某些点的方案数加起来的。

Java代码

```java
class Solution {
    public int numWays(int n, int[][] relation, int k) {

        int[][] mat = new int[10][10];  
        int[][] dp = new int[6][10];  // dp[i][j] 表示第 i 轮传到 j 这个点的方案数
        for (int[] r : relation) {
            mat[r[0]][r[1]] = 1;
        }
        dp[0][0] = 1;
        for (int i = 1; i <= k; i++) {  // 第 i 轮
            for (int j = 0; j < n; j++) {  // 终点
                for (int f = 0; f < n; f++) {  // 起点
                    if (mat[f][j] == 1)
                        dp[i][j] += dp[i-1][f];
                }
            }
        }
        return dp[k][n-1];
    }
}
```



### DFS && BFS

<span id = DFS&&BFS1>[547. 省份数量](https://leetcode.cn/problems/number-of-provinces/description/)</span>

> 有 `n` 个城市，其中一些彼此相连，另一些没有相连。如果城市 `a` 与城市 `b` 直接相连，且城市 `b` 与城市 `c` 直接相连，那么城市 `a` 与城市 `c` 间接相连。
>
> **省份** 是一组直接或间接相连的城市，组内不含其他没有相连的城市。
>
> 给你一个 `n x n` 的矩阵 `isConnected` ，其中 `isConnected[i][j] = 1` 表示第 `i` 个城市和第 `j` 个城市直接相连，而 `isConnected[i][j] = 0` 表示二者不直接相连。
>
> 返回矩阵中 **省份** 的数量。
>
> **示例 1：**
>
> ![img](https://gitee.com/LowProfile666/image-bed/raw/master/img/graph1.jpg)
>
> ```
> 输入：isConnected = [[1,1,0],[1,1,0],[0,0,1]]
> 输出：2
> ```

该题和正常的图的邻接矩阵有点差别。

使用深度优先搜索的方法，遍历每一个城市节点，同时使用一个标记数组来标记哪些节点是访问过的，再遍历和当前城市直接联系的城市。

Java代码

```java
class Solution {
    public int findCircleNum(int[][] isConnected) {
        int n = isConnected.length;  // 城市总数
        int res = 0;  // 省份数量
        boolean[] f = new boolean[n];
        for (int i = 0; i < n; i++) {
            if (!f[i]) {
                dfs(isConnected, i, n, f);
                res++;
            }
        }
        return res;
    }
    public void dfs(int[][] a, int i, int n, boolean[] f) {
        f[i] = true;
        for (int j = 0; j < n; j++) {
            if (a[i][j] == 1 && !f[j])  // 遍历每一个直接联系的城市
                dfs(a, j, n, f);
        }
    }
}
```

<span id=DFS&&BFS2>[841.钥匙和房间](https://leetcode.cn/problems/keys-and-rooms/description/)</span>

> 有 `n` 个房间，房间按从 `0` 到 `n - 1` 编号。最初，除 `0` 号房间外的其余所有房间都被锁住。你的目标是进入所有的房间。然而，你不能在没有获得钥匙的时候进入锁住的房间。
>
> 当你进入一个房间，你可能会在里面找到一套不同的钥匙，每把钥匙上都有对应的房间号，即表示钥匙可以打开的房间。你可以拿上所有钥匙去解锁其他房间。
>
> 给你一个数组 `rooms` 其中 `rooms[i]` 是你进入 `i` 号房间可以获得的钥匙集合。如果能进入 **所有** 房间返回 `true`，否则返回 `false`。

rooms 其实就是一个邻接链表，rooms[i] 里的值就是 i 能访问到的点。

使用一个标记数组 f 来记录每个点是否被访问过了，在使用深度优先搜索从 room[0] 开始访问每个可以访问的节点，最后遍历标记数组，如果有没访问到的点就返回 false。

**Java代码**

```java
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int n = rooms.size();
        boolean[] f = new boolean[n];
        dfs(0, rooms, f);
        for (int i = 0; i < f.length; i++)
            if (!f[i])
                return false;
        return true;
    }
    public void dfs(int cur, List<List<Integer>> rooms, boolean[] f) {
        if (f[cur])
            return;
        f[cur] = true;
        for (int i = 0; i < rooms.get(cur).size(); i++) {
            dfs(rooms.get(cur).get(i), rooms, f);
        }
    }
}
```

<span id = DFS&&BFS3>[面试题 04.01. 节点间通路](https://leetcode.cn/problems/route-between-nodes-lcci/description/)</span>

> 节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

使用邻接表和广度优先遍历。

先将有向图转换成邻接表，然后遍历以起点为头的邻接表，判断是否能到目标点。

**Java代码**

```java
class Solution {
    public boolean findWhetherExistsPath(int n, int[][] graph, int start, int target) {
        List<List<Integer>> list = new ArrayList<>();
        // 用 list 构建邻接表
        for (int i = 0; i < graph.length; i++)
            list.add(new ArrayList<>());
        for (int i = 0; i < graph.length; i++) {
            int a = graph[i][0];
            int b = graph[i][1];
            if (a == start && b == target)
                return true;
            list.get(a).add(b);
        }
        boolean[] f = new boolean[n];
        // 用队列实现 BFS
        Queue<Integer> q = new LinkedList<>();
        q.offer(start);
        f[start] = true;
        while (!q.isEmpty()) {
            int cur = q.poll();
            List<Integer> t = list.get(cur);
            for (int i = 0; i < t.size(); i++) {
                int nex = t.get(i);
                if (!f[nex]) {
                    q.offer(nex);
                    f[nex] = true;
                    if (nex == target)
                    	return true;
                }
            }
        }
        return false;
    }
}
```





### 二叉树

<span id = "二叉树1">[面试题 04.03. 特定深度节点链表](https://leetcode.cn/problems/list-of-depth-lcci/description/)</span>

> 给定一棵二叉树，设计一个算法，创建含有某一深度上所有节点的链表（比如，若一棵树的深度为 `D`，则会创建出 `D` 个链表）。返回一个包含所有深度的链表的数组。
>
> 示例：
>
> ```
> 输入：[1,2,3,4,5,null,7,8]
> 
>         1
>        /  \ 
>       2    3
>      / \    \ 
>     4   5    7
>    /
>   8
> 
> 输出：[[1],[2,3],[4,5,7],[8]]
> ```

该题可以使用层次遍历，记录下每个节点以及它的层数，然后根据层数装入数组，最后返回数组。

**Java代码**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode(int x) { val = x; }
 * }
 */
 class Node{
     TreeNode node;
     int high;
     public Node(TreeNode node, int high) {
         this.node = node;
         this.high = high;
     }
 }
class Solution {
    public ListNode[] listOfDepth(TreeNode tree) {
        if (tree == null)
            return null;
        Node[] q = new Node[10000];
        int f = 0, r = 0;
        q[r++] = new Node(tree, 1);
        while (f < r) {
            TreeNode cur = q[f].node;
            if (cur.left != null) {
                q[r++] = new Node(cur.left, q[f].high+1);
            }
            if (cur.right != null) {
                q[r++] = new Node(cur.right, q[f].high+1);
            }
            f++;
        }
        ListNode[] res = new ListNode[q[r-1].high];
        int top = 0;
        int preHigh = 1;
        for (int i = 0; i < r; i++) {
            ListNode t = new ListNode(q[i].node.val);
            ListNode t1 = t;
            while (i < r-1 && q[i].high == q[i+1].high) {
                ListNode t2 = new ListNode(q[i+1].node.val);
                t1.next = t2;
                t2.next = null;
                t1 = t2;
                i++;
            }
            res[top++] = t;
        }
        return res;
    }
}
```

<span id = "二叉树2">[\654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/description/)</span>

> 给定一个不重复的整数数组 `nums` 。 **最大二叉树** 可以用下面的算法从 `nums` 递归地构建:
>
> 1. 创建一个根节点，其值为 `nums` 中的最大值。
> 2. 递归地在最大值 **左边** 的 **子数组前缀上** 构建左子树。
> 3. 递归地在最大值 **右边** 的 **子数组后缀上** 构建右子树。
>
> 返回 *`nums` 构建的* ***最大二叉树\*** 。

根据题意模拟，先找出数组最大值，以该最大值为当前节点的值，该最大值的下标为左右子树分界点，然后以相同的规则递归。

**Java代码**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        TreeNode res = new TreeNode();
        int maxIdx = getMaxIdx(nums, 0, nums.length-1);
        res.val = nums[maxIdx];
        res.left = construct(res, nums, 0, maxIdx-1);
        res.right = construct(res, nums, maxIdx+1, nums.length-1);
        return res;
    }
    public int getMaxIdx(int[] nums, int l, int r) {
        if (l > r)
            return -1;
        int max = nums[l], maxIdx = l;
        while (l <= r) {
            if (max < nums[l]) {
                max = nums[l];
                maxIdx = l;
            }
            ++l;
        }
        return maxIdx;
    }
    public TreeNode construct(TreeNode root, int[] nums, int l, int r) {
        int maxIdx = getMaxIdx(nums, l, r);
        if (maxIdx == -1)
            return null;
        root = new TreeNode(nums[maxIdx]);
        root.left = construct(root, nums, l, maxIdx-1);
        root.right = construct(root, nums, maxIdx+1, r);
        return root;
    }
}
```

<span id = "二叉树3">[\113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/description/)</span>

> 给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。
>
> **叶子节点** 是指没有子节点的节点。

该题需要使用先序遍历和栈，将遍历路上的节点值存入栈中，同时维护一个变量 sum 累加路径节点的值，当碰到叶子节点时判断 sum 是否和 target 相等。

**Java代码**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    List<List<Integer>> ans;
    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        ans = new ArrayList<>();
        int[] nodes = new int[5000];
        preOrder(root, targetSum, 0, nodes, 0);
        return ans;
    }
    public void preOrder(TreeNode root, int targetSum, int curSum, int[] nodes, int top) {
        if (root == null)
            return;
        curSum += root.val;
        nodes[top++] = root.val;
        if (root.left == null && root.right == null) {
            if (curSum == targetSum) {
                List<Integer> temp = new ArrayList<>();
                for (int i = 0; i < top; i++)
                    temp.add(nodes[i]);
                ans.add(temp);
            }
            return;
        }
        preOrder(root.left, targetSum, curSum, nodes, top);
        preOrder(root.right, targetSum, curSum, nodes, top);
    }
}
```

<span id = "二叉树4">[\1448. 统计二叉树中好节点的数目](https://leetcode.cn/problems/count-good-nodes-in-binary-tree/description/)</span>

> 给你一棵根为 `root` 的二叉树，请你返回二叉树中好节点的数目。
>
> 「好节点」X 定义为：从根到该节点 X 所经过的节点中，没有任何节点的值大于 X 的值。

该题的意思就是，记录从根到当前节点上，当前节点的值最大时的节点个数，所以使用一个变量 max 记录路径上的最大值，当碰到节点值大于等于 max 时，答案就加一。

**Java代码**

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int ans;
    public int goodNodes(TreeNode root) {
        ans = 0;
        preOrder(root, root.val);
        return ans;
    }
    public void preOrder(TreeNode root, int max) {
        if (root == null)
            return;
        if (root.val >= max) {
            ans++;
            max = root.val;
        }
        preOrder(root.left, max);
        preOrder(root.right, max);
    }
}
```

