# 哈希表

把比较复杂（大）的数据映射到比较简单（小）的数据。实现映射过程的函数叫做哈希函数。

哈希函数：一般通过模一个数（一般是数组的长度）来实现，一般这个数是一个质数，且要离 2 的整次幂较远。这样冲突的概率最小。

在 Java 中，模运算的结果的正负是根据左边操作数的正负来决定的，所以为了映射后的下标不为负，一般这样写哈希函数：

```java
int k = (x % N + N) % N
```

冲突：两个不同的数映射到了同一个数。

## 开放寻址法

只开一个数组 hash，这个数组的范围一般开到数据范围的 2 到 3 倍，或者是使用循环数组。

通过哈希函数拿到映射值，去 hash 数组中找这个位置，如果这个位置有数据存在了，那么就以此往后遍历，直到找到一个空位置，所以一般会将 hash 的大小开到数据个数的 2 到 3 倍，这样的话就有足够的空间来寻找，而不用从头循环找。

还需要使用一个变量来表示数组中位置是否为空，可以定义一个超出数据范围的数，初始化给 hash 数组中所有位置都赋上这个值即可。

核心操作：find 方法，返回一个数在 hash 中的位置，如果没有，则返回应该在的位置。

Java 模板

```java
int N = 200003, NULL = (int)1e9+10;  // N为hash数组长度，NULL表示空
int[] hash = new int[N];

// 查找
public int find(int x) {
    int k = (x % N + N) % N;  // 取到关键字

    // 当找不到空位置、找不到相等值就一直往后找
    while (hash[k] != x && hash[k] != NULL) {
        if (++k == N)   k = 0;  // 安全起见，一般不会找到头去
    }

	return k;  // 返回x所在或应该在的下标
}

// 插入
hash[find(x)] = x;
```

[模拟散列表](https://www.acwing.com/problem/content/842/)

> 维护一个集合，支持如下几种操作：
>
> 1. `I x`，插入一个整数 x；
> 2. `Q x`，询问整数 x 是否在集合中出现过；
>
> 现在要进行 N 次操作，对于每个询问操作输出对应的结果。

```java
import java.util.*;

public class Main{
    static int N = 200003, NULL = (int)1e9+10;
    static int[] hash = new int[N];
    
    public static void main(String[] args) {
        Arrays.fill(hash, NULL);
        
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt();
        
        while (n-- != 0) {
            String op = sc.next();
            int x = sc.nextInt();
            
            int k = find(x);
            if ("I".equals(op)) hash[k] = x;
            else    System.out.println(hash[k] == NULL ? "No" : "Yes");
        }
    }
    
    public static int find(int x) {
        int k = (x % N + N) % N;
        
        while (hash[k] != x && hash[k] != NULL) {
            if (++k == N)   k = 0;
        }
        
        return k;
    }
}
```

## 拉链法

使用一个数组 hash，数组的每个元素上都有一个链表。

![image-20231022102746108](https://gitee.com/LowProfile666/image-bed/raw/master/img/202310221027150.png)

hash 数组的下标就表示映射后的值（关键字），如果出现冲突的话（有相同关键字），就在该关键字后的链表添加元素，一般使用头插法（速度快）。

Java模板：

```java
int N = 10003, idx = 1;  // N 是大于 10000 的第一个质数，也是数组长度
int[] hash = new int[N];  // hash数组，下标表示关键字，值表示链表的头
int[] val = new int[N], nex = new int[N];  // 链表结构

// 插入
public void insert(int x) {
 	int k = (x % N + N) % N;  // 通过哈希函数拿到关键字
    val[idx] = x;
    nex[idx] = hash[k];
    hash[k] = idx++;
}

// 查找
public boolean find(int x) {
    int k = (x % N + N) % N;  // 通过哈希函数拿到关键字
    for (int i = hash[k]; i != 0; i = nex[i])
        if (val[i] == x)
            return true;
    return false;
}
```

[模拟散列表](https://www.acwing.com/problem/content/842/)

> 维护一个集合，支持如下几种操作：
>
> 1. `I x`，插入一个整数 x；
> 2. `Q x`，询问整数 x 是否在集合中出现过；
>
> 现在要进行 N 次操作，对于每个询问操作输出对应的结果。

```java
import java.util.*;

public class Main{
    static int[] hash, val, nex;
    static int idx = 1, N = 100003;
    
    public static void main(String[] args) {
        hash = new int[N];
        val = new int[N];
        nex = new int[N];
        
        Scanner sc = new Scanner(System.in);
        
        int n = sc.nextInt();
        
        while (n-- != 0) {
            String op = sc.next();
            int x = sc.nextInt();
            
            if ("I".equals(op)) insert(x);
            else    System.out.println(find(x) ? "Yes" : "No");
        }
    }
    
    public static void insert(int x) {
        int k = (x % N + N) % N;
        val[idx] = x;
        nex[idx] = hash[k];
        hash[k] = idx++;
    }
    
    public static boolean find(int x) {
        int k = (x % N + N) % N;
        
        for (int i = hash[k]; i != 0; i = nex[i])
            if (val[i] == x)
                return true;
        return false;
    }
}
```

## 字符串哈希

字符串前缀哈希法。

重要的哈希方式。

