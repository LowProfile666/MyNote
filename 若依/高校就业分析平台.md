# 基于若依高校就业分析平台

[视频地址](https://www.bilibili.com/video/BV15k4y1A7Wb/?spm_id_from=333.788&vd_source=da6b8372cd6b02c82a52737350aace72)

# 准备

[若依官网](http://ruoyi.vip/)

根据官网文档，要准备这些环境：

- JDK >= 1.8
- MySQL >= 5.7
- Maven >= 3.0
- Node >= 12
- Redis >= 3

## 配置 Redis

[Redis 的下载路径](https://github.com/tporadowski/redis/releases)，这是 github 上的包，用于 Windows 的，下载后解压缩，

注意：解压后不要有这种路径：

![image-20240218101953885](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181019929.png)

如果有，要将里面的同名路径覆盖掉外面的路径，改成这种：

![image-20240218102018530](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181020559.png)

然后需要配置 Redis 的系统环境变量，将当前路径 D:\DEV\Redis\Redis-x64-5.0.14.1 配置到系统变量 Path 中。

配置好后，打开 cmd 命令窗口，输入命令查看是否配置成功：

```bash
redis-server
```

出现以下界面即为成功：

![image-20240218103121902](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181031956.png)

此时也是 Redis 启动成功。

## 下载RuoYi-Vue

[下载地址](https://gitee.com/y_project/RuoYi-Vue)，就是从官网点过去的地址。

下载后解压，解压出来发现路径有嵌套：

![image-20240218103859957](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181038990.png)

同样需要将这个路径改为一层的：

![image-20240218103924074](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181039110.png)

然后可以将目录中的 `.github` 和 `doc` 文件夹以及 `.gitignore` 文件删掉，然后启动 IDEA，打开这个项目。

## 配置数据库、启动服务器

[官网文档](https://doc.ruoyi.vip/ruoyi-vue/document/hjbs.html#%E5%89%8D%E7%AB%AF%E8%BF%90%E8%A1%8C)

先创建数据库 ry-vue，并导入数据脚本`ry_2021xxxx.sql`，`quartz.sql`，这两个脚本在项目中的 sql 文件夹下。

再回到 IDEA 中，在 ruoyi-admin 下的 resources 包中，找到 application-druid.yml 这个文件，在里面修改数据库连接的账号和密码即可：

![image-20240218105518300](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181055375.png)

然后运行`com.ruoyi.RuoYiApplication.java`，出现如下图表示启动成功（要先启动 Redis）：

![image-20240218105717087](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181057133.png)

此时，服务器端就已经启动了。

服务器启动后，现在可以通过 http://localhost:8080/ 访问到：

![image-20240218110149086](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181101120.png)

## 客户端配置

前端的工程在 ruoyi-ui 文件夹中，使用 vscode 打开这个文件夹（或者新建一个文件夹，将 ruoyi-ui 中的东西复制过来，再删除原有的 ruoyi-ui 的东西）。

然后打开 vscode 的终端，输入命令：

```bash
# 进入项目目录
cd ruoyi-ui

# 安装依赖
npm install

# 强烈建议不要用直接使用 cnpm 安装，会有各种诡异的 bug，可以通过重新指定 registry 来解决 npm 安装速度慢的问题。
# 上一个方式可以就不用这一个
# npm install --registry=https://registry.npmmirror.com

# 本地开发 启动项目
npm run dev
```

+ 依赖安装好后，项目文件夹下会多一个 node_modules 文件夹，就是用到的第三方的 js 库

+ 如果在 vscode 终端中安装失败的的话，就可以在 ruoyi-ui 目录下通过 cmd 窗口安装，注意，需要使用管理员权限打开窗口

  ![image-20240218111320491](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181113559.png)

  如果安装失败重新安装的话，记得先将 node_modules 文件夹删除掉。

如果是使用 IDEA 打开前端项目的话，安装依赖都是一样的步骤，然后点击上面下拉框中的 Edit Configuration，左边点击加号，加一个 npm，在右边有个 Script 选择 dev 开发模式，点击 ok 即可。

然后找到前端项目中的 package.json 文件，找到：

```json
"scripts": {
    "dev": "vue-cli-service serve",
    "build:prod": "vue-cli-service build",
    "build:stage": "vue-cli-service build --mode staging",
    "preview": "node build/index.js --preview",
    "lint": "eslint --ext .js,.vue src"
  },
```

然后将 dev 中的内容替换为：

```json
SET NODE_OPTIONS=--openssl-legacy-provider&&vue-cli-service serve
```

这是因为前端需要的 node 版本是 16，我装的是 20。不换的话，启动会报错 ：

![image-20240218112826112](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181128152.png)

此时再启动就成功了：

![image-20240218130319100](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181303811.png)

这个登录页面的验证码就是放在 Redix 中的，所以每次启动项目需要启动 Redix。

## 改造前端页面、参数设置

在前端项目中，我们需要经常和 src 下的 api、views 这两个文件夹下的内容打交道。

找到 src/views/login.vue ，修改登录页面的标题，改为：高校就业分析平台；

找到 src/views/index.vue ，修改登陆后的主页，删除所有内容，只留下框架即可；

在若依的系统管理里，有一个参数设置，在这里可以设置验证码功能的开关，

![image-20240218132247835](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181322927.png)

~~将验证码功能关闭后，就可以不用启动 Redix 服务了。先停掉 Redix 服务和后台，然后重新只运行后台服务即可。~~

## 工作目录

[文档](https://doc.ruoyi.vip/ruoyi-vue/document/xmjs.html#%E5%90%8E%E7%AB%AF%E7%BB%93%E6%9E%84)

后端结构：

```bash
com.ruoyi     
├── common            // 工具类
│       └── annotation                    // 自定义注解
│       └── config                        // 全局配置
│       └── constant                      // 通用常量
│       └── core                          // 核心控制
│       └── enums                         // 通用枚举
│       └── exception                     // 通用异常
│       └── filter                        // 过滤器处理
│       └── utils                         // 通用类处理
├── framework         // 框架核心
│       └── aspectj                       // 注解实现
│       └── config                        // 系统配置
│       └── datasource                    // 数据权限
│       └── interceptor                   // 拦截器
│       └── manager                       // 异步处理
│       └── security                      // 权限控制
│       └── web                           // 前端控制
├── ruoyi-generator   // 代码生成（可移除）
├── ruoyi-quartz      // 定时任务（可移除）
├── ruoyi-system      // 系统代码
├── ruoyi-admin       // 后台服务
├── ruoyi-xxxxxx      // 其他模块
```

+ common：不需要动

前端结构：

```bash
├── build                      // 构建相关  
├── bin                        // 执行脚本
├── public                     // 公共文件
│   ├── favicon.ico            // favicon图标
│   └── index.html             // html模板
│   └── robots.txt             // 反爬虫
├── src                        // 源代码
│   ├── api                    // 所有请求
│   ├── assets                 // 主题 字体等静态资源
│   ├── components             // 全局公用组件
│   ├── directive              // 全局指令
│   ├── layout                 // 布局
│   ├── plugins                // 通用方法
│   ├── router                 // 路由
│   ├── store                  // 全局 store管理
│   ├── utils                  // 全局公用方法
│   ├── views                  // view
│   ├── App.vue                // 入口页面
│   ├── main.js                // 入口 加载组件 初始化等
│   ├── permission.js          // 权限管理
│   └── settings.js            // 系统配置
├── .editorconfig              // 编码格式
├── .env.development           // 开发环境配置
├── .env.production            // 生产环境配置
├── .env.staging               // 测试环境配置
├── .eslintignore              // 忽略语法检查
├── .eslintrc.js               // eslint 配置项
├── .gitignore                 // git 忽略项
├── babel.config.js            // babel.config.js
├── package.json               // package.json
└── vue.config.js              // vue.config.js
```

# 准备数据库表

九张表：

+ t_province：省份表

  ![image-20240218144012659](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181440701.png)

+ t_city：城市表

  ![image-20240218142559865](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181426727.png)

+ t_university：学校表

  ![image-20240218144400792](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181444837.png)

+ t_college：学院表

  ![image-20240218144420109](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181444154.png)

+ t_major：专业表

  ![image-20240218144433132](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181444177.png)

+ t_class：班级表

  ![image-20240218144448940](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181444989.png)

+ t_student：学生表

  ![image-20240218144509233](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181445338.png)

+ t_employment：就业表

  ![image-20240218144526060](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181445109.png)

+ t_industry：行业表

  ![image-20240218144547550](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181445590.png)

删除标记默认都是 0。

# 创建工程

创建一个就业模块：

![image-20240218144947455](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181449607.png)

修改它的 pom.xml 文件，打包方式改为 jar，删除多余东西，引入若依的 common 模块：

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.ruoyi</groupId>
        <artifactId>ruoyi</artifactId>
        <version>3.8.7</version>
    </parent>
    <groupId>ruoyi.employment</groupId>
    <artifactId>ruoyi-employment</artifactId>
    <packaging>jar</packaging>
    <name>ruoyi-employment</name>
    <dependencies>
<!--        引入若依common工具类-->
        <dependency>
            <groupId>com.ruoyi</groupId>
            <artifactId>ruoyi-common</artifactId>
        </dependency>
    </dependencies>
</project>
```

在 ruoyi-common 中的 pom.xml 中引入 lombok 的依赖：

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
</dependency>
```

然后将这个就业模块导入到 ruoyi-admin 模块中，在 ruoyi-admin 模块中的 pom.xml 中：

```xml
<!--        就业模块-->
<dependency>
    <groupId>ruoyi.employment</groupId>
    <artifactId>ruoyi-employment</artifactId>
    <version>3.8.7</version>
</dependency>
```

这样，就在若依这个项目中，构建了我们自己的项目。

然后，在这个 ruoyi-employment 模块中，将 java 文件夹创建出来，再创建包，包的名字必须是 com.ruoyi.employment，因为其他模块的包名就是这样。然后再在 resources 包下创建一个 mapper 目录，这是放 mybatis 配置文件的：

![image-20240218150602277](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181506322.png)

# 学校管理

## 生成代码

先做 t_university 表。

在若依管理系统里面，系统工具中有个代码生成，点击导入，

![image-20240218150841193](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181508278.png)

选择 t_university  数据库表，然后点击确定

![image-20240218150906101](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181509181.png)

然后可以编辑当前选中的表：

![image-20240218150949487](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181509572.png)

编辑基本信息：

![image-20240218165902745](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181659825.png)

+ 实体类名称默认是表名每个单词的首字母大写

字段信息：

![image-20240218165947419](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181659516.png)

+ 就是将这张表生成一个 Java 类，将字段对应为类中的属性
+ Java属性就是字段对应的 bean 的属性
+ Java类型就是字段对应属性的类型

生成信息：

![image-20240218170742267](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181707345.png)

+ 注意：**如果前端类型选了Vue3 Plus的话，下载下来后可能会不匹配，导致出现报错**，所以选默认的Vue2即可
+ 包路径要选刚刚创建的 ruoyi-employment 模块中的 com.ruoyi.employment 包，默认是 system 包
+ 模块名和业务名改为一样
+ 功能名就是描述
+ 上级菜单就是左侧的菜单

然后可以预览生成的代码：

![image-20240218152145927](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181521019.png)

+ 这里面生成了一份 sql 代码，将这个 sql 代码复制下来，这个是用来增加系统菜单的，复制下来后去数据库管理工具中运行，然后找到菜单表 sys_menu，可以查看生成的数据。

  ![image-20240218152610852](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181526912.png)

  ![image-20240218152714241](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181527293.png)

然后点击生成代码，将代码下载下来，下载后解压，里面有三个东西：

![image-20240218152945175](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181529227.png)

+ main 是后端代码
  + java/com/ruoyi/employment：
    + controller：控制器
    + domain：bean类
    + mapper：mapper接口
    + service：业务接口及实现类
  + resources：sqlmapper 配置文件
+ vue 是前端代码
  + api：接口代码
  + views：页面代码
+ sql 是数据库代码

## 复制代码

sql 代码已经运行过了。

复制前端代码：直接将这两个文件夹复制，然后通过资源管理器，在前端项目 src 下进行粘贴，会自动将文件夹中的内容合并到原来的 api 和 views 文件夹中。

复制后端代码：

1. 先在com/ruoyi/employment下新建一个包 domain，将生成的 domain 中的Java类复制进去。修改一下，不继承 BaseEntity 类，直接实现 Serializable 接口。

   然后使用 Lombok 的注解，删除生成的 getter、setter 和继承的方法：

   ```java
   package com.ruoyi.employment.domain;
   
   import java.io.Serializable;
   import java.util.Date;
   import com.fasterxml.jackson.annotation.JsonFormat;
   import lombok.AllArgsConstructor;
   import lombok.Data;
   import lombok.NoArgsConstructor;
   import org.apache.commons.lang3.builder.ToStringBuilder;
   import org.apache.commons.lang3.builder.ToStringStyle;
   import com.ruoyi.common.annotation.Excel;
   import com.ruoyi.common.core.domain.BaseEntity;
   
   /**
    * 学校管理对象 t_university
    * 
    * @author zsm
    * @date 2024-02-18
    */
   @Data
   @NoArgsConstructor
   @AllArgsConstructor
   public class TUniversity implements Serializable
   {
       private static final long serialVersionUID = 1L;
   
       /** 高校主键 */
       private String id;
   
       /** 名称 */
       @Excel(name = "名称")
       private String name;
   
       /** 描述 */
       @Excel(name = "描述")
       private String desc;
   
       /** 修改时间 */
       @JsonFormat(pattern = "yyyy-MM-dd")
       @Excel(name = "修改时间", width = 30, dateFormat = "yyyy-MM-dd")
       private Date modifyTime;
   
       /** 创建时间 */
       @JsonFormat(pattern = "yyyy-MM-dd")
       @Excel(name = "创建时间", width = 30, dateFormat = "yyyy-MM-dd")
       private Date createTime;
   
       /** 删除标记 */
       private Long deleted;
   }
   ```

2. 在 com/ruoyi/employment 包下建一个 mapper 包，用来放 mapper 接口文件的，然后将生成的 mapper 文件复制进去，然后使用 @Repository 注解标注。

3. 将生成的 resources 下的 mapper 文件拷贝复制到 com/ruoyi/employment/resources/mapper 文件夹下

4. 在 com/ruoyi/employment 包下建一个 service 包，再在 service 下建个 impl 包，用来放业务接口和实现类的，然后将生成的 service 中的文件复制进去

   ![image-20240218163406967](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181634033.png)

5. 在 ruoyi-admin 模块下的 com.ruoyi.web.controller 下新建一个包 employment，将生成的控制器文件复制过来

代码复制完后，前后端都要重启。此时在运行项目，系统管理菜单中就有了一个学校管理的选择：

![image-20240218164603026](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181646131.png)

## 新增学校

在点击新建时，输入了学校名称和描述，提交时，报了错：

![image-20240218164839115](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181648213.png)

这是因为我的属性名叫做 desc，是一个mysql中的关键字，这就可能导致mybatis在生成数据库语句的时候出现语法错误，所以我将数据库中的属性名改了，并重新生成了代码。

然后在添加一次还是报错：

![image-20240218182111863](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181821186.png)

这是因为我们的 t_university 表的主键没有设置默认值，且这个新建的时候没有给主键赋值，所以我们需要在代码中给主键赋值。

在 UniversityController 里，有一个新增的方法，在这里面添加代码：

```java
/**
     * 新增学校管理
     */
@PreAuthorize("@ss.hasPermi('employment:university:add')")
@Log(title = "学校管理", businessType = BusinessType.INSERT)
@PostMapping
public AjaxResult add(@RequestBody University university)
{
    university.setId(UUID.randomUUID().toString());  // 设置id
    university.setCreateTime(DateUtils.getNowDate());  // 设置创建时间
    return toAjax(universityService.insertUniversity(university));
}
```

+ 这个 UUID 是若依框架里面的 UUID
+ 这个 DateUtils 也是若依的

那么也将修改时的代码修改一下，设置一下修改时间：

```java
/**
     * 修改学校管理
     */
@PreAuthorize("@ss.hasPermi('employment:university:edit')")
@Log(title = "学校管理", businessType = BusinessType.UPDATE)
@PutMapping
public AjaxResult edit(@RequestBody University university)
{
    university.setModifyTime(DateUtils.getNowDate());
    return toAjax(universityService.updateUniversity(university));
}
```

这时候刷新一下页面，重新添加学校，就发现添加成功了：

![image-20240218182910096](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181829204.png)

然后可以在前端项目中 src/views/employment/university 下修改 index.vue 中的代码，将主键不显示在页面上，将以下代码注释或删除：

```vue
<el-table-column label="高校主键" align="center" prop="id" />
```

再添加一个学校，又出现了报错：

![image-20240218183646983](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181836074.png)

这个报错是说学校描述的这个字段内容太长了，超过了数据库中设置的 255 个长度，可以将描述缩小，或者扩大表中字段的长度范围即可。

## 程序执行流程

当页面上发生操作时，会先进入 ruoyi-admin 里的控制器，控制器会调用业务层的方法，业务层的接口都有自己的实现类，就会调用实现类里的方法，实现类中就有对应的 mapper，就会通过 mapper 来操作数据库

## 控制器方法解释

解释一下控制器中的方法，以查询方法为例：

```java
/**
     * 查询学校管理列表
     */
@PreAuthorize("@ss.hasPermi('employment:university:list')")
@GetMapping("/list")
public TableDataInfo list(University university)
{
    startPage();
    List<University> list = universityService.selectUniversityList(university);
    return getDataTable(list);
}
```

+ `@GetMapping("/list")`：设置页面请求方式，这里是 get 请求，get 请求一般用于查询，"/list" 是该方法的路径，但这不是完整的请求路径，完整的请求路径是控制器的路径加上这个方法的路径。
+ post 请求的注解是 `@PostMapping()`，post 一般用于添加
+ put 请求的注解是 `@PutMapping()`，put 一般用于修改
+ delete 请求的直接是 `@DeleteMapping()`，delete 一般用于删除
+ 如果注解中没有路径，比如：`@PostMapping`，就说明是控制器的路径

控制器中的这些方法是通过哪里过来的？是前端中 api 下的 js 文件。

再看增删改的方法，

```java
/**
     * 删除学校管理
     */
@PreAuthorize("@ss.hasPermi('employment:university:remove')")
@Log(title = "学校管理", businessType = BusinessType.DELETE)
@DeleteMapping("/{ids}")
public AjaxResult remove(@PathVariable String[] ids)
{
    return toAjax(universityService.deleteUniversityByIds(ids));
}
```

这些方法的返回值类型都是 AjaxResult ，这是若依框架封装的一个通用的返回值类型，他主要有三个属性：

```java
/** 状态码 */
public static final String CODE_TAG = "code";

/** 返回内容 */
public static final String MSG_TAG = "msg";

/** 数据对象 */
public static final String DATA_TAG = "data";
```

+ 状态码：200 表示成功……

若依还提供了一个方法 `toAjax` 将数据转为 `AjaxResult` 这种类型，这个方法来自于 BaseController 中。

同时，在增删改的方法上，都还有一句：`@Log(title = "学校管理", businessType = BusinessType.DELETE)` 类似的，这是用来记录日志的，这个日志可以在页面上的日志管理中的操作日志能看到：

![image-20240218191054125](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402181910228.png)

还有在每个方法上面都有这样一句：`@PreAuthorize("@ss.hasPermi('employment:university:list')")`，这个不能省略，这个是用来权限验证的，表示当前方法是需要什么权限的。

### 前端到后端的流程

在我添加学校，点击提交的时候，提交按钮是怎么调用到后端的？

+ 在学校管理的页面文件中，提交按钮绑定了一个叫 submitForm 的函数，这个函数中有这一部分代码：

  ```js
  addUniversity(this.form).then(response => {
      this.$modal.msgSuccess("新增成功");  // 添加成功后，提示信息
      this.open = false;  // 关闭添加对话框
      this.getList();  // 重新查询
  });
  ```

  + 这个参数 `this.form`，这个参数是定义的一个对象，然后通过与前端控件的双向绑定（v-model）来获取数据的

  先调用 addUniversity 这个函数，这就是添加学校的函数，这个函数是通过以下代码引进来的：

  ```js
  import { listUniversity, getUniversity, delUniversity, addUniversity, updateUniversity } from "@/api/employment/university";
  ```

  那这个 @/api/employment/university 文件就是开始时生成的 api 文件，在这个文件里面的 addUniversity 函数是这样的：

  ```js
  // 新增学校管理
  export function addUniversity(data) {
    return request({
      url: '/employment/university',
      method: 'post',
      data: data
    })
  }
  ```

  然后就是从这里调到了后端的代码上，完成了添加。

## 逻辑删除

每一张表里都有一个字段 deleted 来表示删除状态，值为 0，表示没有删除，为 1 表示删除，默认值为 0。

要实现假删除，就是将这个字段改变为 1 ，不会从数据库中真正的删除它，在查询的时候只需要多谢上一句 where deleted = 0 即可，但是框架生成的代码中真删除，需要我们自己修改。

在 resources/mapper 下的UniversityMapper.xml 中修改：
```xml
<select id="selectUniversityList" parameterType="University" resultMap="UniversityResult">
    <include refid="selectUniversityVo"/>
    <where>  
        <if test="name != null  and name != ''"> and name like concat('%', #{name}, '%')</if>
        and deleted = 0  -- 添加了这一句
    </where>
</select>
```

改了查询之后，已经查不到删除位是 1 的数据了，还要改一下删除的代码，删除的代码就使用 update 的操作，将删除位改为 1 即可：

```xml
<delete id="deleteUniversityById" parameterType="String">
    --         delete from t_university where id = #{id}
    update t_university set deleted = 1 where id = #{id}
</delete>

<delete id="deleteUniversityByIds" parameterType="String">
    --         delete from t_university where id in
    update t_university set deleted = 1 where id in
    <foreach item="id" collection="array" open="(" separator="," close=")">
        #{id}
    </foreach>
</delete>
```

## 显示问题

接下来处理页面上，高校简介显示的问题。一旦描述过长，就会将这一栏的高度撑大，不利于列表显示。

在前端的主页中，找到表格中显示学校简介的元素：

```vue
<el-table-column label="描述" align="center" prop="description" />
```

将它修改为一种折叠面板的样式，可以去 element 官网里面找，找到对应的样式，将代码复制过来：

```vue
<el-table-column type="expand">
    <template v-slot="scope">
		<el-card>
    		{{ scope.row.description }}
        </el-card>
	</template>
</el-table-column>
```

+ `<el-table-column type="expand">`: 这是 Element UI 提供的一个表格列组件，它的 type 属性被设置为 "expand"，表明这个列是一个可展开的列，用来显示额外的信息。
+ `<template v-slot="scope">`: 这是 Vue.js 中的一个模板语法，用于定义一个插槽 (slot)。在这个情况下，插槽被命名为 "scope"。这个插槽会被 el-table-column 组件用来渲染展开的内容。
  + 这个 scope 只是个名字，随意取
+ `<el-card>`: 这是 Element UI 提供的一个卡片组件，用来包裹展开内容。卡片组件通常用于呈现一些独立的信息块，提供了边框和阴影效果。
+ `{{ scope.row.description }}`: 这里是使用插值表达式，输出了在表格中当前行 (scope.row) 的描述信息 (description)。这个描述信息将会被包含在展开的卡片组件中，显示在表格中的展开列中。
  + 可以直接输出 scope.row 查看，发现这就是一个 university 对象，里面都是 university 的数据

当前效果：

![image-20240219093519515](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402190935651.png)

# 学院管理

表为 t_college，先在系统功能中生成代码，字段配置如下：

![image-20240219095031603](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402190950786.png)

然后将生成的 sql 代码执行到数据库中，创建好对应的菜单。

接着将代码下载下来，复制到对应的地方。记得：  

+ domain 类使用 Lombok 的注解，实现 Serializable 接口，删除生成的 getter 和 setter，创建一个 createTime 属性，因为生成的代码中没有，是继承过来的。
+ mapper 接口文件要使用 @Repository 注解

然后修改 mapper 配置文件，修改查询和删除的 sql 代码。然后前后端工程重启一下。然后系统管理中就有了学院管理：

![image-20240219100928634](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402191009731.png)

## 新增学院

在新增学院的时候，需要选择所属学校，应该将当前学校以下拉框的形式展示出来。

### 后端

先写后端的查询所有学校的方法。在 controller 中写好前端调用的接口，在 service中写业务接口，在 impl 中写业务实现，在 mapper.xml 中写 sql 代码。

先在 UniversityController 中写页面的访问接口：

```java
/**
     * 查询所有的学校
     */
@PreAuthorize("@ss.hasPermi('employment:university:getAllUniversities')")
@Log(title = "查询所有的学校信息，初始化新增学院的下拉框", businessType = BusinessType.EXPORT)
@GetMapping("/getAllUniversities")
public AjaxResult getAllUniversities() {
    return success(universityService.getAllUniversities());
}
```

+ success 是 AjaxResult 类中的一个方法，返回成功消息

然后要在 UniversityService 中写业务接口：

```java
/**
     * 查询所有的学校信息，初始化学院的下拉框
     * @return
     */
List<University> getAllUniversities();
```

然后在 UniversityService 的实现类 UniversityServiceImpl 中写方法的实现：

```java
@Override
public List<University> getAllUniversities() {
    return universityMapper.getAllUniversities();
}
```

然后在 UniversityMapper 中写方法接口：

```java
List<University> getAllUniversities();
```

最后在UniversityMapper.xml 中写对应的 sql 代码：

```xml
<select id="getAllUniversities" resultMap="UniversityResult">
    select * from t_university where deleted = 0
</select>
```

### 前端

后端接口写好了，就要写前端的调用了。

在前端的 api 目录下找到 university.js ，调用接口：

```js
// 获取所有的学校信息，初始化学院的下拉框
export function getAllUniversities() {
  return request({
    url: '/employment/university/getAllUniversities',
    method: 'get'
  })
}
```

然后在学院的页面中，引入这个方法：

```js
import { getAllUniversities } from "../../../api/employment/university";
```

引入过后，要使用这个方法，在 methods 中定义一个另外的方法，用来绑定在下拉框上，并使用上面的方法：

```js
/** 获取所有的学校信息 */
getAllUniversities() {
    getAllUniversities().then(resp => console.log(resp))
},
```

+ resp 就是获取到的信息，可以打印输出看下内容：

  ![image-20240219104308407](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402191043518.png)

  说明我们只需要 resp 中 data 的值，就可以了。

那么这个方法在什么时候调用呢？在生命周期函数中调用，在浏览器加载这个对象的时候，就会调用：

```js
created() {
    this.getList();
    this.getAllUniversities();
},
```

那接下来就是将获得数据 resp.data 初始化到下拉框中。

定义一个数组，存放下拉列表的值：

```js
data() {
    return {
      // 学校选项
      universityOptions: [],
      //...
    }
}
```

然后将获取到的值赋给这个变量：
```js
/** 获取所有的学校信息 */
getAllUniversities() {
    getAllUniversities().then(resp => {
        console.log(resp);
        this.universityOptions = resp.data;
    })
},
```

接着修改下拉框组件，这是原来的：

```vue
<el-form-item label="高校外键" prop="uniId">
    <el-input v-model="form.uniId" placeholder="请输入高校外键" />
</el-form-item>
```

修改为：

```vue
<el-form-item label="所属学校" prop="uniId">
    <el-select v-model="form.uniId" placeholder="请选择学校">
        <el-option v-for="u in universityOptions" :key="u.id" :value="u.id" :label="u.name"></el-option>
    </el-select>
</el-form-item>
```

+ `<el-form-item label="所属学校" prop="uniId">`: 这是 Element UI 提供的一个表单项组件，**用于包裹一个表单元素**，并且包含一个标签 (label) 显示 "所属学校"，同时定义了这个表单项的校验属性 (prop) 为 "uniId"，这在表单验证时会用到。
+ `<el-select v-model="form.uniId" placeholder="请选择学校">`: 这是 Element UI 提供的一个选择框组件，用于从预定义的选项中选择一个值。`v-model="form.uniId"` 将选择框的值与 Vue 实例中的 `form.uniId` 数据进行双向绑定，这意味着选择框的值会随着 `form.uniId` 的改变而改变，反之亦然。`placeholder="请选择学校"` 设置了选择框的占位符文本，当没有选中值时会显示该文本。
+ `<el-option v-for="u in universityOptions" :key="u.id" :value="u.id" :label="u.name"></el-option>`: 这是 Element UI 提供的选项组件，用于定义选择框中的选项。`v-for="u in universityOptions"` 通过遍历 `universityOptions` 数组中的每个元素来动态创建选项。`:key="u.id"` 定义了每个选项的唯一键，`:value="u.id"` 定义了选项的实际值，即选中后所对应的值，`:label="u.name"` 定义了选项的显示文本，即选项列表中显示的内容。

此时就可以正常选择：

![image-20240219110231643](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402191102762.png)

### 问题

在添加的时候，会报错：

![image-20240219110321273](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402191103401.png)

同样是因为没有 id 值导致的，所以要修改后端控制器中的代码，修改方法和之前的一样。在新增的方法中设置 id 值和创建时间，在修改的时候设置修改时间。

然后添加成功，页面显示：

![image-20240219112759228](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402191127340.png)

需要将学院主键隐藏显示，将所属学校显示为学校名字。

将这一行删除或注释：

```vue
<el-table-column label="学院主键" align="center" prop="id" />
```

然后想要获得学校的名字，那么在查询学院的时候就需要联合查询，将对应的学校名字也查出来：

```sql
SELECT c.*, u.`name` uniName FROM t_college c left join t_university u on c.uni_id = u.id
```

将这个 sql 语句改到 CollegeMapper.xml 中：

```xml
<select id="selectCollegeList" parameterType="College" resultMap="CollegeResult">
    SELECT c.*, u.`name` uniName FROM t_college c left join t_university u on c.uni_id = u.id
    <!--    <include refid="selectCollegeVo"/> 这是原来引入的 sql 语句-->
    <where>  
        <if test="name != null  and name != ''"> and c.name like concat('%', #{name}, '%')</if>
        and c.deleteed = 0
    </where>
</select>
```

+ 注意，表名起了别名，记得将下面代码用到的属性都加上别名

查到了学校名字之后，需要在 College 类中添加一个字段来接收，用于返回给前端：

```java
/** 高校名称*/
private String uniName;
```

+ 注意：这个属性名，要和上面查询出来的列名相同才会自动赋值，这样就不用进行下一步手动赋值

~~然后要在 CollegeMapper.xml 中修改查询语句返回的类型，修改 resultMap，将这个 uniName 赋值：~~

```java
<result property="uniName"    column="uni_name" />
```

在前端中就直接使用 uniName 就可以了：

```vue
<el-table v-loading="loading" :data="collegeList" @selection-change="handleSelectionChange">
	<el-table-column label="所属学校" align="center" prop="uniName" >
```

+ 因为这个 table 绑定的数据是 collegeList，这个 collegeList 的值来自：

  ```js
  /** 查询学院管理列表 */
  getList() {
      this.loading = true;
      listCollege(this.queryParams).then(response => {
          this.collegeList = response.rows;
          this.total = response.total;
          this.loading = false;
      });
  },
  ```

  他就是一行 college 数据，他就有 college 类中的属性，可以直接使用。

当前效果：

![image-20240219130215712](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402191302897.png)

最后可将简介部分修改为和学校管理的模块一样：

```vue
<el-table-column type="expand">
    <template v-slot="scope">
		<el-card>{{ scope.row.description }}</el-card>
    </template>
</el-table-column>
```

# 省份管理

使用代码生成器先生成代码，然后拷贝代码，

+ 给 mapper 接口添加 @Repository 注解
+ 给实体类删除继承关系，使用 Lombok 注解，实现 Serializable 接口，定义创建时间属性
+ 给 controller 的添加方法中设置 id、创建时间，修改方法中设置修改时间
+ 修改 mapper.xml 文件中的 sql 代码，实现假删除，查寻也是判断假删除
+ 删除前端显示主键的代码。

# 城市管理

使用代码生成器先生成代码，然后拷贝代码，

+ 给 mapper 接口添加 @Repository 注解
+ 给实体类删除继承关系，使用 Lombok 注解，实现 Serializable 接口，定义创建时间属性，定义一个省份名字属性，用来显示省份
+ 给 controller 的添加方法中设置 id、创建时间，修改方法中设置修改时间
+ 修改 mapper.xml 文件中的 sql 代码，实现假删除，查寻也是判断假删除，同时实现联合查询，获取省份名字
+ 删除前端显示主键的代码，显示省份名字

接下来需要将所有的省份做成一个下拉选择，用在新增城市的页面上。

首先在后端写获取所有省份的接口：

ProvinceController：

```java
/**
     * 获取所有省份
     */
@PreAuthorize("@ss.hasPermi('province:province:getAllProvinces')")
@GetMapping(value = "/getAllProvinces")
public AjaxResult getAllProvinces()
{
    return success(provinceService.getAllProvinces());
}
```

ProvinceService：

```java
/**
     * 获取所有省份
     * @return
     */
List<Province> getAllProvinces();
```

ProvinceServiceImpl：

```java
/**
     * 获取所有省份
     * @return
     */
@Override
public List<Province> getAllProvinces() {
    return provinceMapper.getAllProvinces();
}
```

ProvinceMapper.java：

```java
/**
     * 获取所有省份
     * @return
     */
List<Province> getAllProvinces();
```

ProvinceMapper.xml：

```xml
<select id="getAllProvinces" resultMap="ProvinceResult">
    <include refid="selectProvinceVo"/>
</select>
```

前端：

api 下的 province.js：

```js
// 获取所有省份
export function getAllProvinces() {
  return request({
    url: "/province/province/getAllProvinces",
    method: "get",
  })
}
```

views/city 下的 index.vue：

引入函数：

```js
import { getAllProvinces } from "../../../api/province/province";
```

定义变量：

```js
data() {
    return {
      // 所有的省份
      provinceOptions: [],
    }
}
```

使用函数：

```js
methods: {
    // 获取所有省份
    getAllProvinceOptions() {
        getAllProvinces().then(resp => {
            this.provinceOptions = resp.data;
        })
    },
}
```

调用自己的函数：

```js
created() {
    this.getList();
    this.getAllProvinceOptions();
},
```

修改页面：

```vue
<el-form-item label="省份" prop="provinceId">
    <el-select placeholder="选择省份" v-model="form.provinceId" >
        <el-option v-for="p in provinceOptions" :key="p.id" :value="p.id" :label="p.name"></el-option>
    </el-select>
</el-form-item>
```

# 行业管理

使用代码生成器先生成代码，然后拷贝代码，

+ 给 mapper 接口添加 @Repository 注解
+ 给实体类删除继承关系，使用 Lombok 注解，实现 Serializable 接口，定义创建时间属性
+ 给 controller 的添加方法中设置 id、创建时间，修改方法中设置修改时间
+ 修改 mapper.xml 文件中的 sql 代码，实现假删除，查寻也是判断假删除
+ 删除前端显示主键的代码

# 菜单定义

在系统管理里面有一个菜单管理，可以用来配置菜单。

创建一个数据管理目录，将之前所有的管理都放在这个目录下：

![image-20240219161843061](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402191618240.png)

+ 菜单类型选目录，就可以在这个菜单下放二级菜单
+ 排序是显示在左侧的顺序，从小到大排
+ 外链就是外部链接，路由就要写一个链接
+ 如果不是外链，路由地址就填模块名

然后将之前的那些页面都放在数据管理菜单中，只需要修改上级菜单即可：

![image-20240219162900725](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402191629895.png)

之后再生成代码的时候，就可以选择上级菜单，选择到数据管理中。

# 专业管理

使用代码生成器先生成代码，然后拷贝代码，

+ 给 mapper 接口添加 @Repository 注解
+ 给实体类删除继承关系，使用 Lombok 注解，实现 Serializable 接口，定义创建时间属性
+ 给 controller 的添加方法中设置 id、创建时间，修改方法中设置修改时间
+ 修改 mapper.xml 文件中的 sql 代码，实现假删除，查询也是判断假删除
+ 删除前端显示主键的代码，修改显示学院外键的代码
+ 将添加专业时的学院设为下拉框。
+ 将描述部分变为展开行显示

专业是属于学院下的，学院是属于学校下的，所以添加和删除专业的时候，都要考虑是哪个学校哪个学院的。

## 显示三个名称

在显示专业的时候，将专业所属的学院和学校都显示出来，那么查询语句就涉及到了三个表，要这样写：

```sql
select m.*, c.name collegeName, u.name universityName
from t_major m 
left join t_college c
on m.college_id =  c.id
left join t_university u
on c.uni_id = u.id
```

所以要将 MajorMapper.xml 中的查询语句改为：

```xml
<select id="selectMajorList" parameterType="Major" resultMap="MajorResult">
    select m.*, c.name collegeName, u.name universityName
    from t_major m
    left join t_college c
    on m.college_id =  c.id
    left join t_university u
    on c.uni_id = u.id
    <where>  
        <if test="collegeId != null  and collegeId != ''"> and college_id = #{collegeId}</if>
        <if test="name != null  and name != ''"> and m.name like concat('%', #{name}, '%')</if>
        and m.deleted = 0
    </where>
</select>
```

此时专业这个Java类 Major 中，没有学院名称对应的属性，所以要定义个属性，顺便也将学校名称定义一下：

```java
// 学院名
private String collegeName;
// 学校名
private String universityName;
```

然后要修改前端页面，将专业名称、学院名称、学校名称都显示出来：

```vue
<el-table-column label="专业名称" align="center" prop="name" />
<el-table-column label="学院名称" align="center" prop="collegeName" />
<el-table-column label="学校名称" align="center" prop="universityName" />
```

此时效果：

![image-20240220000639048](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402200006149.png)

## 查询

还要修改前端的查询条件区域，可以按学院名称、专业名称和学校名称来搜索。

在按条件查询的时候，默认生成了两个条件，一个是学院 id，一个是专业名称，应该将学院 id 这个查询条件改成学院的名称，并且添加一句按学校名称搜索，所以修改以上部分代码：

```xml
<where>
    <if test="collegeName != null  and collegeName != ''"> 
        and c.name like concat('%', #{collegeName}, '%')</if>
    <if test="name != null  and name != ''"> 
        and m.name like concat('%', #{name}, '%')</if>
    <if test="universityName != null  and universityName != ''"> 
        and u.name like concat('%', #{universityName}, '%')</if>
    and m.deleted = 0
</where>
```

然后需要定义前端的代码，因为默认生成只有两个查询条件，所以要在前端新加一个输入框，用来输入学校名称：

```vue
<el-form-item label="专业名称" prop="name">
    <el-input
              v-model="queryParams.name"
              placeholder="请输入专业名称"
              clearable
              @keyup.enter.native="handleQuery"
              />
</el-form-item>
<el-form-item label="学院名称" prop="collegeName">
    <el-input
              v-model="queryParams.collegeName"
              placeholder="请输入学院外键"
              clearable
              @keyup.enter.native="handleQuery"
              />
</el-form-item>
<el-form-item label="学校名称" prop="universityName">
    <el-input
              v-model="queryParams.universityName"
              placeholder="请输入学校名称"
              clearable
              @keyup.enter.native="handleQuery"
              />
</el-form-item>
```

+ 学院名称那里是将原本的 collegeId 改为了 collegeName
+ 学校名称 collegeName 是直接新建的

可以看到三个输入框都是绑定的 queryParams 这个数据，所以想在这个 queryParams 对象中添加对应的属性：

```js
data() {
    return {
      //...
      // 查询参数
      queryParams: {
        pageNum: 1,
        pageSize: 10,
        collegeName: null,
        name: null,
        universityName: null,
        description: null,
      },
      //...
    }
}
```

现在就可以按三个条件进行搜索：

![image-20240220002108735](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402200021830.png)

## 执行流程

搜索按钮上绑定的点击事件是 handleQuery，handleQuery 的定义：

```js
/** 搜索按钮操作 */
handleQuery() {
    this.queryParams.pageNum = 1;
    this.getList();
},
```

在 handleQuery 中会调用 getList 函数，getList 函数的定义：

```js
/** 查询专业管理列表 */
getList() {
    this.loading = true;
    listMajor(this.queryParams).then(response => {
        this.majorList = response.rows;
        this.total = response.total;
        this.loading = false;
    });
},
```

在 getList 中的会调用 listMajor 函数，同时将 queryParams 对象传过去，这个对象就是定义的对象，三个输入框分别绑定了它的三个属性，listMajor 函数就是 api 中定义的函数：

```js
// 查询专业管理列表
export function listMajor(query) {
  return request({
    url: '/major/major/list',
    method: 'get',
    params: query
  })
}
```

在这里就会调用到后端的方法，将参数传过去，参数里面带有输入的条件，就能实现条件查询。

## 添加学校选择

在添加专业的时候，就应该先选择学校，再选择学院，最后输入专业的名字。所以需要在添加页面上再加一个选择学校的下拉框。并且，学院的数据是根据选择的学校来定的，也就是说学校下拉框和学院下拉框是联动的。

首先，在前端中获取到学校数据，获取所有的学校数据已经有了接口，可以直接使用，定义一个数组接收就可以了，在 data 中定义一个数组：

```js
universityOptions: [],
```

在 methods 中定义一个获取所有学校的方法：

```js
getAllUniversityOptions() {
    getAllUniversities().then(resp => {
        this.universityOptions = resp.data;
    })
},
```

要使用 getAllUniversities 函数，需要先导入：

```js
import { getAllUniversities } from "../../../api/employment/university";
```

然后新建一个用来选择学校的下拉框：

```vue
<el-form-item label="学校名称" prop="universityName">
    <el-select v-model="form.universityId">
        <el-option v-for="u in universityOptions" 
                   :key="u.id" 
                   :value="u.id" 
                   :label="u.name" 
                   placeholder="选择学校"></el-option>
    </el-select>
</el-form-item>
<el-form-item label="学院名称" prop="collegeName">
    <el-select v-model="form.collegeId">
        <el-option v-for="c in collegeOptions" 
                   :key="c.id" :value="c.id" 
                   :label="c.name" 
                   placeholder="选择学院"></el-option>
    </el-select>
</el-form-item>
<el-form-item label="专业名称" prop="name">
    <el-input v-model="form.name" placeholder="请输入专业名称" />
</el-form-item>
```

## 联动

接下来就是要让选择学校后，学院的下拉框的选项会动态的变化。

每当学校下拉框的值变化的时候，就应该触发一个函数，带着当前所选的学校的 id 去获取所有的学院，所以给学校下拉框绑定一个 change 事件：

```vue
<el-select v-model="form.universityId" @change="getAllCollegesByUniId">
    <el-option v-for="u in universityOptions" 
               :key="u.id" :value="u.id" 
               :label="u.name" 
               placeholder="选择学校"></el-option>
</el-select>
```

然后定义一下这个函数，这个函数应该是调用一个 api 文件中的函数：

```js
// 根据学校id获取学院
getAllCollegesByUniId() {
    getAllCollegesByUniversityId(this.form.universityId).then(resp => {
        this.collegeOptions = resp.data;
    })
},
```

这个 getAllCollegesByUniversityId 函数就应该定义在 college 的 api 文件中：

```js
// 根据学校id获取学院
export function getAllCollegesByUniversityId(uniId) {
  return request({
    url: '/college/college/getAllCollegesByUniversityId/' + uniId,
    method: 'get',
  })
}
```

并且将这个函数引入进来：

```js
import { getAllCollegesByUniversityId } from "../../../api/college/college";
```

然后去后端 college 的控制器中，实现这个接口：

```java
/**
     * 通过学校id获取所有学院
     */
@PreAuthorize("@ss.hasPermi('college:college:getAllCollegesByUniversityId')")
@GetMapping(value = "/getAllCollegesByUniversityId/{uniId}")
public AjaxResult getAllCollegesByUniversityId(@PathVariable("uniId") String uniId)
{
    return success(collegeService.getAllCollegesByUniversityId(uniId));
}
```

然后一路添加该方法，最终在 mapper.xml 中：

```xml
<select id="getAllCollegesByUniversityId" resultMap="CollegeResult">
    select * from t_college where uni_id = #{uniId} and deleteed = 0
</select>
```

# 班级管理

使用代码生成器先生成代码，然后拷贝代码，

+ 给 mapper 接口添加 @Repository 注解
+ 给实体类删除继承关系，使用 Lombok 注解，实现 Serializable 接口，定义创建时间属性
+ 给 controller 的添加方法中设置 id、创建时间，修改方法中设置修改时间
+ 修改 mapper.xml 文件中的 sql 代码，实现假删除，查询也是判断假删除
+ 删除前端显示主键的代码，修改显示专业外键的代码
+ 将添加班级时的专业设为下拉框。
+ 将描述部分变为展开行显示

班级是在专业下的，专业在学院下，学院在学校下，所以添加班级时涉及到了 4 张表。查询的时候要知道当前班级属于哪个专业、哪个学院、哪个学校，所以查询语句这样写：

```sql
select z.*, m.name majorName, c.name collegeName, u.name universityName
from t_class z 
left join (select * from t_major where deleted = 0) m
on z.major_id = m.id
left join (select * from t_college where deleteed = 0) c
on m.college_id = c.id
left join (select * from t_university where deleted = 0) u
on c.uni_id = u.id
```

+ 在查询专业、学院、学校的时候也要注意已经被删除过了的数据，之前的sql语句也应该注意这里。

需要注意，这里的前端应该有一个三级联动，选择学校后，会有对应的学院，选择 学院后，会有对应的专业：

```vue
<el-form-item label="学校名称" prop="universityId">
    <el-select v-model="form.universityId" placehodler="选择学校" @change="getAllCollegesByUniId">
        <el-option v-for="u in universityOptions" :key="u.id" :value="u.id" :label="u.name"></el-option>
    </el-select>
</el-form-item>
<el-form-item label="学院名称" prop="collegeId">
    <el-select v-model="form.collegeId" placehodler="选择学院" @change="getAllMajorsByColId">
        <el-option v-for="c in collegeOptions" :key="c.id" :value="c.id" :label="c.name"></el-option>
    </el-select>
</el-form-item>
<el-form-item label="专业名称" prop="majorId">
    <el-select v-model="form.majorId" placehodler="选择专业">
        <el-option v-for="m in majorOptions" :key="m.id" :value="m.id" :label="m.name"></el-option>
    </el-select>
</el-form-item>
```

定义数组：

```js
data() {
    return {
      // 所有学校
      universityOptions: [],
      // 所有学院
      collegeOptions: [],
      // 所有专业
      majorOptions: [],
    }
}
```

引入方法：

```js
import { getAllCollegesByUniversityId } from "../../../api/college/college";
import { getAllUniversities } from "../../../api/employment/university";
import { getAllMajorsByCollegeId } from "../../../api/major/major"
```

定义方法：

```js
methods: {
    // 根据学院id获取专业
    getAllMajorsByColId() {
      getAllMajorsByCollegeId(this.form.collegeId).then(resp => {
        this.majorOptions = resp.data;
      })
    },
    // 根据学校id获取学院
    getAllCollegesByUniId() {
      getAllCollegesByUniversityId(this.form.universityId).then(resp => {
        this.collegeOptions = resp.data;
      })
    },
    // 获取所有的学校
    getAllUniversityOptions() {
      getAllUniversities().then(resp => {
        this.universityOptions = resp.data;
      })
    },
}
```

getAllUniversities 和 getAllCollegesByUniversityId 这两个接口都已经实现了，所以还需要实现一个 getAllMajorsByCollegeId 接口，在 api 下的 major.js 文件中实现：

```js
// 根据学院id获取专业
export function getAllMajorsByCollegeId(collId) {
  return request({
    url: '/major/major/getAllMajorsByCollegeId/' + collId,
    method: 'get',
  })
}
```

最后再在后端写这个接口的实现就可以了，和其它部分的操作一样。

# 学生管理

使用代码生成器先生成代码，然后拷贝代码，

+ 给 mapper 接口添加 @Repository 注解
+ 给实体类删除继承关系，使用 Lombok 注解，实现 Serializable 接口，定义创建时间属性
+ 给 controller 的添加方法中设置 id、创建时间，修改方法中设置修改时间
+ 修改 mapper.xml 文件中的 sql 代码，实现假删除，查询也是判断假删除
+ 删除前端显示主键的代码，修改显示班级外键的代码
+ 将添加学生时的班级设为下拉框。

学生管理在班级的下面，所以查询的时候他比班级还要多一张表。

```sql
select s.*, z.name className, m.name majorName, c.name collegeName, u.name universityName
from t_student s
left join (select * from t_class where deleted = 0) z on s.class_id = z.id
left join (select * from t_major where deleted = 0) m on z.major_id = m.id
left join (select * from t_college where deleteed = 0) c on m.college_id = c.id
left join (select * from t_university where deleted = 0) u on c.uni_id = u.id
```

在新增学生的时候，需要选择学校、学院、专业、班级，这又是一个多级联动下拉框。

同时，新增学生时，条件太多，竖直放置控件的话一个屏幕显示不全，可以使用栅格系统来布局。

```vue
<el-row :gutter="5">
    <el-col :span="12">
        <el-form-item label="学校名称" prop="universityId">
            <el-select v-model="form.universityId" placehodler="选择学校" @change="getAllCollegesByUniId">
                <el-option v-for="u in universityOptions" :key="u.id" :value="u.id" :label="u.name"></el-option>
            </el-select>
        </el-form-item>
    </el-col>
    <el-col :span="12">
        <el-form-item label="学院名称" prop="collegeId">
            <el-select v-model="form.collegeId" placehodler="选择学院" @change="getAllMajorsByColId">
                <el-option v-for="c in collegeOptions" :key="c.id" :value="c.id" :label="c.name"></el-option>
            </el-select>
        </el-form-item>
    </el-col>
</el-row>
<el-row :gutter="5">
    <el-col :span="12">
        <el-form-item label="专业名称" prop="majorId">
            <el-select v-model="form.majorId" placehodler="选择专业" @change="getAllClassesByMajId">
                <el-option v-for="m in majorOptions" :key="m.id" :value="m.id" :label="m.name"></el-option>
            </el-select>
        </el-form-item>
    </el-col>
    <el-col :span="12">
        <el-form-item label="班级名称" prop="classId">
            <el-select v-model="form.classId" placehodler="选择班级" >
                <el-option v-for="c in classOptions" :key="c.id" :value="c.id" :label="c.name"></el-option>
            </el-select>
        </el-form-item>
    </el-col>
</el-row>
```

需要补充一个根据专业 id 来获取班级的方法：

```js
// 根据专业id来获取班级
getAllClassesByMajId() {
    getAllClassesByMajorId(this.form.majorId).then(resp => {
        this.classOptions = resp.data;
    })
},
```

在 api 下的 clazz.js 中实现：

```js
// 根据专业id获取班级
export function getAllClassesByMajorId(majorId) {
  return request({
    url: '/clazz/clazz/getAllClassesByMajorId/' + majorId,
    method: 'get'
  })
}
```

然后剩下的就是在后端创建接口，实现接口。

# 就业管理

使用代码生成器先生成代码，然后拷贝代码，

+ 给 mapper 接口添加 @Repository 注解
+ 给实体类删除继承关系，使用 Lombok 注解，实现 Serializable 接口，定义创建时间属性
+ 给 controller 的添加方法中设置 id、创建时间，修改方法中设置修改时间
+ 修改 mapper.xml 文件中的 sql 代码，实现假删除，查询也是判断假删除
+ 删除前端显示主键的代码，修改显示学生外键的代码

就业信息关系着行业、城市、学生三个表。

```sql
select e.*, s.name studentName, i.name industryName, c.name cityName
from t_employment e
left join (select * from t_student where deleted = 0) s on e.student_id = s.id
left join (select * from t_industry where deleted = 0) i on e.industry_id = i.id
left join (select * from t_city where deleted = 0) c on e.city_id = c.id
```

该模块内容涉及较多，新增就业记录的页面：

```vue
<el-form ref="form" :model="form" :rules="rules" label-width="80px">
    <el-row :gutter="5">
        <el-col :span="12">
            <el-form-item label="学校名称" prop="universityId">
                <el-select v-model="form.universityId" placehodler="选择学校" @change="getAllCollegesByUniId">
                    <el-option v-for="u in universityOptions" :key="u.id" :value="u.id" :label="u.name"></el-option>
                </el-select>
            </el-form-item>
        </el-col>
        <el-col :span="12">
            <el-form-item label="学院名称" prop="collegeId">
                <el-select v-model="form.collegeId" placehodler="选择学院" @change="getAllMajorsByColId">
                    <el-option v-for="c in collegeOptions" :key="c.id" :value="c.id" :label="c.name"></el-option>
                </el-select>
            </el-form-item>
        </el-col>
    </el-row>
    <el-row :gutter="5">
        <el-col :span="12">
            <el-form-item label="专业名称" prop="majorId">
                <el-select v-model="form.majorId" placehodler="选择专业" @change="getAllClassesByMajId">
                    <el-option v-for="m in majorOptions" :key="m.id" :value="m.id" :label="m.name"></el-option>
                </el-select>
            </el-form-item>
        </el-col>
        <el-col :span="12">
            <el-form-item label="班级名称" prop="classId">
                <el-select v-model="form.classId" placehodler="选择班级" @change="getAllStudentsByClass">
                    <el-option v-for="c in classOptions" :key="c.id" :value="c.id" :label="c.name"></el-option>
                </el-select>
            </el-form-item>
        </el-col>
    </el-row>
    <el-row :gutter="5">
        <el-col :span="12">
            <el-form-item label="学生名称" prop="studentId">
                <el-select v-model="form.studentId" placehodler="选择学生" >
                    <el-option v-for="s in studentOptions" :key="s.id" :value="s.id" :label="s.name"></el-option>
                </el-select>
            </el-form-item>
        </el-col>
        <el-col :span="12">
            <el-form-item label="行业名称" prop="industryId">
                <el-select v-model="form.industryId" placehodler="选择行业" >
                    <el-option v-for="i in industryOptions" :key="i.id" :value="i.id" :label="i.name"></el-option>
                </el-select>
            </el-form-item>

        </el-col>
    </el-row>
    <el-row :gutter="5">
        <el-col :span="12">
            <el-form-item label="省份名称" prop="provinceId">
                <el-select v-model="form.provinceId" placehodler="选择省份" @change="getAllCitiesByProId">
                    <el-option v-for="p in provinceOptions" :key="p.id" :value="p.id" :label="p.name"></el-option>
                </el-select>
            </el-form-item>
        </el-col>
        <el-col :span="12">
            <el-form-item label="城市名称" prop="cityId">
                <el-select v-model="form.cityId" placehodler="选择城市" >
                    <el-option v-for="c in cityOptions" :key="c.id" :value="c.id" :label="c.name"></el-option>
                </el-select>
            </el-form-item>
        </el-col>
    </el-row>
    <el-row :gutter="5">
        <el-col :span="12">
            <el-form-item label="企业名称" prop="enterprise">
                <el-input v-model="form.enterprise" placeholder="请输入企业名称" />
            </el-form-item>

        </el-col>
        <el-col :span="12">
            <el-form-item label="企业性质" prop="nature">
                <el-select v-model="form.nature" placeholder="请选择企业性质">
                    <el-option label="国企" value="国企"></el-option>
                    <el-option label="民企" value="民企"></el-option>
                </el-select>
            </el-form-item>

        </el-col>
    </el-row>
    <el-row :gutter="5">
        <el-col :span="12">
            <el-form-item label="就业薪资" prop="money">
                <el-input v-model="form.money" placeholder="请输入就业薪资" />
            </el-form-item>

        </el-col>
        <el-col :span="12">
            <el-form-item label="就业时间" prop="times">
                <el-date-picker
                                placeholder="就业时间" 
                                v-model="form.times"
                                type="date"
                                size="small"
                                />
            </el-form-item>
        </el-col>
    </el-row>
</el-form>
```

![image-20240220171803310](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402201718633.png)

+ 学校、学院、专业、班级、学生五个下拉框是从上到下联动的，前四个下拉框的联动规则已经写过了，还需要实现一个通过班级 id 获取学生的功能。
+ 省份和城市联动，根据省份 id 获取城市。
+ 企业性质下拉框是写死的下拉框，分为国企和民企
+ 就业时间是使用日期选择器

另外，可以看到页面上有些属性的前面是一个小红心，这表示必填字段。

在添加一条数据后，可以看到时间的显示不符合日常生活使用，

![image-20240220173946929](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402201739139.png)

要改成和创建时间一样，也可以在添加数据的时候，手动将这个就业时间的数据截取前十个字符下来，然后保存在数据库，这样拿出来的数据就是这个格式：

```java
/**
     * 新增就业管理
     */
@PreAuthorize("@ss.hasPermi('employment:employment:add')")
@Log(title = "就业管理", businessType = BusinessType.INSERT)
@PostMapping
public AjaxResult add(@RequestBody Employment employment)
{
    employment.setId(UUID.randomUUID().toString());
    employment.setCreateTime(DateUtils.getNowDate());
    employment.setTimes(employment.getTimes().substring(0, 10));  // 截取时间
    return toAjax(employmentService.insertEmployment(employment));
}
```

也可以在前端中，通过格式控制，创建时间的显示就是通过前端代码的限制：

```vue
<el-table-column label="就业时间" align="center" prop="times" >
    <template slot-scope="scope">
		<span>{{ parseTime(scope.row.times, '{y}-{m}-{d}') }}</span>
    </template>
</el-table-column>
```

+ `parseTime` 方法的作用是将时间数据进行格式化，将其转换为指定格式的字符串。其中 `{y}` 代表年份，`{m}` 代表月份，`{d}` 代表日期。

还有就业状态的显示，应该显示已就业：

```vue
<el-table-column label="就业状态" align="center" prop="status" >
    <template v-slot="scope">
		<el-tag type="success" v-if="scope.row.status==0">
    		已就业
        </el-tag>
    </template>
</el-table-column>
```

+ 这里出现了 `v-slot` 和 `slot-scope`，这两者作用相似，但是 `v-slot` 是 Vue3 中提供的，更加清晰地指定具名插槽的名称，并且可以直接在插槽标签上使用。可以取代 `slot-scope`。

![image-20240220175300463](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402201753672.png)

# 表单验证

当没有填必填字段的时候，点击确定按钮，会提示你错误信息：

![image-20240220172345134](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402201723337.png)

这些错误信息是从哪里来的？以学生名称为例：

```vue
<el-form-item label="学生名称" prop="studentId">
    <el-select v-model="form.studentId" placehodler="选择学生" >
        <el-option v-for="s in studentOptions" :key="s.id" :value="s.id" :label="s.name"></el-option>
    </el-select>
</el-form-item>
```

有一个 prop 属性，表单验证就是通过这个 prop 属性来进行的，这个属性验证是在这里定义的：

```js
// 表单校验
rules: {
  industryId: [
    { required: true, message: "行业外键不能为空", trigger: "blur" }
  ],
  studentId: [
    { required: true, message: "学生外键不能为空", trigger: "blur" }
  ],
  cityId: [
    { required: true, message: "城市外键不能为空", trigger: "blur" }
  ],
  enterprise: [
    { required: true, message: "企业名称不能为空", trigger: "blur" }
  ],
  nature: [
    { required: true, message: "企业性质不能为空", trigger: "blur" }
  ],
  money: [
    { required: true, message: "就业薪资不能为空", trigger: "blur" }
  ],
  status: [
    { required: true, message: "就业状态不能为空", trigger: "change" }
  ],
  times: [
    { required: true, message: "就业时间不能为空", trigger: "blur" }
  ],
  createTime: [
    { required: true, message: "创建时间不能为空", trigger: "blur" }
  ],
  modifyTime: [
    { required: true, message: "修改时间不能为空", trigger: "blur" }
  ],
}
```

+ required：必填
+ message：错误消息
+ trigger：触发方式

可以看到学生名称的 prop 属性 studentId 就定义在这个 rules 中，说明如果标签上有定义在 rules 中的属性的话，那么这个标签就会执行对应的验证。

所以如果想要哪个字段需要必填验证，可以自己定义在 rules 中定义一个变量，然后使用在目标对象的 prop 属性上。

# 首页设置

## 布局

首先给首页布局：

![image-20240220175732123](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402201757359.png)

还是使用 vue 的栅格系统来布局。在 views 下的 index.vue 中进行首页的修改。

将首页所有的内容都放在一个卡片中，按照上面划分的布局，首先确定第一行的元素：

```vue
<template>
<!-- 这是最外层的根元素 -->
<el-card>
    <!-- 这是第一行 -->
    <el-row>
        <el-col :span="8">
            <el-card>
                总毕业人数：2000
            </el-card>
        </el-col>
        <el-col :span="8">
            <el-card>
                总就业人数：2000
            </el-card>
        </el-col>
        <el-col :span="8">
            <el-card>
                未就业人数：2000
            </el-card>
        </el-col>
    </el-row>
</el-card>
</template>
<style scoped>
.el-card {
  margin: 5px;
}
</style>
```

+ 注意：在 template 中只能有一个根元素，所以所有的东西都是写在最外层的卡片中的
+ 注意：这个样式是通过类名选择器来的，因为 Element UI 组件库设计时采用了基于类名的样式封装方法，.el-card 就是 el-card 的类名。

这是第一行的效果：

![image-20240220181300376](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402201813587.png)

第二行：

```vue
<el-row>
    <el-col :span="6">
        <el-card>就业企业性质-柱状图</el-card>
    </el-col>
    <el-col :span="12">
        <el-card>中国地图</el-card>
    </el-col>
    <el-col :span="6">
        <el-card>就业所在城市男女比例</el-card>
    </el-col>
</el-row>
```

此时效果：

![image-20240220182047213](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402201820430.png)

## 统计企业属性

在后端项目中新建一个业务包 bo（business objects），主要用来进行数据分析统计，在里面建一个业务类 BusinessBo：

```java
/**
 * 业务类，根据页面业务不同设置不同属性，查询数据、封装的类
 * Author : ZSM
 * Time :  2024/02/20
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BusinessBo {
}
```

然后分析数据库中的数据，比如就业记录中民企和国企的数量：

```sql
select nature name, count(nature) value 
from t_employment
where deleted = 0
group by nature
```

这个 sql 语句会返回两列数据，第一列就是名称（国企或民企），第二列是对应的数量，所以可以在 BusinessBo 类中添加两个属性 name 和 vlaue，用来对应这两列：

```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class BusinessBo {
    private String name;
    private String value;
}
```

然后将上面的 sql 语句封装成一个方法，封装在就业管理的 mapper 接口中：

```java
/**
     * 获取学生就业的企业中国企的数量和民企的数量
     * @return 国企的数量和民企的数量
     */
List<BusinessBo> getNatureCount();
```

再在 mapper.xml 中写 sql 语句：

```xml
<select id="getNatureCount" resultMap="com.ruoyi.employment.bo.BusinessBo">
    select nature name, count(nature) value
    from t_employment
    where deleted = 0
    group by nature
</select>
```

然后还要在业务层中、控制器中写，因为这个方法也是会从前端请求过来，所以顺序是一样的：

IEmploymentService.java：

```java
/**
     * 获取学生就业的企业中国企的数量和民企的数量
     * @return 国企的数量和民企的数量
     */
List<BusinessBo> getNatureCount();
```

EmploymentServiceImpl.java：

```java
/**
     * 获取学生就业的企业中国企的数量和民企的数量
     * @return 国企的数量和民企的数量
     */
@Override
public List<BusinessBo> getNatureCount(){
    return employmentMapper.getNatureCount();
}
```

EmploymentController.java：

```java
/**
     * 获取学生就业的企业中国企的数量和民企的数量
     */
@PreAuthorize("@ss.hasPermi('employment:employment:getNatureCount')")
@GetMapping(value = "/getNatureCount")
public AjaxResult getNatureCount()
{
    return success(employmentService.getNatureCount());
}
```

然后在前端的 api 下的 employment.js 中：

```js
// 获取学生就业的企业中国企的数量和民企的数量
export function getNatureCount() {
  return request({
    url: '/employment/employment/getNatureCount',
    method: 'get',
  })
}
```

然后将这个方法引入到首页中：

```js
import { getNatureCount } from '../api/employment/employment';
```

在首页中定义一个方法，用来显示图表：

```js
methods: {
    // 显示企业性质柱状图
    showNatureCount() {

    },
}
```

然后使用 echarts。

## 使用echarts

要在首页中进行数据分析的展示，会插入一些饼状图和折线图之类的图形，就会用到一个工具 echarts，[ecahrts官网](https://echarts.apache.org/zh/index.html)。

先安装 echarts，在当前项目下：

```bash
npm install echarts
```

这样就安装成功：

```bash
[##################] / reify:nan: timing reifyNode:node_modules/bindings Completed in 1549ms
```

可以在 package.json 中查看到这样的代码：

![image-20240220182437064](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402201824281.png)

然后在 main.js 中引入 echarts：

```js
// 引入 echarts
import * as echarts from 'echarts'
```

然后将 echarts 变成 Vue 对象的一个全局变量，这样可以通过 this 去访问：

```js
// 全局方法挂载
Vue.prototype.$echarts = echarts
```

+ 这个 $echarts 就是一个别名了

### 概述

可以在官网的示例中找到一个例子，将代码拷贝下来，比如：

```js
// 基于准备好的dom，初始化echarts实例
var myChart = echarts.init(document.getElementById('main'));

// 指定图表的配置项和数据
var option = {
    title: {
        text: 'ECharts 入门示例'
    },
    tooltip: {},
    legend: {
        data: ['销量']
    },
    xAxis: {
        data: ['衬衫', '羊毛衫', '雪纺衫', '裤子', '高跟鞋', '袜子']
    },
    yAxis: {},
    series: [
        {
            name: '销量',
            type: 'bar',
            data: [5, 20, 36, 10, 10, 20]
        }
    ]
};

// 使用刚指定的配置项和数据显示图表。
myChart.setOption(option);
```

+ title:text：柱状图的标题
+ legend:data：当鼠标放上柱子时，显示的内容
+ xAxis：x轴
  + data：x轴的值
+ yAxis：y轴
+ series
  + data：实际数据
  + type: bar：表示柱状图
  + name：显示在柱状图的上方的标识

这就是以上柱状图的效果：

![image-20240220224714614](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402202247827.png)

### 使用

先初始化一个 echarts 对象，初始化的时候，传入一个有宽高的节点：

```js
let natureCountEcahrt = this.$echarts.init(document.querySelector("#natureCountField"));
```

+ 这个 natureCountField 是显示该柱状图的元素的 id

+ 需要注意的是，使用这种方法在调用 `echarts.init` 时需保证容器已经有宽度和高度了。

+ 如果图表容器不存在宽度和高度，或者，你希望图表宽度和高度不等于容器大小，也可以在初始化的时候指定大小。

  ```js
  let natureCountEcahrt = this.$echarts.init(document.querySelector("#natureCountField"), null, {
      width: 600,
      height: 400
  });
  ```

然后使用 setOption() 函数：

```js
natureCountEcahrt.setOption(optionObj)
```

+ 这个 optionObj 对象是用来设置柱状图的配置项和数据的

然后调用 getNatureCount 函数，获取到数据，并将数据封装成两个数组，一个用于 x 轴，一个用于值，然后调用 showNatureCount 函数：

```js
methods: {
        // 显示企业性质柱状图
        showNatureCount(optionObj) {
            let natureCountEcahrt = this.$echarts.init(document.querySelector("#natureCountField"));
            natureCountEcahrt.setOption(optionObj);
        },
        // 获取数据，并调用显示
        getNaturesCount() {
            getNatureCount().then(resp => {
                // 将数据装成两个数组
                let names = [];
                let values = [];
                for (let item of resp.data) {
                    names.push(item.name);
                    values.push(item.value);
                }
                // 创建option对象
                let optionObj = {
                    title: {
                        text: '高校就业企业属性统计'
                    },
                    tooltip: {},
                    legend: {
                        data: ['民企', '国企']
                    },
                    xAxis: {
                        data: names,
                    },
                    yAxis: {},
                    series: [
                        {
                            name: '企业数量',
                            type: 'bar',
                            data: values,
                        }
                    ]
                };
                // 调用显示图表函数
                this.showNatureCount(optionObj);
            })
        },
}
```

然后记得在 created 中调用函数：

```js
created() {
    this.getNaturesCount();
},
```

### 问题

在初始使用 natureCountEcahrt.setOption(optionObj); 的时候遇到了一个问题，就是不管怎么写，都会报错：

```js
Error Initialize failed invalid dom
```

其实这是因为我在 created 中调用了 showNatureCount 函数，但是此时的 echarts 并没有被挂载，所以可以使用 setTimeout 延迟调用 showNatureCount  函数，或者就像上面那样调用函数，再或者将调用函数的写法写在 mounted 中，而不是 created 中。

```js
mounted() {
    this.showNatureCount();
},
```

现在的效果：

![image-20240220231057508](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402202310691.png)

## 显示地图

如何使用 echarts 显示一个中国地图？

+ 准备地图容器：就是写一个 `div` 用来显示地图的

  ```vue'
  <div id="chinaMapField" style="width: auto; height: 400px;"></div>
  ```

+ 准备地图数据：在 echarts 的 [Github仓库](https://github.com/apache/echarts/blob/master/test/data/map/json/china.json) 下载一个 china.json 文件，这是中国地图数据，并将这个文件放在自己的项目中，然后引入需要的地方。

  ```js
  import 'echarts/lib/chart/map';  // 内置的地图
  import chinaJson from '../china.json'  // 地图数据
  ```

+ 注册地图数据：在ECharts中注册地图数据。

  ```js
  this.$echarts.registerMap('china', chinaJson);
  ```

+ 创建并配置 ECharts 实例：

  ```js
  let chinaMapEchart = this.$echarts.init(document.querySelector("#chinaMapField"));
  chinaMapEchart.setOption(chianMapOptionObj)
  ```

这有一个地图示例：

```js
let chianMapOption = {
    // 设置标题
    title: {
        text: '中国地图示例'
    },
    // 设置提示框
    tooltip: {
        trigger: 'item',
        formatter: '{b}'  // 提示框显示的内容
    },
    // 设置地图系列
    series: [
        {
            name: '中国', // 系列名称
            type: 'map', // 系列类型，地图
            mapType: 'china', // 地图类型，中国地图
            roam: true, // 是否开启鼠标缩放和平移漫游
            label: {
                normal: {
                    show: true // 是否显示标签文本
                },
                emphasis: {
                    show: true // 高亮时是否显示标签文本
                }
            },
            itemStyle: {
                emphasis: {
                    areaColor: '#F3B329' // 高亮时区域颜色
                }
            },
            data: [ // 地图数据，以数组形式提供各个区域的名称和值
                { name: '北京', value: Math.random() * 1000 }, // 示例数据，可以根据实际情况修改
                { name: '天津', value: Math.random() * 1000 },
                { name: '上海', value: Math.random() * 1000 },
                { name: '重庆', value: Math.random() * 1000 },
                { name: '河北', value: Math.random() * 1000 },
                { name: '河南', value: Math.random() * 1000 },
                { name: '云南', value: Math.random() * 1000 },
                { name: '辽宁', value: Math.random() * 1000 },
                { name: '黑龙江', value: Math.random() * 1000 },
                { name: '湖南', value: Math.random() * 1000 },
                { name: '安徽', value: Math.random() * 1000 },
                { name: '山东', value: Math.random() * 1000 },
                { name: '新疆', value: Math.random() * 1000 },
                { name: '江苏', value: Math.random() * 1000 },
                { name: '浙江', value: Math.random() * 1000 },
                { name: '江西', value: Math.random() * 1000 },
                { name: '湖北', value: Math.random() * 1000 },
                { name: '广西', value: Math.random() * 1000 },
                { name: '甘肃', value: Math.random() * 1000 },
                { name: '山西', value: Math.random() * 1000 },
                { name: '内蒙古', value: Math.random() * 1000 },
                { name: '陕西', value: Math.random() * 1000 },
                { name: '吉林', value: Math.random() * 1000 },
                { name: '福建', value: Math.random() * 1000 },
                { name: '贵州', value: Math.random() * 1000 },
                { name: '广东', value: Math.random() * 1000 },
                { name: '青海', value: Math.random() * 1000 },
                { name: '西藏', value: Math.random() * 1000 },
                { name: '四川', value: Math.random() * 1000 },
                { name: '宁夏', value: Math.random() * 1000 },
                { name: '海南', value: Math.random() * 1000 },
                { name: '台湾', value: Math.random() * 1000 },
                { name: '香港', value: Math.random() * 1000 },
                { name: '澳门', value: Math.random() * 1000 }
            ]
        }
    ]
}
```

这样使用：
```js
// 显示中国地图
showChinaMap() {
    let chinaMapEchart = this.$echarts.init(document.querySelector("#chinaMapField"));
    this.$echarts.registerMap('china', chinaJson);
    chinaMapEchart.setOption(chianMapOption)
},
```

效果：

![image-20240221001613487](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402210016680.png)

## 统计就业人数分布

统计就业的人在全国的分布，显示一个中国地图。

首先要获取到各个城市的就业人数，

sql 语句：

```xml
<select id="getCityEmploymentCount" resultType="com.ruoyi.employment.bo.BusinessBo">
    select p.name name, count(e.student_id) value
    from t_employment e
    left join (select * from t_city where deleted = 0) c on e.city_id = c.id
    left join (select * from t_province where deleted = 0) p on c.province_id = p.id
    where e.deleted = 0
    GROUP BY name
</select>
```

+ 将省份名称作为 BusinessBo 对象的 name，人数作为 value

然后实现后端的方法，再在前端中进行调用。

将地图的配置信息定义在 data 中：

```js
data() {
    let chinaMapOption = {
      // 设置标题
      title: {
        text: '中国地图示例'
      },
      // 设置提示框
      tooltip: {
        trigger: 'item',
        formatter: '{b}: {c}人'  // 提示框显示的内容，{b} 表示省份名称，{c} 表示数据值
      },
      // 设置地图系列
      series: [
        {
          name: '中国', // 系列名称
          type: 'map', // 系列类型，地图
          mapType: 'china', // 地图类型，中国地图
          roam: true, // 是否开启鼠标缩放和平移漫游
          label: {
            normal: {
              show: true // 是否显示标签文本
            },
            emphasis: {
              show: true // 高亮时是否显示标签文本
            }
          },
          itemStyle: {
            normal: {
              areaColor: '#ccc', // 普通状态下区域颜色
              borderColor: '#fff' // 边框颜色
            },
            emphasis: {
              areaColor: '#F3B329' // 高亮时区域颜色
            }
          },
          data: []  // 这里是数据
        }
      ]
    };
    return {
        chianMapOption,
    };
}
```

+ tooltip 的 formatter 参数支持使用特定的占位符来表示数据，其中 `{b}` 表示数据项的名称，`{c}` 表示数据项的值。
  + `{a}`：系列名。
  + `{b}`：数据项名称。
  + `{c}`：数值（如果是饼图、雷达图等可以显示数值的图表）。
  + `{d}`：百分比（仅适用于饼图）。
  + `{e}`：事件分发目标的参数数组。
  + `{f}`：坐标轴的格式化文本。
  + `{g}`：用于文本样式的文本。

再调用方法：

```js
// 统计每个城市的人数
getEmploymentCount() {
    getCityEmploymentCount().then(resp => {
        this.chinaMapOption.series[0].data = resp.data;
        this.showChinaMap();
    })
},
// 显示中国地图
showChinaMap() {
    let chinaMapEchart = this.$echarts.init(document.querySelector("#chinaMapField"));
    this.$echarts.registerMap('china', chinaJson);
    chinaMapEchart.setOption(this.chinaMapOption)
},
```

如果想要地图上的区域根据对应的就业人数来显示颜色的话，可以这样写：

```js
let chinaMapOption = {
    // 设置标题
    title: {
        text: '中国地图示例'
    },
    // 设置提示框
    tooltip: {
        trigger: 'item',
        formatter: '{b}: {c}人'  // 提示框显示的内容，{b} 表示省份名称，{c} 表示数据值
    },
    // 设置地图系列
    series: [
        {
            name: '中国', // 系列名称
            type: 'map', // 系列类型，地图
            mapType: 'china', // 地图类型，中国地图
            roam: true, // 是否开启鼠标缩放和平移漫游
            label: {
                normal: {
                    show: true // 是否显示标签文本
                },
                emphasis: {
                    show: true // 高亮时是否显示标签文本
                }
            },
            itemStyle: {
                normal: {
                    areaColor: '#ccc', // 普通状态下区域颜色
                    borderColor: '#fff' // 边框颜色
                },
                emphasis: {
                    areaColor: '#F3B329' // 高亮时区域颜色
                }
            },
            data: []  // 这里是数据
        }
    ],
    visualMap: {
        min: 0,
        max: 500, // 数据中的最大值
        calculable: true,
        inRange: {
            color: ['#FFD700', '#FF0000'] // 浅黄到红色渐变
        }
    }
};
```

现在的效果：

![image-20240221012057194](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402210120422.png)

## 统计就业男女人数

```sql
select s.sex name, count(e.student_id) value
from t_employment e 
left join (select * from t_student where deleted = 0) s on e.student_id = s.id
where e.deleted = 0
group by s.sex
```

然后实现后端接口，在 EmploymentController 中

```java
/**
     *  统计就业男女人数
     */
@PreAuthorize("@ss.hasPermi('employment:employment:getEmploymentCountWithSex')")
@GetMapping(value = "/getEmploymentCountWithSex")
public AjaxResult getEmploymentCountWithSex()
{
    return success(employmentService.getEmploymentCountWithSex());
}
```

实现前端调用，在 api 下employment.js 中：

```js
// 获取就业男女人数
export function getEmploymentCountWithSex() {
  return request({
    url: '/employment/employment/getEmploymentCountWithSex',
    method: 'get',
  })
}
```

然后就可以在主页获取男女人数的数据，然后还是使用一个柱状图来展示，直接将上一个柱状图复制过来：

```js
//  统计就业男女人数
getEmploymentCountBySex() {
    getEmploymentCountWithSex().then(resp => {
        let names = [];
        let values = [];
        for (let item of resp.data) {
            names.push(item.name);
            values.push(item.value);
        }
        let optionObj = {
            title: {
                text: '高校就业男女人数统计'
            },
            tooltip: {},
            legend: {
                data: ['男', '女', '保密']
            },
            xAxis: {
                data: names,
            },
            yAxis: {},
            series: [
                {
                    name: '就业人数',
                    type: 'bar',
                    data: values,
                }
            ]
        };
        this.showEmploymentCountWithSex(optionObj);
    })
},
// 显示就业男女人数折线图
showEmploymentCountWithSex(optionObj) {
    let employmentSexEchart = this.$echarts.init(document.querySelector("#employmentCountField"));
    employmentSexEchart.setOption(optionObj);
},
```

这是现在的效果：

![image-20240221100222377](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211002572.png)

## 统计不同学院就业人数

```sql
select coll.name name, count(e.student_id) value
from t_employment e 
left join (select * from t_student where deleted = 0) s on e.student_id = s.id
left join (select * from t_class where deleted = 0) c on s.class_id = c.id
left join (select * from t_major where deleted = 0) m on c.major_id = m.id
left join (select * from t_college where deleteed = 0) coll on m.college_id = coll.id
where e.deleted = 0
group by name
```

然后实现后端的接口，在 EmploymentController 中：

```java
/**
     *  统计不同学院就业人数
     */
@PreAuthorize("@ss.hasPermi('employment:employment:getEmploymentCountWithCollege')")
@GetMapping(value = "/getEmploymentCountWithCollege")
public AjaxResult getEmploymentCountWithCollege()
{
    return success(employmentService.getEmploymentCountWithCollege());
}
```

然后在前端 api 下 employment.js 中调用：

```js
// 统计不同学院就业人数
export function getEmploymentCountWithCollege() {
  return request({
    url: '/employment/employment/getEmploymentCountWithCollege',
    method: 'get',
  })
}
```

然后在首页使用柱状图显示：

```js
// 统计不同学院就业人数
getEmploymentCountByCollege() {
    getEmploymentCountWithCollege().then(resp => {
        let names = [];
        let values = [];
        for (let item of resp.data) {
            names.push(item.name);
            values.push(item.value);
        }
        let optionObj = {
            title: {
                text: '不同学院就业人数统计'
            },
            tooltip: {},
            legend: {
                data: []
            },
            xAxis: {
                data: names,
            },
            yAxis: {},
            series: [
                {
                    name: '就业人数',
                    type: 'bar',
                    data: values,
                }
            ]
        };
        this.showEmploymentCountWithCollege(optionObj);
    })
},
// 显示不同学院就业人数图
showEmploymentCountWithCollege(optionObj) {
    let employmentCollegeEchart = this.$echarts.init(document.querySelector("#employmentCountCollegeField"));
    employmentCollegeEchart.setOption(optionObj);
},
```

现在效果：

![image-20240221102403972](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211024122.png)

## 统计历年已就业人数

```sql
select year(times) name, count(student_id) value
from t_employment
where deleted = 0
group by name
```

+ year 函数可以将字符串转为年份

后端实现接口、前端实现调用，然后使用图展示出来：

```js
// 统计历年已就业人数
getEmploymentCountByTimes() {
    getEmploymentCountWithTimes().then(resp => {
        let names = [];
        let values = [];
        for (let item of resp.data) {
            names.unshift(item.name);
            values.unshift(item.value);
        }
        let optionObj = {
            title: {
                text: '历年就业人数统计'
            },
            tooltip: {},
            legend: {
                data: []
            },
            xAxis: {
                data: names,
            },
            yAxis: {},
            series: [
                {
                    name: '就业人数',
                    type: 'line',
                    data: values,
                }
            ]
        };
        this.showEmploymentCountWithTimes(optionObj);
    });
},
// 显示历年已就业人数
showEmploymentCountWithTimes(optionObj) {
    let employmentTimesEchart = this.$echarts.init(document.querySelector("#employmentCountTimesField"));
    employmentTimesEchart.setOption(optionObj);
},
```

然后发现这个 optionObj 其实是在重复写代码，所以可以定义一份在 data 中，作为全局变量使用，然后每次请求后给指定的属性赋值显示即可：

```js
data() {
    let chinaMapOption = {
        //。。。
    };
    let optionObj = {
        title: {
            text: ''
        },
        tooltip: {},
        legend: {
            data: []
        },
        xAxis: {
            data: [],
        },
        yAxis: {},
        series: [
            {
                name: '',
                type: 'line',
                data: [],
            }
        ]
    };
    return {
        chinaMapOption,
        optionObj
    };
},
```

```js
// 统计历年已就业人数
getEmploymentCountByTimes() {
    getEmploymentCountWithTimes().then(resp => {
        let names = [];
        let values = [];
        for (let item of resp.data) {
            names.unshift(item.name);
            values.unshift(item.value);
        }
        this.optionObj.series[0].type = 'line';
        this.optionObj.series[0].name = '就业人数';
        this.optionObj.series[0].data = values;
        this.optionObj.xAxis.data = names;
        this.optionObj.title.text = '历年就业人数统计';
        this.showEmploymentCountWithTimes(this.optionObj);
    });
},
// 显示历年已就业人数
showEmploymentCountWithTimes(optionObj) {
    let employmentTimesEchart = this.$echarts.init(document.querySelector("#employmentCountTimesField"));
    employmentTimesEchart.setOption(optionObj);
},
```

现在效果：

![image-20240221104616718](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211046882.png)

## 统计不同行业从业人数平均薪资

```sql
select i.name name, avg(e.money) value
from t_employment e 
left join (select * from t_industry where deleted = 0) i on e.industry_id = i.id
where e.deleted = 0
group by name
```

实现接口，调用方法，前台显示。

这次使用一个饼状图来显示，直接从 echarts 官网的示例中复制一份饼状图的配置就可以了：

```js
data() {
    // let chinaMapOption = ...
	// let optionObj = ...
    let pieOptionObj = {
      title: {
        text: '',
      },
      tooltip: {
        trigger: 'item'
      },
      legend: {
        top: '5%',
        left: 'center'
      },
      series: [
        {
          name: '',
          type: 'pie',
          radius: ['40%', '70%'],
          avoidLabelOverlap: false,
          itemStyle: {
            borderRadius: 10,
            borderColor: '#fff',
            borderWidth: 2
          },
          label: {
            show: false,
            position: 'center'
          },
          emphasis: {
            label: {
              show: true,
              fontSize: 30,
              fontWeight: 'bold'
            }
          },
          labelLine: {
            show: false
          },
          data: [
              // data 的格式一定是：一个对象中，包含name和value两个属性
            { value: 1048, name: 'Search Engine' },
          ]
        }
      ]
    }
    return {
      chinaMapOption,
      optionObj,
      pieOptionObj
    };
}
```

使用：

```js
// 统计不同行业从业人数平均薪资
getAvgSalaryByIndustry() {
    getAvgSalaryWithIndustry().then(resp => {
        this.pieOptionObj.title.text = '统计不同行业从业人数平均薪资';
        this.pieOptionObj.series[0].data = resp.data;
        this.showAvgSalary(this.pieOptionObj);
    })
},
// 显示平均薪资
showAvgSalary(optionObj) {
    let avgSalaryEchart = this.$echarts.init(document.querySelector("#avgSalaryField"));
    avgSalaryEchart.setOption(optionObj);
},
```

效果：

![image-20240221111341678](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211113878.png)

## 统计不同学历从业人数平均薪资

```sql
select s.education name, avg(e.money) value
from t_employment e 
left join (select * from t_student where deleted = 0) s on e.student_id = s.id
where e.deleted = 0
group by name
```

实现接口，调用方法，前台显示。同样使用饼图：

![image-20240221112206966](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211122151.png)

# 角色权限

学会使用若依中自带的角色权限。

第一个角色就是超级管理员角色，我们当前的用户角色就是超级管理员。

## 创建角色

创建一个院长角色：在系统管理中的角色管理中

![image-20240221113340546](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211133708.png)

+ 权限字符是后端控制器中方法上面的代码比如：

  ```java
  @PreAuthorize("@ss.hasPermi('employment:employment:getAvgSalaryWithEducation')")
  ```

  但是可以随便写，也可以写汉字。

+ 在菜单权限中，指定院长这个角色可以看哪些菜单，可以对菜单有什么样的权限。

设置好了之后，就可以将这个角色分配给用户：

![image-20240221113905892](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211139041.png)

然后点过去会显示当前这个角色下的所有用户，可以点击左上角添加用户（这个只是添加该角色下的用户，不是新增用户，新增用户在系统管理中的用户管理中）：

![image-20240221114050081](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211140238.png)

然后勾选要分配角色的用户：

![image-20240221114118796](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211141983.png)

然后就可以看到当前角色下的所有用户：

![image-20240221114145083](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211141234.png)

现在使用 嬴政 这个账号进行登录，查看页面：

![image-20240221114321299](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211143490.png)

+ 此时首页就没有显示出来，因为首页的显示都是我们自定义的方法，这些方法并没有给这个角色复权，所以他看不见。
+ 只要是我们自己写的方法，如果没有配置，这个用户角色是没有权限访问的

左边的菜单就只有数据管理了。

## 分配自己定义的方法权限

我们在专业管理里面如果想新增一个专业的话，会拿不到学校的数据，因为获取学校数据的方法是我们自己实现的，所以他没有权限：

![image-20240221114557774](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211145975.png)

在后端的控制器中，自动生成的方法每一个上都带有了一个权限字符串：

```java
@PreAuthorize("@ss.hasPermi('employment:university:getAllUniversities')")
```

这些权限字符串在数据库中的 sys_menu 表中有的：

![image-20240221114956103](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211149280.png)

+ 这个 perms 数据对应着控制器中方法上的权限字符串

但是我们自己写的权限字符串，是在数据库中没有数据的，所以访问不到。

那么如何将自己写的方法的权限分配下去呢？在系统管理的菜单管理中，选择新增菜单：

![image-20240221120808197](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211208365.png)

+ 这个权限字符就是数据库中存的权限，所以将我们自己写的权限字符串写过来就好了。
+ 权限字符的值是：`@PreAuthorize("@ss.hasPermi('employment:employment:getAvgSalaryWithEducation')")` 中的 `employment:employment:getAvgSalaryWithEducation`

然后要记得将这个按钮权限赋权给角色，这样角色就能使用这个方法：

![image-20240221120637976](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211206143.png)

现在就能看到：

![image-20240221120950390](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211209593.png)

所以只需要记住，我们自己写的方法，要在菜单配置中配置，然后才可以分配给角色。

权限字符串：菜单的权限字符串要和后端的方法上的权限字符串一样，菜单的权限字符串就是数据库中的权限字符串。

# 部署

[参考链接](https://blog.csdn.net/lxyoucan/article/details/123951424)

## 项目打包

后端：通过 maven 打包：

![image-20240221130250437](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211302603.png)

可以在控制台中看到生成的每个 jar 包的位置，比如：D:\MyCode\RuoYi\RuoYi-Vue-master\ruoyi-admin\target\ruoyi-admin.jar

前端：在项目的主目录中执行：

```bash
npm run build:prod
```

然后报错：

![image-20240221161649894](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211616112.png)

出现这个错误是因为 node.js 高版本中最近发布的OpenSSL3.0, 而OpenSSL3.0对允许算法和密钥大小增加了严格的限制，可能会对生态系统造成一些影响。解决办法，[参考链接](https://blog.csdn.net/zjjxxh/article/details/127173968)：

+ 方法一（有效）：在终端中使用命令：

  ```bash
  set NODE_OPTIONS=--openssl-legacy-provider
  ```

  `--openssl-legacy-provider` 是一个 Node.js 提供的选项，用于指定在使用旧版 OpenSSL 库时采用的加密提供者。在某些情况下，新版的 OpenSSL 库可能不兼容旧版的加密算法，这时可以通过设置 `NODE_OPTIONS` 环境变量来强制使用旧版 OpenSSL 库以解决兼容性问题。

  执行这个命令后，环境变量 `NODE_OPTIONS` 将会在当前终端会话中生效，Node.js 在运行时会使用这个选项来指定加密提供者。请注意，这个设置只会在当前终端会话中生效，关闭终端后将会失效。

+ 方法二（未测试）：放弃高版本 node，退回 16 版本。

+ 方法三（未测试）：package.json增加配置

  ```json
  "scripts": {
      "serve": "set NODE_OPTIONS=--openssl-legacy-provider && vue-cli-service serve",
      "build": "vue-cli-service build"
  },
  ```

打包成功：

![image-20240221163349712](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211633864.png)

执行完后会在`dist`目录生成相关的打包好的文件。

## 服务器部署

在服务器端新建一个文件 ruoyi，用来放这次的若依项目。

在 ruoyi 下新建一个文件夹 ruoyi-ui，将前端打包生成的 dist 文件夹中的所有文件，都上传到这个文件夹下。

在 ruoyi 下新建一个文件夹 ruoyi-admin，将后端打包生成的 ruoyi-admin.jar 包传到这个文件夹下。

## 安装JDK

然后需要安装 jdk。

[参考链接](https://timberkito.com/?p=12)

### 方法1

查看云端yum库中目前支持安装的jdk软件包

```bash
yum search java|grep jdk
```

![image-20240221165054440](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211650622.png)

选择版本安装jdk。这里装 1.8 的，因为这个项目使用 JDK8 编译的。

```bash
 yum install -y java-1.8.0-openjdk*
```

这是安装成功：

![image-20240221165227329](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211652518.png)

验证是否安装成功：

```bash
java -version
```

![image-20240221165400049](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211654185.png)

查找 jdk 安装位置：

> 默认安装路径一般为：
> /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.151-5.b12.el7_4.x86_64/jre/bin/java

```bash
find / -name 'java'
```

![image-20240221165513136](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211655308.png)

### 方法2

```bash
 mkdir /usr/java21
 cd /usr/java21
 
 wget https://download.oracle.com/java/21/latest/jdk-21_linux-x64_bin.tar.gz
 tar zxvf jdk-21_linux-x64_bin.tar.gz
 
 vim /etc/profile
```

在文件的末尾处添加以下代码：

```bash
export JAVA_HOME=/usr/java21/jdk-21.0.2
export PATH=$JAVA_HOME/bin:$PATH
export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar
```

![image-20240222224103734](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402222241598.png)

```bash
source /etc/profile
java -version
```





## 运行后端

安装好了 jdk 后，去 ruoyi-admin.jar 包所在的路径，启动我们的 ruoyi-admin.jar 包：

```bash
nohup java -jar ruoyi-admin.jar &
```

+ &：在命令后面加上 `&` 符号可以让命令在后台运行。
+ nohup 可以使命令在后台运行，并且不受终端关闭的影响。

报错：

![image-20240221170323085](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211703773.png)

这是因为服务器上没有若依的数据库，所以先将数据库拷贝一份过去，将 ry-vue 数据库转储为 sql 文件，然后将这个 sql 文件传到服务器中，并在 mysql 中新建一个数据库也叫 ry_vue，然后使用这个 sql 文件。如果想更换数据库的连接信息的话，需要更改 jar 包中的 BOOT-INF 下 classes 下的 application-druid.yml 文件中的信息。

注意，如果直接将整个数据库转为 sql 文件再导入的话，可能只能导入几张表（不知道为啥），所以最好还是将手动将所有的表，都一起转储为 sql 文件，传到服务器，导入,这样数据就是全的了。

数据库配好了后，再运行又报错：

![image-20240221183843989](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211838161.png)

这是因为要运行 Redis

## 运行 Redis

[参考链接](https://juejin.cn/post/7012898467643621412)

先安装 Redis：

先获取redis资源

```bash
wget https://github.com/redis/redis/archive/7.2.4.tar.gz
```

然后解压：

```bash
tar xzvf 7.2.4.tar.gz
```

解压后，当前目录下有一个文件夹：

![image-20240221192525936](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402211925089.png)

进入这个文件夹进行安装：

```bash
cd redis-7.2.4/
make
cd src 
make install PREFIX=/usr/local/redis
```

先在就可以直接运行 redis 了

```bash
/usr/local/redis/bin/redis-server
```

这时候再去运行 ruoyi-admin.jar 就可以正常运行了。以下是 Redis 的其他配置。

移动配置文件到安装目录下：

```bash
cd ../
mkdir /usr/local/redis/etc
mv redis.conf /usr/local/redis/etc
```

现在开启redis：

```bash
/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf 
```

在执行开启命令的时候，可能遇到以下异常：

![image-20240222003439481](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402220034927.png)

+ 这个警告是关于内存过度提交（Memory overcommit）的问题。Redis 在启动时发现内存过度提交被禁用，因此发出了警告。

有两个解决方法：

+ 将 `vm.overcommit_memory` 设置为 1：你可以编辑 `/etc/sysctl.conf` 文件，在文件末尾添加一行 `vm.overcommit_memory = 1`，然后保存并退出。然后，运行 `sysctl -p` 命令来重新加载配置文件，使更改生效。这个方法会在系统重新启动后永久生效。
+ 直接运行命令：你也可以直接运行命令 `sysctl vm.overcommit_memory=1`，这将立即生效，但不会在系统重启后保留设置。

将redis-cli,redis-server拷贝到bin下，让redis-cli指令可以在任意目录下直接使用

```bash
cp /usr/local/redis/bin/redis-server /usr/local/bin/
cp /usr/local/redis/bin/redis-cli /usr/local/bin/
```

常用命令：

+ `redis-server /usr/local/redis/etc/redis.conf //启动redis`
+ `pkill redis //停止redis`
+ 卸载redis：
  + `rm -rf /usr/local/redis //删除安装目录`
  + `rm -rf /usr/bin/redis-* //删除所有redis相关命令脚本`
  + `rm -rf /root/download/redis-4.0.4 //删除redis解压文件夹`

启动 redis 两种方式：

+ `redis-server &`：加上`&`号使redis以后台程序方式运行
+ `redis-server`

## 持久运行

目前后端和redis都启动了，但是还要这两个命令在服务器上一直运行，并且在需要的时候自己启动，使用 `systemd` 管理。

在 systemd 服务目录中 `/etc/systemd/system/`，创建两个服务单元文件，比如 `ruoyi-admin.service` 和 `redis.service`，以便 systemd 可以管理这些服务。

`ruoyi-admin.service` 文件内容如下：

```
[Unit]
Description=Ruoyi Admin Service
After=network.target

[Service]
User=root
WorkingDirectory=/roor/ruoyi/ruoyi-admin
ExecStart=/usr/bin/java -jar ruoyi-admin.jar
SuccessExitStatus=143
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

 `redis.service` 文件内容如下：

```
[Unit]
Description=Redis Server
After=network.target

[Service]
User=root
Type=simple
ExecStart=/usr/local/redis/bin/redis-server /usr/local/redis/etc/redis.conf
Restart=always
RestartSec=3

[Install]
WantedBy=multi-user.target
```

然后重新加载 systemd 守护程序配置：

```shell
systemctl daemon-reload
```

再启动服务并设置为开机启动：

```shell
sudo systemctl start ruoyi-admin
sudo systemctl enable ruoyi-admin

sudo systemctl start redis
sudo systemctl enable redis
```

这样，`ruoyi-admin.jar` 和 `redis-server` 就会作为服务在后台持续运行，并且在服务器启动时自动启动。

## 使用 Nginx

```bash
yum install nginx -y  # 安装Nginx
systemctl enable nginx  # 设置nginx开启启动
systemctl start nginx  # 启动nginx
```

启动后，访问自己服务的 IP 地址，会看到 Nginx 的红页，说明安装成功。

```bash
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash  # 安装node管理工具nvm
source ~/.bashrc  # 更新配置文件
nvm install v20.11.1  # 安装node
node -v  # 验证是否安装成功
```

然后在 `/etc/nginx/conf.d/` 下新建一个 `ry.conf` 文件：

```bash
server {
        listen 80;  # 端口
        server_name 47.109.78.124;  # 自己的ip地址
        location / {
                root /usr/share/nginx/html/test;  # 前端项目的根路径
                index index.html;  # 项目根路径下的首页
        }
}
```

然后保存退出，使用 `nginx -s reload` 重启 nginx，然后访问自己的 IP 地址，即可访问到前端项目的首页。

注意：前端项目的位置最好就放在 `/usr/share/nginx/html` 下自己新建的文件夹中，如果放在其他地方可能会有 403 错误。

此时还是有个错误，就是前端首页是获取不到验证码图片的，所以推荐直接使用若依官方的配置文件：

```bash
worker_processes  1;

events {
    worker_connections  1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    keepalive_timeout  65;

    server {
        listen       80;
        server_name  localhost;
		charset utf-8;

		location / {
            root   /home/ruoyi/projects/ruoyi-ui;
			try_files $uri $uri/ /index.html;
            index  index.html index.htm;
        }
		
		location /prod-api/ {
			proxy_set_header Host $http_host;
			proxy_set_header X-Real-IP $remote_addr;
			proxy_set_header REMOTE-HOST $remote_addr;
			proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
			proxy_pass http://localhost:8080/;
		}

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
    }
}
```

只需要将其中的 server 块改掉 location 中的 root 地址就可以用了。那么现在就可以通过服务器的IP来访问项目：http://47.109.78.124/

## 注意

如果不想通过根路径来访问，也就是说不想通过这样的路径来访问项目：http://47.109.78.124/，那么还可以自己设置访问路径：

```
location /CEAP/ {
    root   /home/ruoyi/projects/CEAP;
    try_files $uri $uri/ /index.html;
    index  index.html index.htm;
}
```

+ CEAP：College employment analysis platform

这样访问地址就变成了：http://47.109.78.124/CEAP

但是，这样会有个问题，因为在 `location` 块中使用了 `root` 指令时，Nginx 会根据请求的 URI 与 `location` 块的匹配规则来构造文件路径。也就是说当我们访问 http://47.109.78.124/CEAP 的时候，nginx 实际会在服务器上的 /home/ruoyi/projects/ruoyi-ui/CEAP/ 下去访问资源，所以这时候很有可能会出现 404 错误，因为没有 CEAP 这个文件夹，但是哪怕在 /home/ruoyi/projects/ruoyi-ui 下新建一个 CEAP 文件夹，项目中有些文件引入了其他地方的 js 文件或 css 文件这个时候也会报错，因为这些引入文件的路径中没有 CEAP 这个路径，所以这时候就需要 publicPath。

在 Vue.js 中，`publicPath` 用于指定项目的根路径，即所有资源的基础路径。

在 Vue.config.js 中 publicPath 默认是这样的：
```
publicPath: process.env.NODE_ENV === "production" ? "/" : "/",
```

这表明不管是生产环境还是开发环境， publicPath 都是根路径，修改如下：
```
publicPath: process.env.NODE_ENV === "production" ? "/CEAP/" : "/",
```

这样，生产环境中，项目内的路径都会以 CEAP 开始，使用上面的 nginx 配置就不会报错 404。

## 再注意

这时候可以通过 http://47.109.78.124/CEAP/ 链接访问到项目了，但是点击登录后会跳转到 404 页面，此时点击 “返回首页” 会回到项目的主页，并且此时一刷新的话，就会回到 404 页面。这是因为路由的问题，我们的 nginx 配置的路径是 /CEAP/，但是点击登录后的页面，路径不是以 /CEAP/ 开始的，所以会报 404，所以还需要将项目中的路由改一下。

具体可以查看该篇文章：[关于publicPath](https://segmentfault.com/a/1190000042107272)

该文章总结了四个方式部署：

1. 傻瓜模式：路由采用 hash 模式，publicPath 采用相对路径 './' 模式，此种组合配置操作简单，可以部署到任意路径上，并且能支持二级目录，比较省心。即便是直接访问打包后的 index.html 也能看到效果，应用的场景可能如下：

   - 一个纯前端应用，不需要和后台的接口进行交互，支持本地静态展示。
   - 只是用来部署到 github gh-page 分支下的纯前端展示应用。
   - 如使用 vue 开发的 h5 项目，然后使用 hbuilder 进行打包的 hybird app。
   - 部署在带有二级路径的网站上。

   路由采用 hash 模式：在 router 下的 index.js 中
   ```js
   export default new Router({
     // mode: 'history', // 去掉url中的#
     mode: 'hash',
     scrollBehavior: () => ({ y: 0 }),
     routes: constantRoutes
   })
   ```

   publicPath 采用相对路径 './' 模式：在 Vue.config.js 中

   ```js
   publicPath: process.env.NODE_ENV === "production" ? "./" : "/",
   ```

2. 进阶模式：路由采用 history 模式，publicPath 采用绝对路径 '/' 模式，此这种模式需要服务器来对前端资源进行部署。同时，还需要在服务器上配置404重定向到 index.html。

3. 升级模式：路由采用 history 模式，publicPath 采用了 '/sub/' 二级路径，相应的 router base 参数也应该设置为 '/sub/' (通常使用脚手架默认提供的 process.env.BASE_URL 即可)。此种模式即在多个项目同时部署到一个域名和端口下时，采用不同的二级路径来对项目进行逻辑上的划分。与进阶模式的服务部署方式相同。

   路由采用 history，router base 参数设置为 process.env.BASE_URL：router 下的 index.js 中

   ```js
   export default new Router({
     mode: 'history', // 去掉url中的#
     scrollBehavior: () => ({ y: 0 }),
     base: process.env.NODE_ENV === "production" ? "/CEAP" : process.env.BASE_URL,
     routes: constantRoutes
   })
   ```

   publicPath 采用了二级路径：

   ```js
   publicPath: process.env.NODE_ENV === "production" ? "/CEAP/" : "/",
   ```

这还有一篇文章，讲的东西很上一篇一样，但是更简单：[vue cli3-cli4 打包后项目在二级路径的方法](https://www.mulingyuer.com/archives/746/)

## 退出跳到404页面

我采用了上面的第四种方法部署，基本没问题，但是点击退出登录的时候，跳到了404页面，观察这时候的地址栏：http://47.109.78.124/index，这个地址并不在 CEAP 二级目录下，所以会报 404。可以在项目中 src/layout 下找到 Navbar.vue 文件，查看它的退出登录代码：

```js
 async logout() {
     this.$confirm('确定注销并退出系统吗？', '提示', {
         confirmButtonText: '确定',
         cancelButtonText: '取消',
         type: 'warning'
     }).then(() => {
         this.$store.dispatch('LogOut').then(() => {
             location.href = '/index';
         })
     }).catch(() => {});
 }
```

可以看到这时候的退出登录是绝对路径，所以改一下：

```js
 async logout() {
     this.$confirm('确定注销并退出系统吗？', '提示', {
         confirmButtonText: '确定',
         cancelButtonText: '取消',
         type: 'warning'
     }).then(() => {
         this.$store.dispatch('LogOut').then(() => {
             location.href = '/CEAP/index';
         })
     }).catch(() => {});
 }
```

## 总结：部署成功

主要是总结前端 vue 项目的部署，后端项目的部署很简单，随便找个位置把 jar 包放着，然后运行 jar 包，一直运行就好了。

前端项目主要是路由和静态资源路径的问题。

将前端项目打包生成的 dist 文件夹中的所有东西都传到了服务器的 /home/ruoyi/projects/CEAP 目录下。

设置 publicPath，在 Vue.config.js 中：

```js
publicPath: process.env.NODE_ENV === "production" ? "/CEAP/" : "./",
```

设置路由的 base 参数，在 router 下的 index.js 中：

```js
export default new Router({
  mode: 'history', // 去掉url中的#
  scrollBehavior: () => ({ y: 0 }),
  base: process.env.NODE_ENV === "production" ? "/CEAP" : process.env.BASE_URL,
  routes: constantRoutes
})
```

设置退出登录的跳转，在 src/layout 下的 navbar.vue 中：

```js
async logout() {
     this.$confirm('确定注销并退出系统吗？', '提示', {
         confirmButtonText: '确定',
         cancelButtonText: '取消',
         type: 'warning'
     }).then(() => {
         this.$store.dispatch('LogOut').then(() => {
             location.href = '/CEAP/index';
         })
     }).catch(() => {});
 }
```

设置 nginx 的配置：

```js
location /CEAP/ {
    root /home/ruoyi/projects;
    try_files $uri $uri/ /CEAP/index.html;
    index  index.html index.htm;
}
```

