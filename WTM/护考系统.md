# 护考系统

> 护士资格考试刷题系统

## 一、建库

### 1. 建表

所有考试题目分为两种类型：

+ 专业实务
+ 实践能力

现有的题库中将所有题目按照 年度真题 和 章节题目 分成了两部分，所以考虑将刷题页面做成两个：

+ 章节练习：根据章节来刷题
+ 真题练习：根据真题的年度来刷题

![image-20231210132501919](https://gitee.com/LowProfile666/image-bed/raw/master/img/202312101325009.png)

+ Year 表示真题的年度，可以使用一张表来存，也可可以用 WTMPlus 提供的数据字典或枚举类型来管理；
+ QuestionType 表示题目的类型，也用 WTMPlus 提供的数据字典来处理，有两个值：专业实务、实践能力；
+ Chapter 和 Section 用数据表存储，因为章节的关系应该是一对多的关系，一个章有多个节。

### 2. 创建模型

使用 WTMPlus ，新建两个区域：QuestionBank 和 StudentArea

+ QuestionBank 用来存放题库相关的模型和页面
+ StudentArea 用来存放学生能看到的页面的，就是刷题页面

按照上面的表设计，在 QuestionBank 区域中建三个模型，分别是：Question（题）、Chapter（章）、Section（节），均勾选上 “是否为BasePoco” 选项，然后分别创建它们所含有的字段，注意 Photo 字段需要使用 “附件类型”。

其中 Question 模型的 QuestionType、Year 两个字段使用 “单个数据字典” 类型，在 “资源维护” 中的 “数据字典维护” 中添加两个字典：“真题年度” 和 “题目类型”，真题年度中的值就为 2011 到 2022，题目类型中的值就是 专业实务、实践能力。还有 Chapter 和 Section 字段，都设为 “一对多关联” 类型，Chapter 字段关联的模型是 Chapter，Section 字段关联的模型是 Section，这表示一个章和一个节对应着多个题目。

还有 Section 模型中的 Chapter 字段需要使用 “一对多关联” 类型，关联的模型是 Chapter，表示一个章有多个节。

并且三个模型均使用自定义主键，在页面右边选择主键类型为 int，字段名为 id。

![image-20231210134718160](https://gitee.com/LowProfile666/image-bed/raw/master/img/202312101347237.png)

然后保存模型，并且都生成默认页面。生成默认页面后，需要改动一下有的页面，将章节信息设置为联动。

比如在创建题目的时候，在 Question 的 Create 页面中，会有两个章节的下拉选择框，将 “章” 的那个下拉框设置联动，“节” 下拉框不需要设置联动：

![image-20231210135214523](https://gitee.com/LowProfile666/image-bed/raw/master/img/202312101352576.png)

除了这个页面，还有其他只要出现了章节信息的页面都将下拉框设为联动。

### 3. 创建页面

在 StudentArea 区域下新建三个页面：ChapterExam、RealExam 和 MockExam（按需创建），分别是章节训练、真题训练和模拟考试。这三个页面都只需要拖入一个表单即可，因为最终的页面由我们自己手写完成，通过 WTMPlus 创建好页面就可以直接使用，不用再去人工配置。

## 二、实现后端API

将代码下载下来，然后使用 VS 打开，先在 appsetting.json 中将数据库改成本地的 MySQL 数据库。

然后在 Areas/StudentArea/Controllers 下新建两个文件：\_ChapterExamController.cs 和 \_RealExamController.cs，分别用来控制章节训练和真题训练的业务逻辑。

这两个新建的 controller 要继承 BaseController，如：

```cs
public class _ChapterExamController : BaseController
{
    
}
```

### 1. 章节训练

先在类名上添加路由：

```cs
[Route("/ChapterExam")]
public class _ChapterExamController : BaseController
{
}
```

这样表示该类中所有的 API 的路径都是在 /ChapterExam 下。

#### 1.1 获取章节信息

可以新建一个内部类来做返回数据的结构，这个类包括两个属性，章的名字和该章所有的节的名字，返回的是一个 List 集合：

```cs
// 用做返回结果的结构
public class ChapterResult
{
    public string Name { get; set; }
    public List<string> SectionList { get; set; }
}
// 获取章节信息
[HttpGet("GetChapterInfo")]
public List<ChapterResult> GetChapterInfo()
{
    var ChapterList = DC.Set<Chapter>().ToList();
    List<ChapterResult> res = new List<ChapterResult>();
    foreach (var item in ChapterList)
    {
        ChapterResult c = new ChapterResult();
        c.SectionList = DC.Set<Section>().Where(x => x.ChapterIDId == item.ID).Select(x => x.Name).ToList();
        c.Name = item.Name;
        res.Add(c);
    }
    return res;
}
```

这个 API 的访问地址就是：`/ChapterExam/GetChapterInfo/`。

#### 1.2 根据章节获取题目信息

使用 `[FromBody]` 来接收前端传来的章节信息，然后拿到数据库中的值，返回给前端：

```cs
// 获取指定章节的所有题目
[HttpPost("GetQuestionByChapter")]
public List<Question> GetQuestionByChapter([FromBody] string chapter, [FromBody] string section)
{
    List<Question> list = new List<Question>();
    list = DC.Set<Question>().Where(x => x.Chapter.Name == chapter && x.Section.Name == section).ToList();
    return list;
}
```

#### 1.3 获取题目的图片

前端传过来题目的 ID，根据这个 ID 去拿到数据库中对应的图片，然后返回图片的二进制信息，再由前端将这个二进制信息转为图片：

```cs
public class PhotoRequest
{
    public string PhotoId { get; set; }
}
// 获取题目图片
[HttpPost("GetQuestionPhoto")]
public IActionResult GetQuestionPhoto([FromBody] PhotoRequest request)
{
    var fileAttachment = DC.Set<FileAttachment>().Single(x => x.ID.ToString() == request.PhotoId);

    // 根据文件类型设置 Content-Type 头
    string contentType = "image/png"; // 根据你的实际文件类型进行调整
    Response.Headers.Add("Content-Type", contentType);
    // 返回文件数据
    return File(fileAttachment.FileData, contentType);
}
```

因为前端在请求的时候，传过来的 ID 并不是一个简单的字符串，而是一个 json 对象，所以要使用一个对应这个 json 对象的格式的对象来接收。

### 2. 真题训练

和章节训练的API类似：

```cs
[Route("/RealExam/")]
public class _RealExamController : BaseController
{
}
```

#### 2.1 获取年度信息

年度的存储是数据字典的形式，数据库中会有一个 DicDef 表，这个表里放着定义的所有的数据字典，还有一个 DicField 表，这个表里记录着所有数据字典的数据，有个字段是指明了这条数据属于的数据字典。

所以先找到要的数据字典的 ID，然后过根据这个 ID 拿到这个数据字典里的所有数据，返回给前端：

```cs
[HttpGet("GetYearInfo")]
public List<string> GetYearInfo()
{
    var YearId = DC.Set<DicDef>().Single(x => x.DicName == "YearDic").ID;
    var YearList = DC.Set<DicField>().Where(x => x.DicDefId == YearId).OrderBy(x => x.DicFieldName).Select(x => x.DicFieldName).ToList();
    return YearList;
}
```

#### 2.2 获取类型信息

类型也是用的数据字典保存的：

```cs
[HttpGet("GetTypeInfo")]
public List<string> GetTypeInfo()
{
    var TypeId = DC.Set<DicDef>().Single(x => x.DicName == "QuestionTypeDic").ID;
    var TypeList = DC.Set<DicField>().Where(x => x.DicDefId == TypeId).OrderBy(x => x.DicFieldName).Select(x => x.DicFieldName).ToList();
    return TypeList;
}
```

#### 2.3 获取年度题目信息

前台传过来指定的年度和类型，然后拿到数据库中对应的年度和类型的 ID，再用这两个 ID 去题目表中去找，最后返回给前端：

```cs
[HttpPost("GetQuestionByYear")]
public List<Question> GetQuestionByYear([FromBody] string year, [FromBody] string type)
{
    List<Question> list = new List<Question>();
    var yearId = DC.Set<DicField>().Single(x => x.DicFieldName == year).ID;
    var typeId = DC.Set<DicField>().Single(x => x.DicFieldName == type).ID;
    list = DC.Set<Question>().Where(x => x.YearId == yearId && x.QuestionTypeId == typeId).ToList();
    return list;
}
```

## 三、实现前端页面

打开 Areas/StudentArea/Views/\_Default 下的 ChapterExam.cshtml 和 RealExam.cshtml，这是章节训练和真题训练的页面，将框架自己生成的代码删除掉，只留一下一个关闭按钮：

```html
<wt:closebutton></wt:closebutton>
```

这个关闭按钮可以将当前这个 tab 页给关闭掉。然后使用纯 HTML 代码写页面。

### 1. 整体布局

![image-20231210174014916](https://gitee.com/LowProfile666/image-bed/raw/master/img/202312101740973.png)

```html
<div id="selectArea">
    <label for="firstSelect" class="lable">章：</label>
    <select id="firstSelect" onchange="firstSelectChange()"></select>
    <label for="secondSelect" class="lable">节：</label>
    <select id="secondSelect" onchange="updateContent()"></select>
</div>
<div id="questionNumber">
    <div id="questionNumberInfo"></div>
    <div id="questionNumberInput">
        <label for="jumpToQuestion">跳转至题号:</label>
        <input type="text" id="jumpToQuestion" placeholder="题号">
        <button onclick="jumpToQuestion()">跳转</button>
    </div>
</div>
<hr />
<div id="contentArea">
    <div id="summeryArea"></div>
    <div id="questionArea"></div>
    <div id="parseArea"></div>
    <div id="buttonArea">
        <button type="button" class="button" id="preBtn" onclick="preQuestion()">上一题</button>
        <button type="button" class="button" id="submitBtn" onclick="submit()">提交</button>
        <button type="button" class="button" id="nextBtn" onclick="nextQuestion()">下一题</button>
        <button type="button" class="button" id="parseBtn" onclick="showParse()">查看解析</button>
    </div>
</div>
<hr />
<wt:closebutton></wt:closebutton>
```

### 2. 前台逻辑

```js
<div id="selectArea">
    <label for="firstSelect" class="lable">章：</label>
    <select id="firstSelect" onchange="firstSelectChange()">
    </select>

    <label for="secondSelect" class="lable">节：</label>
    <select id="secondSelect" onchange="updateContent()">
    </select>
</div>
<div id="questionNumber">
    <div id="questionNumberInfo">

    </div>
    <div id="questionNumberInput">
        <label for="jumpToQuestion">跳转至题号:</label>
        <input type="text" id="jumpToQuestion" placeholder="题号">
        <button onclick="jumpToQuestion()" id="jumpBtn">跳转</button>
    </div>

</div>
<hr />
<div id="contentArea">
    <div id="summeryArea"></div>
    <div id="questionArea"></div>
    <div id="parseArea"></div>
    <div id="buttonArea">
        <button type="button" class="button" id="preBtn" onclick="preQuestion()">上一题</button>
        <button type="button" class="button" id="submitBtn" onclick="submit()">提交</button>
        <button type="button" class="button" id="nextBtn" onclick="nextQuestion()">下一题</button>
        <button type="button" class="button" id="parseBtn" onclick="showParse()">查看解析</button>
    </div>
</div>
<hr />

<script>
    let cInfo = new Map();
    let qInfo = {
        q: [],
        idx: 0,
    };
    var userAnswers = new Map();
    var isSubmit = false;
    var isNull = false;
    var isParse = false;
    var preBtn = document.getElementById("preBtn");
    var nextBtn = document.getElementById("nextBtn");
    var submitBtn = document.getElementById("submitBtn");
    var parseBtn = document.getElementById("parseBtn");
    var jumpBtn = document.getElementById("jumpBtn");
    var firstSelect = document.getElementById("firstSelect");
    var secondSelect = document.getElementById("secondSelect");
    var questionNumberInput = document.getElementById("questionNumberInput");
    
    // 拿到所有的章节信息，并显示第一章和第一节
    function getBasicData() {
        addKeyDownListener();
        $.ajax({
            url: "/ChapterExam/GetChapterInfo/",
            type: "get",
            success: function (resp) {
                // 将章节信息对应保存起来
                resp.forEach((c, i) => {
                    var sections = [];
                    c.SectionList.forEach((s, j) => {
                        sections.push(s);
                    });
                    cInfo.set(c.Name, sections);
                });

                // 设置章下拉框的内容
                var html = ``, idx = 1;
                for (var name of cInfo.keys()) {
                    html += `<option value="` + name + `">第` + idx++ + `章：` + name + `</option>`;
                }
                $("#firstSelect").html(html);

                // 设置第一章的节下拉框的内容
                html = ``, idx = 1;
                for (var name of cInfo.get(resp[0].Name)) {
                    html += `<option value="` + name + `">第` + idx++ + `节：` + name + `</optino>`;
                }
                $("#secondSelect").html(html);

                // 设置题号区域的信息
                setQuestionNumber();

                // 设置题目页面第一章第一节的第一题
                getQuestion(resp[0].Name, resp[0].SectionList[0]);
                showBtns();
            }
        });
    }
    // 设置题号区域的信息
    function setQuestionNumber() {
        var sum = qInfo.q.length;
        var cur = qInfo.idx + 1;
        if (sum == 0) cur = 0;
        var html = `<span>总题数: ` + sum + `</span>`;
        html += `<span>当前题号: ` + cur + `</span>`;
        $("#questionNumberInfo").html(html);
    }
    // 空页
    function setNullPage() {
        isNull = true;
        var html = `<h1 style="margin-top:30px; margin-bottom:30px;">当前章节下没有题目！</h1>`;
        $("#questionArea").html(html);
        qInfo.idx = 0;
        qInfo.q = [];
        setQuestionNumber();
        showBtns();
    }
    // 根据章节，获取题目
    function getQuestion(c, s) {
        $.ajax({
            url: "/ChapterExam/GetQuestionByChapter/",
            type: 'post',
            data: {
                chapter: c,
                section: s,
            },
            success: function (resp) {
                // 当前章节没有题目时
                if (resp.length == 0) {
                    setNullPage();
                    return;
                }
               
                // 将题目保存到本地
                qInfo.q = resp;
                qInfo.idx = 0;

                // 渲染题目
                showQuestion(resp[0], 0);
            },
        });
    }
    // 渲染按钮
    function showBtns() {
        nextBtn.style.display = "";
        preBtn.style.display = "";
        submitBtn.style.display = "";
        parseBtn.style.display = "";
        questionNumberInput.style.display = "";
        // 空页时，不显示按钮区域
        if (isNull) {
            document.getElementById("buttonArea").style.display = "none";
            questionNumberInput.style.display = "none";
            isNull = false;
            return;
        } 
        document.getElementById("buttonArea").style.display = "";
        // 提交后，只显示查看解析按钮
        if (isSubmit) {
            nextBtn.style.display = "none";
            preBtn.style.display = "none";
            submitBtn.style.display = "none";
            parseBtn.style.display = "";
            questionNumberInput.style.display = "none";
            isSubmit = false;
            return;
        }
        parseBtn.style.display = "none";
        // 显示解析信息时不显示提交
        if (isParse) {
            submitBtn.style.display = "none";
            nextBtn.style.display = "";
            preBtn.style.display = "";
        }
        // 没有下一题时不显示下一题按钮
        if (qInfo.q.length <= 1 || qInfo.idx >= qInfo.q.length - 1)
            nextBtn.style.display = "none";
        else nextBtn.style.display = "";
        // 没有上一题时不显示上一题按钮
        if (qInfo.q.length <= 0 || qInfo.idx == 0)
            preBtn.style.display = "none";
        else preBtn.style.display = "";
    }
    // 章节改变时
    function firstSelectChange() {
        var c = document.getElementById('firstSelect').value;
        var html = ``, idx = 1;
        for (var name of cInfo.get(c)) {
            html += `<option value="` + name + `">第` + idx++ + `节：` + name + `</optino>`;
        }
        $("#secondSelect").html(html);
        updateContent();
    }
    // 获取题目图片
    function getQuestionPhoto(photoId, imgId) {
        fetch("/ChapterExam/GetQuestionPhoto/", {
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            },
            body: JSON.stringify({
                photoId: photoId,
            }),
        })
            .then(response => response.blob())
            .then(blob => {
                let imageUrl = URL.createObjectURL(blob);
                document.getElementById(imgId).src = imageUrl;
            })
            .catch(error => console.error('Error fetching image:', error));
    }
    // 渲染题目
    function showQuestion(q, idx, disabled) {

        var html = '<h4 style="line-height:40px">' + (idx + 1) + `、` + q.Text + `</h4>`;
        html += `<img id="questionPhoto" src=""></img>`
        html += `<div style = "line-height:20px;" >`;
        html += `<input type="radio" id="CA" value="A" name="` + 'c' + idx + `" ` + disabled + `/><label for="CA"> &nbsp;&nbsp;A：` + q.OptionA + `<br /><img src="" id="CAPhoto" /></label><br />`;
        html += `<input type="radio" id="CB" value="B" name="` + 'c' + idx + `" ` + disabled + `/><label for="CB"> &nbsp;&nbsp;B：` + q.OptionB + `<br /><img src="" id="CBPhoto" /></label><br />`;
        html += `<input type="radio" id="CC" value="C" name="` + 'c' + idx + `" ` + disabled + `/><label for="CC"> &nbsp;&nbsp;C：` + q.OptionC + `<br /><img src="" id="CCPhoto" /></label><br />`;
        html += `<input type="radio" id="CD" value="D" name="` + 'c' + idx + `" ` + disabled + `/><label for="CD"> &nbsp;&nbsp;D：` + q.OptionD + `<br /><img src="" id="CDPhoto" /></label><br />`;
        html += `<input type="radio" id="CE" value="E" name="` + 'c' + idx + `" ` + disabled + `/><label for="CE"> &nbsp;&nbsp;E：` + q.OptionE + `<br /><img src="" id="CEPhoto" /></label><br />`;
        html += `</div>`;
        $("#questionArea").html(html);

        if(q.PhotoId !== undefined) {
            getQuestionPhoto(q.PhotoId, "questionPhoto");
        }

        if (q.PhotoAId !== undefined) {
            getQuestionPhoto(q.PhotoAId, "CAPhoto");
        }

        if (q.PhotoBId !== undefined) {
            getQuestionPhoto(q.PhotoBId, "CBPhoto");
        }

        if (q.PhotoCId !== undefined) {
            getQuestionPhoto(q.PhotoCId, "CCPhoto");
        }

        if (q.PhotoDId !== undefined) {
            getQuestionPhoto(q.PhotoDId, "CDPhoto");
        }

        if (q.PhotoEId !== undefined) {
            getQuestionPhoto(q.PhotoEId, "CEPhoto");
        }
        setQuestionNumber();
        showBtns();
    }
    // 根据下拉框的变化来更改题目
    function updateContent() {
        isParse = false;
        // 获取第一个下拉框的值
        var c = firstSelect.value.split("：");

        // 获取第二个下拉框的值
        var s = secondSelect.value.split("：");

        // 获取显示内容的区域
        var questionArea = document.getElementById('questionArea');

        // 根据下拉框的值更新内容
        getQuestion(c, s)
        userAnswers.clear();

        $("#parseArea").html("");
        showBtns();

    }
    // 获取当前题目的用户选的答案
    function getAnswer(idx) {
        var radios = document.getElementsByName('c'+idx);
        for (var i = 0; i < 5; i++) {
            if (radios[i].checked) {
                return radios[i].value;
            }
        }
    }
    // 单选框上显示用户选的答案
    function setRadios(idx) {
        var radios = document.getElementsByName('c' + idx);
        for (var i = 0; i < 5; i++) {
            if (radios[i].value === userAnswers.get(idx)) {
                radios[i].checked = "true";
                return;
            }
        }
    }
    // 下一题
    function nextQuestion() {
        // 先保存当前选的答案
        userAnswers.set(qInfo.idx, getAnswer(qInfo.idx));

        ++qInfo.idx;
        showQuestion(qInfo.q[qInfo.idx], qInfo.idx);
        setRadios(qInfo.idx);
        // 显示解析
        if (isParse) {
            showParse(qInfo.idx);
        }
    }
    // 上一题
    function preQuestion() {
        userAnswers.set(qInfo.idx, getAnswer(qInfo.idx));
        --qInfo.idx
        showQuestion(qInfo.q[qInfo.idx], qInfo.idx);
        setRadios(qInfo.idx);
        if (isParse) {
            showParse(qInfo.idx);
        }
    }
    // 提交题目
    function submit() {
        isSubmit = true;
        userAnswers.set(qInfo.idx, getAnswer(qInfo.idx));
        var total = 0, correct = 0, score = 0;
        for (var i = 0; i < userAnswers.size; i++) {
            var a = qInfo.q[i].Answer;
            var b = userAnswers.get(i);
            if (b !== undefined) {
                total++;
                if (a === b) {
                    correct++;
                    score++;
                }
            }
        }
        var html = `<h4>总做题数：` + total
            + `</h4><h4>正确数：` + correct
            + `</h4><h4>错误数：` + (total - correct)
            + `</h4><h4>总得分：` + score + `</h4>`;
        html += `<hr/>`;
        $("#questionArea").html(html);
        qInfo.idx = 0;
        showBtns();
    }
    // 渲染解析页面
    function showParse() {
        isParse = true;
        showQuestion(qInfo.q[qInfo.idx], qInfo.idx, "disabled");
        setRadios(qInfo.idx);
        var a = userAnswers.get(qInfo.idx);
        var b = qInfo.q[qInfo.idx].Answer;
        if (a === undefined)    a = "";
        var html = `<p>你的答案：` + a + `</p><p>正确答案：` + b + `</p>`;
        html += `<p>` + qInfo.q[qInfo.idx].Parse + `</p><img src="" id="parsePhoto"/>`;

        if (qInfo.q[qInfo.idx].PhotoParseId !== undefined) {
            getQuestionPhoto(qInfo.q[qInfo.idx].PhotoParseId, "parsePhoto");
        }
        $("#parseArea").html(html);
        setQuestionNumber();
        showBtns();
        isSubmit = true;
    }
    function jumpToQuestion() {
        // 获取输入的题号并进行相应的处理
        var num = document.getElementById("jumpToQuestion").value;
        if (num === "") return;  // 当前没有输入题号
        if (num > qInfo.q.length) {
            num = qInfo.q.length;
            document.getElementById("jumpToQuestion").value = qInfo.q.length;
        }

        // 这里可以添加具体的跳转逻辑，例如更新题目内容等
        qInfo.idx = num - 1;
        if (isParse) showParse();
        else showQuestion(qInfo.q[qInfo.idx], qInfo.idx);

        document.getElementById("jumpToQuestion").value = "";
    }
    getBasicData();

    var keydownHandler;
    // 添加事件监听器的函数
    function addKeyDownListener() {
        removeKeyDownListener();
        keydownHandler = function (event) {
            // 获取按下的键的键码
            var keyCode = event.keyCode;
            const elements = document.querySelectorAll('.layui-this');
            var cur = elements[0].dataset["name"];
            // 判断按下的是哪个键
            if (cur === "章节练习") {
                switch (keyCode) {
                    case 65: // 键码 65 对应 'a'
                        if (!isParse) document.getElementById("CA").checked = true;
                        break;
                    case 66: // 键码 66 对应 'b'
                        if (!isParse) document.getElementById("CB").checked = true;
                        break;
                    case 67: // 键码 67 对应 'c'
                        if (!isParse) document.getElementById("CC").checked = true;
                        break;
                    case 68: // 键码 68 对应 'd'
                        if (!isParse) document.getElementById("CD").checked = true;
                        break;
                    case 69: // 键码 69 对应 'e'
                        if (!isParse) document.getElementById("CE").checked = true;
                        break;
                    case 38: // 键码 38 对应向上箭头
                        event.preventDefault();
                        if (qInfo.idx > 0)
                            preQuestion();
                        break;
                    case 40: // 键码 40 对应向下箭头
                        event.preventDefault();
                        if (qInfo.idx < qInfo.q.length - 1)
                            nextQuestion();
                        break;
                    case 13:
                        if (!isSubmit)
                            submit();
                        break;
                    default:
                        // 其他键
                        break;
                }
            }
        }
        document.addEventListener("keydown", keydownHandler);
    }

    // 移除事件监听器的函数
    function removeKeyDownListener() {
        if (keydownHandler) {
            document.removeEventListener("keydown", keydownHandler);
            keydownHandler = null;
        }
    }
    // 限制题号输入框只能输入数字
    document.getElementById('jumpToQuestion').addEventListener('keydown', function (e) {
        // 允许数字、删除键、退格键
        if (!(e.key === '0' || e.key === '1' || e.key === '2' || e.key === '3' || e.key === '4' || e.key === '5' || e.key === '6' || e.key === '7' || e.key === '8' || e.key === '9' || e.key === 'Backspace' || e.key === 'Delete')) {
            e.preventDefault();
        }
    });
</script>
```

## 四、更换网站logo等

登录页面的左上角的 logo 在主项目的 Views/Login/Login.cshtml 中修改，在该页面的 <title> 中修改当前网站的标题，

```html
<header class="login-header">
    <img src="/images/logo.png" alt="" height="48">
</header>
```

这一块就是登录页面左上角的 logo 图片，所以只需要将新的 logo 图片复制到 wwwroot/images 下即可。

登录进去后的主页面左侧的顶部的 logo 在 Views/Home/Layout.cshtml 页面中修改，找到代码中的侧边菜单区域，修改如下：

```html
<div class="layui-logo" lay-href="">
    <span><img src="~/layuiadmin/style/res/logo1.png" style="margin-right:5px;" />海通教育</span>
</div>
```

这个 logo1 就是新的 logo 图片，需要放在 wwwroot/layuiadmin/style/res 下。

还需要修改所有页面的标题，要在 Views/Shared/\_Layout.cshtml 中修改，直接将 <title> 的内容换掉即可。

## 五、设置主页

设置根据不同登录用户的角色来显示不同的主页。

在 Views/Home/FrontPage.cshtml 中，删除主页一些不用的代码，只留下快捷方式那一块代码，然后将快捷方式改为自己想要的快捷方式，再通过用户的角色 ID 来决定显示哪些快捷方式。

获取到用户的所有角色 ID ，并把所有的角色ID拿到，和对应的快捷方式链接一起放入一个字典中：

```cs
@{
    var code1 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "管理员").RoleCode;
    var code2 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "超级管理员").RoleCode;
    var code3 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "护士").RoleCode;
    var code4 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "初级护师").RoleCode;
    var code5 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "中级护师").RoleCode;
    var code6 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "考公考编").RoleCode;
    var code7 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "其他类").RoleCode;
    var code8 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "学历提升-专科").RoleCode;
    var code9 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "学历提升-本科").RoleCode;
    var code10 = Model.DC.Set<FrameworkRole>().Single(x => x.RoleName == "学历提升-研究生").RoleCode;
    var userCode = Model.DC.Set<FrameworkUserRole>().Where(x => x.UserCode == Model.LoginUserInfo.ITCode).ToList();
    Dictionary<string, string[]> hrefs = new Dictionary<string, string[]>();
    hrefs.Add(code2, new string[] { "_Admin/FrameworkUser/Index?用户?layui-icon-username",
                                   "questionbank/chapter/index?章管理?layui-icon-date",
                                   "questionbank/section/index?节管理?layui-icon-layer",
                                   "questionbank/question/index?题目管理?layui-icon-template-1"});
    hrefs.Add(code1, new string[] { "_Admin/FrameworkUser/Index?用户?layui-icon-username",
                                   "questionbank/chapter/index?章管理?layui-icon-date",
                                   "questionbank/section/index?节管理?layui-icon-layer",
                                   "questionbank/question/index?题目管理?layui-icon-template-1"});
    hrefs.Add(code3, new string[] { "studentarea/_default/chapterexam?章节训练?layui-icon-tabs",
                                   "studentarea/_default/realexam?真题训练?layui-icon-tabs"});
    hrefs.Add(code4, new string[] { "studentarea/_default/PrimayCareExam?初级护师?layui-icon-tabs"});
    hrefs.Add(code5, new string[] { "studentarea/_default/MiddelCareExam?中级护师?layui-icon-tabs"});
    hrefs.Add(code6, new string[] { "studentarea/_default/CivilServant_Written?笔试?layui-icon-tabs",
                                   "studentarea/_default/CivilServant_Interview?面试?layui-icon-tabs" });
    hrefs.Add(code7, new string[] { "studentarea/_default/Other_Public?其他类-公共课程?layui-icon-tabs",
                                   "studentarea/_default/Other_Major?其他类-专业课程?layui-icon-tabs" });
    hrefs.Add(code8, new string[] { "studentarea/_default/EducationPromotion_Junior_Public?专科-公共课程?layui-icon-tabs",
                                   "studentarea/_default/EducationPromotion_Junior_Major?专科-专业课程?layui-icon-tabs" });
    hrefs.Add(code9, new string[] { "studentarea/_default/EducationPromotion_Undergraduate_Public?本科-公共课程?layui-icon-tabs",
                                   "studentarea/_default/EducationPromotion_Undergraduate_Major?本科-专业课程?layui-icon-tabs" });
    hrefs.Add(code10, new string[] {"studentarea/_default/EducationPromotion_Graduate_Public?研究生-公共课程?layui-icon-tabs",
                                    "studentarea/_default/EducationPromotion_Graduate_Major?研究生-专业课程?layui-icon-tabs" });
    var res = new System.Text.StringBuilder();
}
```

然后通过当前登录用户的角色 ID 动态显示对应的快捷方式：

```html
<div class="layui-carousel layadmin-carousel layadmin-shortcut">
    <div carousel-item>
        <ul class="layui-row layui-col-space10">
            @{
                foreach (var uc in userCode)
                {
                    foreach (var item in hrefs[uc.RoleCode])
                    {
                        string[] s = item.Split("?");
                        res.Append($@"<li class='layui-col-xs3'>");
                        res.Append($@"<a lay-href='{s[0]}'>");
                        res.Append($@"<i class='layui-icon {s[2]}'></i>");
                        res.Append($@"<cite>{s[1]}</cite></a></li>");
                    }
                }
            }
            @Html.Raw(res.ToString())
        </ul>
    </div>
</div>
```

## 六、设置修改页面角色的显示

当有一个管理员角色时，当他创建用户或者审批用户时，不需要将 “超级管理员”和“管理员” 这两个角色显示出来，因为他只能创建用户一种角色，所以在显示页面的时候就不要显示这个角色。

有显示到这个角色的页面就是修改用户的页面，和审批用户的页面，它们的数据来源是：

在 Areas/Controllers/\_FrameworkUserApiController.cs 中，找到 GetFrameworkRoles 方法，修改以下代码：

```cs
if (rv != null && rv.Value is string && rv.Value != null)
{
    users = System.Text.Json.JsonSerializer.Deserialize<List<ComboSelectListItem>>(rv.Value.ToString());
}
else if (rv != null && rv.Value is List<ComboSelectListItem> c)
{
    if (Wtm.LoginUserInfo.ITCode != "admin")  // 管理员角色不能被显示出来
    {
        c.Remove(c.Single(x => x.Text == "超级管理员"));
        c.Remove(c.Single(x => x.Text == "管理员"));
    }
    users = c;
}
```

## 七、用户列表不显示admin

在 FrameworkUserListVM.cs 中，在 GetSearchQuery 方法中，添加一句 Where 条件即可：

```cs
public override IOrderedQueryable<FrameworkUser_View> GetSearchQuery()
{
    var query = DC.Set<FrameworkUser>()

        .CheckContain(Searcher.ITCode, x=>x.ITCode)
        .CheckContain(Searcher.Name, x=>x.Name)
        .CheckEqual(Searcher.IsValid, x=>x.IsValid)
        .Where(x => x.ITCode != "admin")
        .Select(x => new FrameworkUser_View
                {
                    ID = x.ID,

                    FrameworkUser_ITCode = x.ITCode,
                    FrameworkUser_Name = x.Name,
                    FrameworkUser_Gender = x.Gender,
                    FrameworkUser_CellPhone = x.CellPhone,
                    FrameworkUser_Role = DC.Set<FrameworkUserRole>().Where(y => y.UserCode == x.ITCode)
                        .Join(DC.Set<FrameworkRole>(), ur => ur.RoleCode, role => role.RoleCode, (ur, role) => role).Select(y0=>y0.RoleName).ToSepratedString(null,","),
                    FrameworkUser_Group = DC.Set<FrameworkUserGroup>().Where(y => y.UserCode == x.ITCode)
                        .Join(DC.Set<FrameworkGroup>(), ug => ug.GroupCode, group => group.GroupCode, (ug, group) => group ).Select(y0=>y0.GroupName).ToSepratedString(null,","),
                    FrameworkUser_IsValid = x.IsValid,
                    FrameworkUser_Photo = x.PhotoId,
                })
        .OrderBy(x => x.ID);
    return query;
}
```

## 八、导入用户信息

在 FrameworkUser 类中添加了一个不保存在数据库中的属性 Role，表示角色，因为从前端导出来的数据是可以按角色分好的，所以在本系统中导入的时候指定好角色会很方便，

```c#
[NotMapped]
public string Role { get; set; } // 用于导入时，写入角色
```

然后在对应的 FrameworkUserImportVM 中，修改模板，修改 BatchSaveData 方法：

```c#
public override bool BatchSaveData()
{
    SetEntityList();
    bool ok = true;  // 正确导入标志
    for (var i = 0; i < EntityList.Count; i++)
    {
        var item = EntityList[i];
        var user = DC.Set<FrameworkUser>().SingleOrDefault(x => x.ITCode == item.ITCode);
        if (user != null)  // 数据库中有当前用户
        {
            ok = false;
            ErrorListVM.EntityList.Add(new ErrorMessage { Message = "用户的账号重复！", Index = (i + 2) });  // 加2是因为下标从0开始且有一行表头
            continue;
        }
        item.IsValid = true;
        item.Password = Utils.GetMD5String(item.Password);
        var role = DC.Set<FrameworkRole>().SingleOrDefault(x => x.RoleName == item.Role);
        if (role == null)  // 数据库中没有当前角色
        {
            ok = false;
            ErrorListVM.EntityList.Add(new ErrorMessage { Message = "用户的角色输入错误！", Index = (i+2) });  // 加2是因为下标从0开始且有一行表头
            continue;
        }
        FrameworkUserRole fur = new FrameworkUserRole
        {
            UserCode = item.ITCode,
            RoleCode = role.RoleCode
        };
        DC.Set<FrameworkUserRole>().Add(fur);
    }
    if (ok)
        return base.BatchSaveData();
    return false;
}
```

## 九、设置用户列表搜索框

由于每个用户都会有角色，所以在用户的主页面添加一个角色的下拉框用于搜索。

先在对应的 FrameworkUserSearcher 里添加两个属性：

```c#
[Display(Name = "_Model._FrameworkUser._Role")]
public string Role { get; set; }  // 用作下拉框绑定的字段
public List<string> RoleList { get; set; }  // 下拉框的值的来源

protected override void InitVM()
{
    RoleList = DC.Set<FrameworkRole>().Where(x => x.RoleName != "超级管理员").Select(x => x.RoleName).ToList();  // 初始化赋值，不显示超级管理员的角色
}
```

然后再前端添加一个下拉框：

```html
<wt:combobox field="Searcher.Role" items="Searcher.RoleList" empty-text="@Localizer["Sys.All"]"  />
```

最后在 FrameworkUserListVM 中修改搜索条件：

```c#
public override IOrderedQueryable<FrameworkUser_View> GetSearchQuery()
{
    var query = DC.Set<FrameworkUser>()

        .CheckContain(Searcher.ITCode, x => x.ITCode)
        .CheckContain(Searcher.Name, x => x.Name)
        .CheckEqual(Searcher.IsValid, x => x.IsValid)
        .Where(x => x.ITCode != "admin")
        .Select(x => new FrameworkUser_View
                {
                    ID = x.ID,

                    FrameworkUser_ITCode = x.ITCode,
                    FrameworkUser_Name = x.Name,
                    FrameworkUser_Gender = x.Gender,
                    FrameworkUser_CellPhone = x.CellPhone,
                    FrameworkUser_Role = DC.Set<FrameworkUserRole>().Where(y => y.UserCode == x.ITCode)
                        .Join(DC.Set<FrameworkRole>(), ur => ur.RoleCode, role => role.RoleCode, (ur, role) => role).Select(y0 => y0.RoleName).ToSepratedString(null, ","),
                    FrameworkUser_Group = DC.Set<FrameworkUserGroup>().Where(y => y.UserCode == x.ITCode)
                        .Join(DC.Set<FrameworkGroup>(), ug => ug.GroupCode, group => group.GroupCode, (ug, group) => group).Select(y0 => y0.GroupName).ToSepratedString(null, ","),
                    FrameworkUser_IsValid = x.IsValid,
                    FrameworkUser_Photo = x.PhotoId,

                })
        .OrderBy(x => x.ID);
    if (Searcher.Role == "") return query;  // 没有搜索角色时直接返回
    var t = query.ToList();
    var res = t.Where(x => x.FrameworkUser_Role == Searcher.Role).AsQueryable().OrderBy(x => x.ID);
    return res;
}
```

因为直接在第一句代码中添加条件的话，EF翻译不成功，会报错，所以先使用 ToList() 终结方法，然后再重新翻译一句SQL，达到效果。
