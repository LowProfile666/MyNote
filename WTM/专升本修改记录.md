# 学生信息与用户

## 将学生信息导入到用户中

在导入了学生信息后，通过一个按钮将学生信息导入到用户中。

添加一个按钮，在 StudentListVM 中：

```cs
this.MakeAction("StudentInfo","ImportToUser","批量导入用户","批量导入用户",GridActionParameterTypesEnum.MultiIdWithNull,"Data",500).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-plus"),
```

然后在 StudentInfoController 中实现 ImportToUser 方法：

```cs
[ActionDescription("导入学生信息到用户表中")]
public string ImportToUser(string[] ids)
{
    if (ids.Length == 0)
    {
        ids = DC.Set<StudentInfo>().Select(x => x.ID.ToString()).ToArray();
    }
    foreach (var id in ids)
    {
        StudentInfo stu = DC.Set<StudentInfo>().Single(x => x.ID.ToString() == id);
        
        FrameworkUser user = DC.Set<FrameworkUser>().SingleOrDefault(x => x.ITCode == stu.Sfzh);
        if (user != null) continue;
        user = new FrameworkUser();
        user.ID = new Guid();
        user.ITCode = stu.Sfzh;
        user.Password = Utils.GetMD5String(stu.Sfzh.Substring(12));
        user.Name = stu.Xm;
        user.IsValid = true;
        DC.Set<FrameworkUser>().Add(user);

        FrameworkUserRole userRole = new FrameworkUserRole();
        userRole.ID = Guid.NewGuid();
        userRole.UserCode = user.ITCode;
        userRole.RoleCode = "002";
        DC.Set<FrameworkUserRole>().Add(userRole);
    }
    DC.SaveChanges();
    return "<h1>导入成功！</h1>";
}
```

+ 向用户表中插入数据时，也要向用户角色中间表中插入数据，来指定用户角色
+ 还要考虑如果用户表中已经存在了该学生的账号，就不用再添加
+ 记得使用 DC.SaveChanges(); 提交事务，否则修改不会生效。

以上程序可以使用 AI 优化下：

```cs
[ActionDescription("导入学生信息到用户表中")]
public string ImportToUser(string[] ids)
{
    if (ids.Length == 0)
    {
        ids = DC.Set<StudentInfo>().Select(x => x.ID.ToString()).ToArray();
    }

    var studentInfos = DC.Set<StudentInfo>().Where(x => ids.Contains(x.ID.ToString())).ToList();
    var existingUserIds = DC.Set<FrameworkUser>().Where(x => studentInfos.Select(s => s.Sfzh).Contains(x.ITCode)).Select(x => x.ITCode).ToList();

    var usersToAdd = new List<FrameworkUser>();
    var userRolesToAdd = new List<FrameworkUserRole>();

    foreach (var student in studentInfos)
    {
        if (existingUserIds.Contains(student.Sfzh))
        {
            continue;
        }

        var user = new FrameworkUser
        {
            ID = Guid.NewGuid(),
            ITCode = student.Sfzh,
            Password = Utils.GetMD5String(student.Sfzh.Substring(12)),
            Name = student.Xm,
            IsValid = true
        };

        var userRole = new FrameworkUserRole
        {
            ID = Guid.NewGuid(),
            UserCode = user.ITCode,
            RoleCode = "002"
        };

        usersToAdd.Add(user);
        userRolesToAdd.Add(userRole);
    }

    DC.Set<FrameworkUser>().AddRange(usersToAdd);
    DC.Set<FrameworkUserRole>().AddRange(userRolesToAdd);
    DC.SaveChanges();

    return "<h1>导入成功！</h1>";
}
```



## 全部删除

删除全部的学生信息，方便二次导入。

新建一个按钮，这个按钮会执行一个 js 方法，会提示用户是否确定删除，用户点击确定的话就调用后端的删除方法，在 StudentInfoListVM 中：

```cs
this.MakeAction(null,null,"删除全部信息",null,GridActionParameterTypesEnum.NoId).
    SetShowInRow(false).
    SetHideOnToolBar(false).
    SetIconCls("fa fa-trash").
    SetButtonClass("layui-bg-red").
    SetOnClickScript("deleteAllStudentInfo"),
```

然后在 Data/Views/StudentInfo 下的 index.cshtml 中写一个 js 函数：

```html
<script>
    function deleteAllStudentInfo() {
        var res = confirm("确定删除全部学生信息吗？");
        if (res) {
            $.ajax({
                url: "/StudentInfo/DeleteAllStudentInfo",
                type: "post",
                success(resp) {
                    alert(resp)
                    location.reload();
                }
            })
        }
    }
</script>
```

然后在 \_StudentInfoApiController 中实现方法：删除学生信息的时候，一起删除所有的用户信息和已存在的角色信息，方便第二次导入

```cs
[ActionDescription("删除全部学生和用户信息")]
[HttpPost("/StudentInfo/DeleteAllStudentInfo")]
public string DeleteAllStudentInfo()
{
    DC.Set<StudentInfo>().RemoveRange(DC.Set<StudentInfo>());
    DC.Set<FrameworkUser>().RemoveRange(DC.Set<FrameworkUser>().Where(x => x.ITCode != "admin"));
    DC.Set<FrameworkUserRole>().RemoveRange(DC.Set<FrameworkUserRole>().Where(x => x.UserCode != "admin"));
    DC.SaveChanges();
    return "删除成功！";
}
```





# 材料

## 批量下载（按数据库存储方式）

通过按钮批量下载材料上传中的材料。

要将文件的保存方式改为数据库保存，然后从数据库获取图片的二进制数据，再将数据转为文件返回给浏览器。

改变文件的保存方式，在 appsettings.json 中：

![image-20240229140101354](https://gitee.com/LowProfile666/image-bed/raw/master/img/202402291401207.png)

然后创建对应的下载按钮：

```cs
this.MakeAction("Clsc","BatchDownloadScoreTable",
                "批量下载成绩单","批量下载成绩单",
                GridActionParameterTypesEnum.MultiIdWithNull,
                "Data",500).
    SetShowInRow(false).
    SetHideOnToolBar(false).
    SetIconCls("fa fa-plus").
    SetIsDownload(true),
this.MakeAction("Clsc","BatchDownloadCommitment","批量下载承诺书","批量下载承诺书",GridActionParameterTypesEnum.MultiIdWithNull,"Data",500).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-plus").SetIsDownload(true),
this.MakeAction("Clsc","BatchDownloadApplication","批量下载报名申请表","批量下载报名申请表",GridActionParameterTypesEnum.MultiIdWithNull,"Data",500).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-plus").SetIsDownload(true),
this.MakeAction("Clsc","BatchDownloadReviewApplication","批量下载复查申请表","批量下载复查申请表",GridActionParameterTypesEnum.MultiIdWithNull,"Data",500).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-plus").SetIsDownload(true),
```

+ `SetIsDownload(true)` 设置该按钮是一个下载按钮，下载按钮指向的url应该返回文件

然后写对应的方法：

批量下载成绩单，在 ClscController 中：

```cs
[ActionDescription("批量下载成绩单")]
public ActionResult BatchDownloadScoreTable(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    // 拿到所有的成绩单id
    List<string> scoreIDs = new List<string>();
    // 拿到所用的身份证号
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        scoreIDs.Add(item.CjdId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    // 获取所有的成绩单数据
    List<byte[]> dataList = DC.Set<FileAttachment>().Where(x => scoreIDs.Contains(x.ID.ToString())).Select(x => x.FileData).ToList();


    // 创建一个内存流来存储所有图片数据
    using (MemoryStream zipStream = new MemoryStream())
    {
        // 使用压缩格式创建一个 zip 文件
        using (var zipArchive = new System.IO.Compression.ZipArchive(zipStream, System.IO.Compression.ZipArchiveMode.Create, true))
        {
            for (int i = 0; i < dataList.Count; i++)
            {
                byte[] imageData = dataList[i];

                // 生成新的文件名
                string newFileName = sfzhList[i] + "_cjd.jpg"; // 身份证号_cjd.jpg

                // 将图片数据写入到 zip 文件中
                var zipEntry = zipArchive.CreateEntry(newFileName);
                using (var entryStream = zipEntry.Open())
                {
                    entryStream.Write(imageData, 0, imageData.Length);
                }
            }
        }

        // 将 zip 文件的内容作为响应发送到客户端
        zipStream.Seek(0, SeekOrigin.Begin);

        //return File(zipStream.ToArray(), "application/zip", "批量下载成绩单.zip");

        // 将内存流中的数据转换为字节数组，并将其返回给客户端进行下载
        byte[] zipData = zipStream.ToArray();

        // 返回文件给浏览器进行下载
        return File(zipData, "application/zip", "cjd.zip");
    }
}
```

然后发现其实生成 zip 文件的操作是重复的，所以提取出来单作一个方法：

```cs
// 创建zip文件夹的操作
private ActionResult CreateZIP(List<byte[]> dataList, List<string> sfzhList, string suffix, string zipName)
{
    using (MemoryStream zipStream = new MemoryStream())
    {
        using (var zipArchive = new System.IO.Compression.ZipArchive(zipStream, System.IO.Compression.ZipArchiveMode.Create, true))
        {
            for (int i = 0; i < dataList.Count; i++)
            {
                byte[] imageData = dataList[i];
                string newFileName = sfzhList[i] + suffix;
                var zipEntry = zipArchive.CreateEntry(newFileName);
                using (var entryStream = zipEntry.Open())
                {
                    entryStream.Write(imageData, 0, imageData.Length);
                }
            }
        }

        zipStream.Seek(0, SeekOrigin.Begin);
        byte[] zipData = zipStream.ToArray();
        return File(zipData, "application/zip", zipName);
    }
}
```

+ dataList：所有的图片数据
+ sfzhList：所有的身份证号数据
+ suffix：图片文件的后缀，比如成绩单：`"_cjd.jpg"`
+ zipName：生成的zip文件的名字，比如 `"cjd.zip"`

所以批量下载承诺书就可以这样写：

```cs
[ActionDescription("批量下载承诺书")]
public ActionResult BatchDownloadCommitment(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    List<string> commitmentIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        commitmentIDs.Add(item.CnsId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    List<byte[]> dataList = DC.Set<FileAttachment>().Where(x => commitmentIDs.Contains(x.ID.ToString())).Select(x => x.FileData).ToList();

    return CreateZIP(dataList, sfzhList, "_cns.jpg", "cns.zip");
}
```

批量下载报名申请表：

```cs
[ActionDescription("批量下载报名申请表")]
public ActionResult BatchDownloadApplication(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    // 拿到所有的成绩单id
    List<string> applicationIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        applicationIDs.Add(item.BmsqbId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    // 获取所有的成绩单数据
    List<byte[]> dataList = DC.Set<FileAttachment>().Where(x => applicationIDs.Contains(x.ID.ToString())).Select(x => x.FileData).ToList();

    return CreateZIP(dataList, sfzhList, "_bmsqb.jpg", "报名申请表.zip");
}
```

批量下载复查申请表：

```cs
[ActionDescription("批量下载复查申请表")]
public ActionResult BatchDownloadReviewApplication(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    // 拿到所有的成绩单id
    List<string> reviewIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        reviewIDs.Add(item.CjfcsqId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    // 获取所有的成绩单数据
    List<byte[]> dataList = DC.Set<FileAttachment>().Where(x => reviewIDs.Contains(x.ID.ToString())).Select(x => x.FileData).ToList();

    return CreateZIP(dataList, sfzhList, "_cjfcsqb.jpg", "复查申请表.zip");
}
```

**这种写法在最后会被优化掉**

## 批量下载（按本地存储方式）

[查看后文](#backup)

## 上传材料

上传材料时，将上传的文件改名存在数据库中，改为 "身份证号\_cjd.jpg" 这种形式：

学生上传材料是走到 `_ClscApiController` 中的 Edit 方法，所以再 Edit 方法中修改数据库 FileAttachment 中的 FileName 字段即可：

```cs
[ActionDescription("Sys.Edit")]
[HttpPost]
[ValidateFormItemOnly]
public async Task<ActionResult> Edit(ClscVM vm)
{
    if (!ModelState.IsValid)
    {

        return PartialView(vm.FromView, vm);
    }
    else
    {
        // 材料上传的位置
        await vm.DoEditAsync();

        var cjd = DC.Set<FileAttachment>().SingleOrDefault(x => x.ID == vm.Entity.CjdId);
        var cns = DC.Set<FileAttachment>().SingleOrDefault(x => x.ID == vm.Entity.CnsId);
        var bmsqb = DC.Set<FileAttachment>().SingleOrDefault(x => x.ID == vm.Entity.BmsqbId);
        if (cjd != null) cjd.FileName = Wtm.LoginUserInfo.ITCode + "_cjd.jpg";
        if (cns != null) cns.FileName = Wtm.LoginUserInfo.ITCode + "_cns.jpg";
        if (bmsqb != null) bmsqb.FileName = Wtm.LoginUserInfo.ITCode + "_bmsqb.jpg";
        DC.SaveChanges();  // 修改完要保存修改
        
        if (!ModelState.IsValid)
        {
            vm.DoReInit();
            return PartialView("../Clsc/Edit", vm);
        }
        else
        {
            return FFResult().CloseDialog().RefreshGridRow(CurrentWindowId);
        }
    }
}
```

这样后，下载单个学生的材料时的文件名字就是统一格式的名字，另外这样的话批量下载文件时也不需要专门的改名了，但是原来的程序已经写好了就不再去修改了。

# 数据分析

使用 echarts 展示每个专业的报考人数。

新建一个页面：DataAnalysis.cshtml ：

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>数据分析</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.5.0/dist/echarts.min.js"></script>
</head>
<body>  
    <!-- 为 ECharts 准备一个定义了宽高的 DOM -->
    <div id="majorCount" style="width: auto;height:400px;"></div>
    <!-- 每个省份的报名人数 -->
    <!-- 每个专业的报考人数 -->
    <script type="text/javascript">
        // 基于准备好的dom，初始化echarts实例
        var myChart = echarts.init(document.getElementById('majorCount'));
        // 指定图表的配置项和数据
        var option = {
            title: {
                text: '专业报考人数'
            },
            tooltip: {},
            legend: {
                data: ['人数']
            },
            xAxis: {
                data: []
            },
            yAxis: {},
            series: [
                {
                    name: '人数',
                    type: 'bar',
                    data: []
                }
            ]
        };
        $.ajax({
            url: "/DataAnalysis/GetAllMajors/",
            type: 'get',
            success(resp) {
               var keys = Object.entries(resp).map(([key, value]) => key);
               var values = Object.entries(resp).map(([key, value]) => value);
               option["xAxis"].data = keys.map(key => key.substring(0, 3)+"...");
               option["series"][0].data = values;
                // 使用刚指定的配置项和数据显示图表。
                myChart.setOption(option);
            }
        });
    </script>
</body>
</html>
```

然后在 Data 中新建一个 AnalysisController.cs 控制器：

```cs
using Microsoft.AspNetCore.Mvc;
using System.Collections.Generic;
using System.Data;
using System.Linq;
using WalkingTec.Mvvm.Core;
using WalkingTec.Mvvm.Mvc;
using ZsbManagment.Model.Data;

namespace ZsbManagment.Areas.Data.Controllers
{
    public class AnalysisController : BaseController
    {
        [ActionDescription("数据分析页面", IsPage = true)]
        public ActionResult Index(string id)
        {
            return View("/Areas/Data/Views/DataAnalysis.html");
        }

        [ActionDescription("获取所有报考专业")]
        [HttpGet("/DataAnalysis/GetAllMajors")]
        public Dictionary<string,int> GetAllMajors()
        {
            Dictionary<string, int> res = new Dictionary<string, int>();
            var majors = DC.Set<StudentInfo>().Select(x => x.Bkzy).Distinct().ToList();
            foreach (var major in majors)
            {
                int count = DC.Set<StudentInfo>().Where(x => x.Bkzy == major).Count();
                res.Add(major, count);
            }
            return res;
        }
    }
}
```

![image-20240301150317950](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403011503107.png)

```html
<title>数据分析</title>
<style>
    .count {
        width: 100%;
        height: 50px;
        background-color: #16b777;
        margin-bottom:10px;
        border-radius: 5px;
        text-align: center;
        line-height:50px;
        font-weight: bolder;
    }
</style>

<div class="layui-row layui-col-space5">
    <div class="layui-col-lg12">
        <div id="studentCount" class="count"></div>
    </div>
</div>
<div class="layui-row">
    <div class="layui-col-lg6">
        <div id="studentType" style="width: 100%;height:400px;"></div>
    </div>
    <div class="layui-col-lg6">
        <div id="studentSex" style="width: 100%;height:400px;"></div>
    </div>
</div>
<div class="layui-row">
    <div class="layui-col-lg12">
        <div id="majorCount" style="width: 100%;height:400px;"></div>
    </div>
</div>

<script type="text/javascript">

    // 基于准备好的dom，初始化echarts实例
    var majorCountChart = echarts.init(document.getElementById('majorCount'));
    let studentTypeChart = echarts.init(document.getElementById('studentType'));
    let studentSexChart = echarts.init(document.getElementById('studentSex'));
    // 指定图表的配置项和数据
    var barOption = {
        title: {
            text: '各专业报考人数统计'
        },
        tooltip: {},
        legend: {
            data: ['人数']
        },
        xAxis: {
            data: []
        },
        yAxis: {},
        series: [
            {
                name: '人数',
                type: 'bar',
                data: []
            }
        ]
    };
    let pieOption = {
        title: {
            text: "报考类型人数统计"
        },
        tooltip: {
            trigger: 'item'
        },
        legend: {
            top: '5%',
            left: 'center'
        },
        series: [
            {
                name: '报考学生人数',
                type: 'pie',
                radius: ['40%', '70%'],
                avoidLabelOverlap: false,
                label: {
                    show: false,
                    position: 'center'
                },
                emphasis: {
                    label: {
                        show: true,
                        fontSize: 20,
                        fontWeight: 'bold'
                    }
                },
                labelLine: {
                    show: false
                },
                data: []
            }
        ]
    };
    $.ajax({
        url: "/DataAnalysis/GetAllMajors/",
        type: 'get',
        success(resp) {
            var keys = Object.entries(resp).map(([key, value]) => key);
            var values = Object.entries(resp).map(([key, value]) => value);
            barOption["xAxis"].data = keys.map(key => key.substring(0, 3) + "...");
            barOption["series"][0].data = values;
            // 使用刚指定的配置项和数据显示图表。
            majorCountChart.setOption(barOption);
        }
    });
    $.ajax({
        url: "/DataAnalysis/GetStudentTypeCount",
        type: 'get',
        success(resp) {
            pieOption["series"][0].data = Object.keys(resp).map(function (key) {
                return {
                    name: key,
                    value: resp[key]
                };
            });

            studentTypeChart.setOption(pieOption);
        }
    })

    $.ajax({
        url: "/DataAnalysis/GetStudentSexCount",
        type: 'get',
        success(resp) {
            pieOption["series"][0].data = Object.keys(resp).map(function (key) {
                return {
                    name: key,
                    value: resp[key]
                };
            });
            pieOption["series"][0].itemStyle = {
                borderRadius: 10,
                borderColor: '#fff',
                borderWidth: 2
            };
            pieOption.title.text = "报考男女人数统计";
            studentSexChart.setOption(pieOption);
        }
    })

    $.ajax({
        url: "/DataAnalysis/GetStudentCount",
        type: 'get',
        success(resp) {
            $("#studentCount").html(`报考本校总人数：${resp} 人`);
        }
    })
    // 在窗口大小变化时调用Echart的resize方法
    function resizeChart() {
        majorCountChart.resize();
    }

    // 监听窗口大小变化事件，并调用resizeChart函数
    $(window).resize(resizeChart);
</script>
```

```cs
[ActionDescription("数据分析页面", IsPage = true)]
public ActionResult Index(string id)
{
    return View("/Areas/Data/Views/DataAnalysis.cshtml");  // 直接用html页面可能会有问题
}

[ActionDescription("获取所有报考专业")]
[HttpGet("/DataAnalysis/GetAllMajors")]
public Dictionary<string,int> GetAllMajors()
{
    Dictionary<string, int> res = new Dictionary<string, int>();
    var majors = DC.Set<StudentInfo>().Select(x => x.Bkzy).Distinct().ToList();
    foreach (var major in majors)
    {
        int count = DC.Set<StudentInfo>().Where(x => x.Bkzy == major).Count();
        res.Add(major, count);
    }
    return res;
}

[ActionDescription("获取所有报考类型的人数")]
[HttpGet("/DataAnalysis/GetStudentTypeCount")]
public Dictionary<string, int> GetStudentTypeCount()
{
    Dictionary<string, int> res = new Dictionary<string, int>();
    var types = DC.Set<StudentInfo>().Select(x => x.Kslx).Distinct().ToList();
    foreach (var type in types)
    {
        int count = DC.Set<StudentInfo>().Where(x => x.Kslx == type).Count();
        res.Add(type, count);
    }
    return res;
}

[ActionDescription("获取所有毕业院校的人数")]
[HttpGet("/DataAnalysis/GetStudentFromCount")]
public Dictionary<string, int> GetStudentFromCount()
{
    Dictionary<string, int> res = new Dictionary<string, int>();
    var types = DC.Set<StudentInfo>().Select(x => x.Byxx).Distinct().ToList();
    foreach (var type in types)
    {
        int count = DC.Set<StudentInfo>().Where(x => x.Byxx == type).Count();
        res.Add(type, count);
    }
    return res;
}

[ActionDescription("获取所有考生的男女人数")]
[HttpGet("/DataAnalysis/GetStudentSexCount")]
public Dictionary<string, int> GetStudentSexCount()
{
    Dictionary<string, int> res = new Dictionary<string, int>();

    int count = DC.Set<StudentInfo>().Where(x => x.Xb == "男").Count();
    res.Add("男", count);
    count = DC.Set<StudentInfo>().Count() - count;
    res.Add("女", count);

    return res;
}

[ActionDescription("获取所有各个民族的考生人数")]
[HttpGet("/DataAnalysis/GetStudentEthnicCount")]
public Dictionary<string, int> GetStudentEthnicCount()
{
    Dictionary<string, int> res = new Dictionary<string, int>();
    var ethics = DC.Set<StudentInfo>().Select(x => x.Mz).Distinct().ToList();
    foreach (var ethic in ethics)
    {
        int count = DC.Set<StudentInfo>().Where(x => x.Mz == ethic).Count();
        res.Add(ethic, count);
    }
    return res;
}

[ActionDescription("获取所有考生人数")]
[HttpGet("/DataAnalysis/GetStudentCount")]
public int GetStudentCount()
{
    return DC.Set<StudentInfo>().Count();
}
```

# 用户不能修改密码

“管理员”可以修改密码，“用户”不能自己修改密码，当一个账号的角色是“用户”时，隐藏右上角名字下的修改密码选项。

![image-20240301110031328](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403011102206.png)

找到 Views/Home 下的 Layout.cshtml 文件，找到 ChangePassword 关键字，这是修改密码的选项，使用 cs 代码判断当前登录用户的角色，如果是“用户”角色，那么就将该选项通过 jQuery 隐藏：

```cs
<dd>
    <wt:linkbutton url="/Login/ChangePassword" window-width="400" text="@Model.Localizer["Login.ChangePassword"]" is-link="true" id="ChangePasswordLink"/>
    @{
        if (Model.LoginUserInfo.Roles[0].RoleCode == "002")
        {
            <script>
                $("#ChangePasswordLink").hide();
            </script>
        }
    }
</dd>
```

+ “用户”角色的代码是 002

# 侧边菜单缩进

在 Views/Home 下的 Layout.cshtml 中找到侧边菜单的部分，给二级菜单项加一个类，用来控制样式，使用左内边距来达到一个缩进的效果：

```html
<style type="text/css" scoped>
    .children-menu-item-2 {
        margin-left: 20px;
    }
    .children-menu-item-3 {
        margin-left: 20px;
    }
</style>
<dd data-name="{{ item2.name || '' }}" data-jump="{{ item2.jump || '' }}" class="children-menu-item-2">
    <a href="javascript:;" {{ hasChildren2 ? '' : 'lay-href="'+ url2 +'"' }}>
        <i class="{{ item2.icon }}"></i>
        <cite>{{ item2.title }}</cite>
    </a>
    {{# if(hasChildren2){ }}
    <dl class="layui-nav-child">
        {{# layui.each(item2.list, function(index3, item3){
        var url3 = (item3.jump && typeof item3.jump === 'string')
        ? item3.jump
        : [item.name, item2.name, item3.name].join('/')
        }}
        <dd data-name="{{ item3.name || '' }}" data-jump="{{ item3.jump || '' }}" class="children-menu-item-3">
            <a href="javascript:;" lay-href="{{ url3 }}" {{ item3.iframe ? 'lay-iframe="true"' : '' }} style="padding-left:45px">
                <i class="{{ item3.icon }}"></i>
                <cite>{{ item3.title }}</cite>
            </a>
        </dd>
        {{# }); }}
    </dl>
    {{# } }}
</dd>
```

![image-20240301133224470](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403011332599.png)

# 批量修改密码

指定前缀、后缀以及取电话号码后多少位。

先在用户列表上面添加一个按钮，这个按钮用来修改所有用户的密码，在 FramworkUserListVM 中：

```cs
this.MakeAction(null,null,"批量修改密码",null,GridActionParameterTypesEnum.NoId).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-edit").SetButtonClass("layui-bg-blue").SetOnClickScript("batchChangePassword"),
```

通过自己写的 js 函数 batchChangePassword 来打开一个对话框，输入前缀、后缀，在 \_Admin/Views/FrameworkUser/index.cshtml 中添加脚本：

```cs
<style>
    .layui-inline {
        width: 300px;
        margin-left: 12px;
        margin-bottom: 10px;
    }
</style>
<script>
    function batchChangePassword() {
        layui.use('layer', function(){
            var layer = layui.layer;
            layer.open({
                type: 1,
                area: ['320px', '310px'], // 宽高
                title: "格式化所有密码",
                content: `
                        <form class="layui-form layui-form-pane">
                            <div>
                                <div class="layui-inline" style="margin-top:10px">
                                  <label class="layui-form-label" for="prefix">密码前缀</label>
                                  <div class="layui-input-inline">
                                    <input type="text" name="prefix" autocomplete="off" class="layui-input" id="prefix">
                                  </div>
                                </div>
                                <div class="layui-inline" >
                                    <label class="layui-form-label" for="number" style="font-size:11px">手机号码后几位</label>
                                    <div class="layui-input-inline">
                                        <input type="text" name="number" autocomplete="off" class="layui-input" id="number">
                                    </div>
                                </div>
                                <div class="layui-inline" >
                                    <label class="layui-form-label" for="suffix">密码后缀</label>
                                    <div class="layui-input-inline">
                                        <input type="text" name="suffix" autocomplete="off" class="layui-input" id="suffix">
                                    </div>
                                </div>

                                <div class="layui-inline">
                                    <button class="layui-btn layui-btn-primary layui-border-green" id="generate" style="width:107px">生成示例</button>
                                    <div class="layui-input-inline">
                                                <input type="text" name="password" autocomplete="off" class="layui-input" id="password" disabled value="15760656503">
                                    </div>
                                </div>
                                <div class="layui-inline" style="text-align:center">
                                    <button type="button" id="submitBtn" class="layui-btn layui-btn-radius">提交</button>
                                </div> 
                            </div>
                        </form>
                `
            });
            $("#generate").on("click", e => {
                e.preventDefault();
                let mid = "15760656503";
                let prefix = $("#prefix").val();
                let suffix = $("#suffix").val();
                let number = $("#number").val();
                if (number <= 0)    number = 11;
                if (number !== "" && number !== undefined && number < mid.length) {
                    mid = mid.substring(mid.length - number);
                }
                $("#password").val(prefix + mid + suffix);
            })
            $("#submitBtn").on('click', e => {
                e.preventDefault();
                $.ajax({
                    url: "/FramworkUser/BatchChangePassword",
                    type: "post",
                    data: {
                        prefix: $("#prefix").val(),
                        suffix: $("#suffix").val(),
                        number: $("#number").val(),
                    },
                    success(resp) {
                        alert(resp);
                    }
                })
            })
        })
    }
    
</script>
```

然后在 \_FrameworkUserContrApiController 中添加接口：

```cs
[ActionDescription("格式化所有密码")]
[HttpPost("/FramworkUser/BatchChangePassword")]
public string BatchChangePassword(string prefix, string suffix, int number)
{
    if (number <= 0)
        number = 11;
    var users = DC.Set<FrameworkUser>().Where(x => x.ITCode != "admin").ToList();
    List<string> newPasswords = new List<string>();
    foreach (var user in users)
    {
        if (user.CellPhone == null || user.CellPhone.Length == 0)
            return "学生" + user.Name + "缺少电话号码！";
        if (number > user.ITCode.Length)
            return "电话号码长度不够！";
        user.Password = Utils.GetMD5String(prefix + user.CellPhone.Substring(user.CellPhone.Length - number) + suffix);
    }
    DC.SaveChanges();
    return "修改成功！";
}
```

# 部署

需要安装IIS（Internet Information Services）并进行配置。以下是在Windows上安装IIS的一般步骤：

1. 打开控制面板并选择“程序”或“程序和功能”。
2. 在左侧菜单中，选择“打开或关闭Windows功能”。
3. 在“Windows功能”对话框中，找到并展开“Internet Information Services”。
4. 找到并勾选“Web管理工具”和“World Wide Web服务”，如果需要还可以选择其他相关功能，如FTP服务器等。
5. 点击“确定”并等待安装完成。

![image-20240301192955357](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403012004965.png)

安装完成后，这时候在浏览器中输入 localhost 可以看到以下界面，说明iis安装成功了：

![image-20240301200603726](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403012006918.png)

可以在开始菜单中搜索 IIS，然后打开：

![image-20240301200515755](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403012005920.png)

然后双击图中的 “模块” ，查看是否有 AspNetCoreModuleV2：

![image-20240301200730399](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403012007564.png)

如果没有的话需要安装 .NET Core Windows Server Hosting，[安装地址](https://dotnet.microsoft.com/en-us/download/dotnet/thank-you/runtime-aspnetcore-8.0.2-windows-hosting-bundle-installer)。

然后右键单击 “网站”，开始创建网站：

![image-20240301201020961](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403012010136.png)

+ 网站名称只是个名称，随意
+ 物理路径选择发布后的项目的 publish 路径
+ 主机名是用来访问的名字

点击确定后，有个应用程序池需要配置，配置上面这个网站用到的应用程序池 zsb：

![image-20240301201235824](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403012012994.png)

然后访问网站：会出现502错误

一直 502 不知道为啥。。。

[参考文章1](https://zhuanlan.zhihu.com/p/353988800)

[参考文章2](https://www.cnblogs.com/dotnet261010/p/12151618.html)

如果想要在外网访问的话，需要开通防火墙的端口。



# 备份上一次的材料

<span id="backup">将项目部署到服务器上后，使用批量下载材料的时候会报错，才想起来是因为，之前的图片都存在服务器本地中，并不是存在数据库中，数据库中只有一个图片的路径，所以程序需要修改，修改一些地方就可，从数据库中拿到图片的地址，然后通过这个地址再将图片拿到，放入一个压缩包中。</span> 

原来的代码不删除，直接新加四个按钮：在 ClscListVM 中

```cs
this.MakeAction("Clsc","BatchDownloadScoreTableByPath","批量下载成绩单","批量下载成绩单",GridActionParameterTypesEnum.MultiIdWithNull,"Data",500).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-arrow-circle-down").SetIsDownload(true).SetButtonClass("layui-bg-green"),
this.MakeAction("Clsc","BatchDownloadCommitmentByPath","批量下载承诺书","批量下载承诺书",GridActionParameterTypesEnum.MultiIdWithNull,"Data",500).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-arrow-circle-down").SetIsDownload(true).SetButtonClass("layui-bg-green"),
this.MakeAction("Clsc","BatchDownloadApplicationByPath","批量下载报名申请表","批量下载报名申请表",GridActionParameterTypesEnum.MultiIdWithNull,"Data",500).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-arrow-circle-down").SetIsDownload(true).SetButtonClass("layui-bg-green"),
this.MakeAction("Clsc","BatchDownloadReviewApplicationByPath","批量下载复查申请表","批量下载复查申请表",GridActionParameterTypesEnum.MultiIdWithNull,"Data",500).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-arrow-circle-down").SetIsDownload(true).SetButtonClass("layui-bg-green"),
```

然后创建四个新的方法：在 ClscController 中：

```cs
private ActionResult CreateZIPByPath(List<string> filePaths, List<string> sfzhList, string suffix, string zipName)
{
    using (MemoryStream zipStream = new MemoryStream())
    {
        using (var zipArchive = new System.IO.Compression.ZipArchive(zipStream, System.IO.Compression.ZipArchiveMode.Create, true))
        {
            for (int i = 0; i < filePaths.Count; i++)
            {
                string filePath = filePaths[i];
                string fileName = Path.GetFileName(filePath);
                string newFileName = sfzhList[i] + suffix;
                var zipEntry = zipArchive.CreateEntry(newFileName);
                using (var entryStream = zipEntry.Open())
                {
                    byte[] fileBytes = System.IO.File.ReadAllBytes(filePath);
                    entryStream.Write(fileBytes, 0, fileBytes.Length);
                }
            }
        }

        zipStream.Seek(0, SeekOrigin.Begin);
        byte[] zipData = zipStream.ToArray();
        return File(zipData, "application/zip", zipName);
    }
}

[ActionDescription("根据路径批量下载复查申请表")]
public ActionResult BatchDownloadReviewApplicationByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    // 拿到所有的成绩单id
    List<string> reviewIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        reviewIDs.Add(item.CjfcsqId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    // 获取所有的成绩单数据
    List<string> filePaths = DC.Set<FileAttachment>().Where(x => reviewIDs.Contains(x.ID.ToString())).Select(x => x.Path).ToList();

    return CreateZIPByPath(filePaths, sfzhList, "_cjfcsqb.jpg", "复查申请表.zip");
}
[ActionDescription("根据路径批量下载报名申请表")]
public ActionResult BatchDownloadApplicationByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    // 拿到所有的报名申请表id
    List<string> applicationIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        applicationIDs.Add(item.BmsqbId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    // 获取所有的报名申请表文件路径
    List<string> filePaths = DC.Set<FileAttachment>().Where(x => applicationIDs.Contains(x.ID.ToString())).Select(x => x.Path).ToList();

    return CreateZIPByPath(filePaths, sfzhList, "_bmsqb.jpg", "报名申请表.zip");
}

[ActionDescription("根据路径批量下载承诺书")]
public ActionResult BatchDownloadCommitmentByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    List<string> commitmentIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        commitmentIDs.Add(item.CnsId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    List<string> filePaths = DC.Set<FileAttachment>().Where(x => commitmentIDs.Contains(x.ID.ToString())).Select(x => x.Path).ToList();

    return CreateZIPByPath(filePaths, sfzhList, "_cns.jpg", "承诺书.zip");
}

[ActionDescription("根据路径批量下载成绩单")]
public ActionResult BatchDownloadScoreTableByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    // 拿到所有的成绩单id
    List<string> scoreIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        scoreIDs.Add(item.CjdId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    // 获取所有的成绩单文件路径
    List<string> filePaths = DC.Set<FileAttachment>().Where(x => scoreIDs.Contains(x.ID.ToString())).Select(x => x.Path).ToList();

    return CreateZIPByPath(filePaths, sfzhList, "_cjd.jpg", "成绩单.zip");
}
```

然后在系统中，就可以使用菜单权限的控制来控制通过哪种方法来下载图片，方便了如果修改了图片的存储方式的情况，就不需要再写代码。

![image-20240302084922531](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403020851151.png)

+ 根据路径批量下载：就是用于上传文件的保存方式是本地
+ 其他的批量下载：就是用于上传文件保存方式是数据库

**这种写法在后面会被优化**

## 名字与图片不匹配

以上程序部署到了服务器上后，出现了一个问题，下载下的文件的名字和图片内容不匹配，这是因为获取每个文件路径的时候，因为数据表 Clsc 中并不是所有的数据都有 Cjfcbid 字段，所以就会出现错位，接下来将代码改为执行自定义 sql 语句：

```sql
SELECT c.Sfzh, c.CjfcsqId,f.Path FROM `clscs` c 
left JOIN fileattachments f on f.ID = c.CjfcsqId
where c.CjfcsqId is not null
```

同时，为了提高效率，可以将操作改为异步操作：

```cs
private async Task<ActionResult> CreateZIPByPathAsync(List<string> filePaths, List<string> sfzhList, string suffix, string zipName)
{
    using (MemoryStream zipStream = new MemoryStream())
    {
        using (var zipArchive = new System.IO.Compression.ZipArchive(zipStream, System.IO.Compression.ZipArchiveMode.Create, true))
        {
            for (int i = 0; i < filePaths.Count; i++)
            {
                string filePath = filePaths[i];
                string fileName = Path.GetFileName(filePath);
                string newFileName = sfzhList[i] + suffix;
                var zipEntry = zipArchive.CreateEntry(newFileName);
                using (var entryStream = zipEntry.Open())
                {
                    byte[] fileBytes = await System.IO.File.ReadAllBytesAsync(filePath);
                    await entryStream.WriteAsync(fileBytes, 0, fileBytes.Length);
                }
            }
        }

        zipStream.Seek(0, SeekOrigin.Begin);
        byte[] zipData = zipStream.ToArray();
        return File(zipData, "application/zip", zipName);
    }
}

[ActionDescription("根据路径批量下载复查申请表")]
public async Task<ActionResult> BatchDownloadReviewApplicationByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的成绩单数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CjfcsqId equals f.ID
        where c.CjfcsqId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, c.CjfcsqId, f.Path };

    List<string> filePaths = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        filePaths.Add(item.Path);
        sfzhList.Add(item.Sfzh);
    }

    return await CreateZIPByPathAsync(filePaths, sfzhList, "_cjfcsqb.jpg", "复查申请表.zip");
}

[ActionDescription("根据路径批量下载报名申请表")]
public async Task<ActionResult> BatchDownloadApplicationByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    // 拿到所有的报名申请表id
    List<string> applicationIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        if (item.BmsqbId == null)
        {
            Console.WriteLine("输出：BmsqbId为空");
            continue;
        }
        applicationIDs.Add(item.BmsqbId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    // 获取所有的报名申请表文件路径
    List<string> filePaths = DC.Set<FileAttachment>().Where(x => applicationIDs.Contains(x.ID.ToString())).Select(x => x.Path).ToList();

    return await CreateZIPByPathAsync(filePaths, sfzhList, "_bmsqb.jpg", "报名申请表.zip");
}

[ActionDescription("根据路径批量下载承诺书")]
public async Task<ActionResult> BatchDownloadCommitmentByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    List<string> commitmentIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        if (item.CnsId == null)
        {
            Console.WriteLine("输出：CnsId为空");
            continue;
        }
        commitmentIDs.Add(item.CnsId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    List<string> filePaths = DC.Set<FileAttachment>().Where(x => commitmentIDs.Contains(x.ID.ToString())).Select(x => x.Path).ToList();

    return await CreateZIPByPathAsync(filePaths, sfzhList, "_cns.jpg", "承诺书.zip");
}

[ActionDescription("根据路径批量下载成绩单")]
public async Task<ActionResult> BatchDownloadScoreTableByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    // 拿到所有的成绩单id
    List<string> scoreIDs = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var id in ids)
    {
        var item = DC.Set<Clsc>().Single(x => x.ID.ToString() == id);
        if (item.CjdId == null)
        {
            Console.WriteLine("输出：CjdId为空");
            continue;
        }
        scoreIDs.Add(item.CjdId.ToString());
        sfzhList.Add(item.Sfzh);
    }
    // 获取所有的成绩单文件路径
    List<string> filePaths = DC.Set<FileAttachment>().Where(x => scoreIDs.Contains(x.ID.ToString())).Select(x => x.Path).ToList();

    return await CreateZIPByPathAsync(filePaths, sfzhList, "_cjd.jpg", "成绩单.zip");
}
```

然后会报错：Array dimensions exceeded supported range.，这个错误通常发生在尝试创建超过.NET支持的最大尺寸的数组时。所以修改：

```cs
private async Task<ActionResult> CreateZIPByPathAsync(List<string> filePaths, List<string> sfzhList, string suffix, string zipName)
{
    // 创建临时文件
    string tempFile = Path.GetTempFileName();
    using (FileStream zipStream = new FileStream(tempFile, FileMode.Create))
    {
        using (var zipArchive = new System.IO.Compression.ZipArchive(zipStream, System.IO.Compression.ZipArchiveMode.Create, true))
        {
            for (int i = 0; i < filePaths.Count; i++)
            {
                string filePath = filePaths[i];
                string fileName = Path.GetFileName(filePath);
                string newFileName = sfzhList[i] + suffix;
                var zipEntry = zipArchive.CreateEntry(newFileName);
                using (var entryStream = zipEntry.Open())
                {
                    byte[] fileBytes = await System.IO.File.ReadAllBytesAsync(filePath);
                    await entryStream.WriteAsync(fileBytes, 0, fileBytes.Length);
                }
            }
        }
    }

    // 读取临时文件的内容
    byte[] zipData = await System.IO.File.ReadAllBytesAsync(tempFile);

    // 删除临时文件
    System.IO.File.Delete(tempFile);

    return File(zipData, "application/zip", zipName);
}
```

然后报错：The file is too long. This operation is currently limited to supporting files less than 2 gigabytes in size.这个错误是由于.NET的限制，它不支持大于2GB的文件操作。

然后使用第三方库，下载第三方库 DotNetZip，：

```cs
private async Task<ActionResult> CreateZIPByPathAsync(List<string> filePaths, List<string> sfzhList, string suffix, string zipName)
{
    // 创建临时文件
    string tempFile = Path.GetTempFileName();
    using (Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
    {
        zip.UseZip64WhenSaving = Ionic.Zip.Zip64Option.Always;
        for (int i = 0; i < filePaths.Count; i++)
        {
            string filePath = filePaths[i];
            string newFileName = sfzhList[i] + suffix;
            zip.AddFile(filePath, newFileName);
        }
        await Task.Run(() => zip.Save(tempFile));
    }

    // 直接从文件系统中返回文件
    return new FileStreamResult(new FileStream(tempFile, FileMode.Open, FileAccess.Read), "application/zip")
    {
        FileDownloadName = zipName
    };
}
```

这个写法可以将 6.7g 的压缩包在三分钟左右下好，但是生成的压缩包中全是以身份证号命名的二级文件夹，在二级文件夹下才是对应的图片：

![image-20240302134820033](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403021348294.png)



改成这样：

```cs
private async Task<ActionResult> CreateZIPByPathAsync(List<string> filePaths, List<string> sfzhList, string suffix, string zipName)
{
    // 创建临时文件
    string tempFile = Path.GetTempFileName();
    using (Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
    {
        zip.UseZip64WhenSaving = Ionic.Zip.Zip64Option.Always;
        for (int i = 0; i < filePaths.Count; i++)
        {
            string filePath = filePaths[i];
            string newFileName = sfzhList[i] + suffix;
            // 只添加文件名，不添加路径
            zip.AddEntry(newFileName, System.IO.File.ReadAllBytes(filePath));
        }
        await Task.Run(() => zip.Save(tempFile));
    }

    // 直接从文件系统中返回文件
    return new FileStreamResult(new FileStream(tempFile, FileMode.Open, FileAccess.Read), "application/zip")
    {
        FileDownloadName = zipName
    };
}
```

## 最终版

这是从数据库中读取文件的路径，再去读取文件：按路径下载

```cs
private async Task<ActionResult> CreateZIPByPathAsync(List<string> filePaths, List<string> sfzhList, string suffix, string zipName)
{
    // 创建临时文件
    string tempFile = Path.GetTempFileName();
    using (Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
    {
        zip.UseZip64WhenSaving = Ionic.Zip.Zip64Option.Always;
        for (int i = 0; i < filePaths.Count; i++)
        {
            string filePath = filePaths[i];
            string newFileName = sfzhList[i] + suffix;
            // 只添加文件名，不添加路径
            zip.AddEntry(newFileName, System.IO.File.ReadAllBytes(filePath));
        }
        await Task.Run(() => zip.Save(tempFile));
    }

    // 直接从文件系统中返回文件
    return new FileStreamResult(new FileStream(tempFile, FileMode.Open, FileAccess.Read), "application/zip")
    {
        FileDownloadName = zipName
    };
}

[ActionDescription("根据路径批量下载复查申请表")]
public async Task<ActionResult> BatchDownloadReviewApplicationByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的成绩单数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CjfcsqId equals f.ID
        where c.CjfcsqId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, c.CjfcsqId, f.Path };

    List<string> filePaths = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        filePaths.Add(item.Path);
        sfzhList.Add(item.Sfzh);
    }

    return await CreateZIPByPathAsync(filePaths, sfzhList, "_cjfcsqb.jpg", "复查申请表.zip");
}

[ActionDescription("根据路径批量下载报名申请表")]
public async Task<ActionResult> BatchDownloadApplicationByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的报名申请表数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.BmsqbId equals f.ID
        where c.BmsqbId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, c.BmsqbId, f.Path };

    List<string> filePaths = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        filePaths.Add(item.Path);
        sfzhList.Add(item.Sfzh);
    }

    return await CreateZIPByPathAsync(filePaths, sfzhList, "_bmsqb.jpg", "报名申请表.zip");
}


[ActionDescription("根据路径批量下载承诺书")]
public async Task<ActionResult> BatchDownloadCommitmentByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的承诺书数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CnsId equals f.ID
        where c.CnsId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, c.CnsId, f.Path };

    List<string> filePaths = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        filePaths.Add(item.Path);
        sfzhList.Add(item.Sfzh);
    }

    return await CreateZIPByPathAsync(filePaths, sfzhList, "_cns.jpg", "承诺书.zip");
}

[ActionDescription("根据路径批量下载成绩单")]
public async Task<ActionResult> BatchDownloadScoreTableByPath(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的成绩单数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CjdId equals f.ID
        where c.CjdId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, c.CjdId, f.Path };

    List<string> filePaths = new List<string>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        filePaths.Add(item.Path);
        sfzhList.Add(item.Sfzh);
    }

    return await CreateZIPByPathAsync(filePaths, sfzhList, "_cjd.jpg", "成绩单.zip");
}
```

生成 6.5g 的报名申请表压缩包用了 2 分半。

生成 530m 的复查申请表压缩包用了 10 秒。

生成 5.1g 的成绩单压缩包用了 1分55秒。

生成 824m 的承诺书压缩包用了 20 秒。

按数据库存储文件的话，最终版：

```cs
// 创建zip文件夹的操作
private ActionResult CreateZIP(List<byte[]> dataList, List<string> sfzhList, string suffix, string zipName)
{
    using (MemoryStream zipStream = new MemoryStream())
    {
        using (var zipArchive = new System.IO.Compression.ZipArchive(zipStream, System.IO.Compression.ZipArchiveMode.Create, true))
        {
            for (int i = 0; i < dataList.Count; i++)
            {
                byte[] imageData = dataList[i];
                if (imageData == null) return View("当前没有按数据库存储文件！");
                string newFileName = sfzhList[i] + suffix;
                var zipEntry = zipArchive.CreateEntry(newFileName);
                using (var entryStream = zipEntry.Open())
                {
                    entryStream.Write(imageData, 0, imageData.Length);
                }
            }
        }

        zipStream.Seek(0, SeekOrigin.Begin);
        byte[] zipData = zipStream.ToArray();
        return File(zipData, "application/zip", zipName);
    }
}

[ActionDescription("批量下载复查申请表")]
public ActionResult BatchDownloadReviewApplication(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的成绩单数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CjfcsqId equals f.ID
        where c.CjfcsqId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, c.CjfcsqId, f.FileData };

    List<byte[]> dataList = new List<byte[]>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        dataList.Add(item.FileData);
        sfzhList.Add(item.Sfzh);
    }

    return CreateZIP(dataList, sfzhList, "_cjfcsqb.jpg", "复查申请表.zip");
}

[ActionDescription("批量下载报名申请表")]
public ActionResult BatchDownloadApplication(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的报名申请表数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.BmsqbId equals f.ID
        where c.BmsqbId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, c.BmsqbId, f.FileData };

    List<byte[]> dataList = new List<byte[]>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        dataList.Add(item.FileData);
        sfzhList.Add(item.Sfzh);
    }

    return CreateZIP(dataList, sfzhList, "_bmsqb.jpg", "报名申请表.zip");
}

[ActionDescription("批量下载承诺书")]
public ActionResult BatchDownloadCommitment(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的承诺书数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CnsId equals f.ID
        where c.CnsId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, c.CnsId, f.FileData };

    List<byte[]> dataList = new List<byte[]>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        dataList.Add(item.FileData);
        sfzhList.Add(item.Sfzh);
    }

    return CreateZIP(dataList, sfzhList, "_cns.jpg", "承诺书.zip");
}

[ActionDescription("批量下载成绩单")]
public ActionResult BatchDownloadScoreTable(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的成绩单数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CjdId equals f.ID
        where c.CjdId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, c.CjdId, f.FileData };

    List<byte[]> dataList = new List<byte[]>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        dataList.Add(item.FileData);
        sfzhList.Add(item.Sfzh);
    }

    return CreateZIP(dataList, sfzhList, "_cjd.jpg", "成绩单.zip");
}
```

该方式没有经受过 5000 张照片的考验，以后可能需要修改。

**以下是最终优化**

# 材料下载终极版

每一张图片，在数据库中 fileAttachments 表中都有两个字段：Path 和 FileData，Path 是本地保存方式的路径，FileData 是数据库保存方式的数据，所以可以将以上的方法和按数据库存储的批量下载的方法合在一起写，核心的sql语句是：

```sql
select c.Sfzh, f.Path, f.FileData from clscs c
left join fileattachments f on c.CjdId = f.ID
where c.CjdId is not null
```

所以终极版，只需要一个方法，不需要分类是路径还是数据都可以全部下载下来：

```cs
private async Task<ActionResult> CreateZIPAsync(List<string> filePaths, List<byte[]> dataList, List<string> sfzhList, string suffix, string zipName)
{
    // 创建临时文件
    string tempFile = Path.GetTempFileName();
    using (Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
    {
        zip.UseZip64WhenSaving = Ionic.Zip.Zip64Option.Always;
        for (int i = 0; i < sfzhList.Count; i++)
        {
            string newFileName = sfzhList[i] + suffix;
            if (i < filePaths.Count && filePaths[i] != null)
            {
                // 只添加文件名，不添加路径
                zip.AddEntry(newFileName, System.IO.File.ReadAllBytes(filePaths[i]));
            }
            else if (i < dataList.Count && dataList[i] != null)
            {
                zip.AddEntry(newFileName, dataList[i]);
            }
        }

        await Task.Run(() => zip.Save(tempFile));
    }

    // 直接从文件系统中返回文件
    return new FileStreamResult(new FileStream(tempFile, FileMode.Open, FileAccess.Read), "application/zip")
    {
        FileDownloadName = zipName
    };
}
[ActionDescription("批量下载报名申请表")]
public async Task<ActionResult> BatchDownloadApplication(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的报名申请表数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.BmsqbId equals f.ID
        where c.BmsqbId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, f.Path, f.FileData };

    List<string> filePaths = new List<string>();
    List<byte[]> dataList = new List<byte[]>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        if (item.Path != null)
        {
            filePaths.Add(item.Path);
            dataList.Add(null);
        }
        else if (item.FileData != null)
        {
            dataList.Add(item.FileData);
            filePaths.Add(null);
        }
        sfzhList.Add(item.Sfzh);
    }

    return await CreateZIPAsync(filePaths, dataList, sfzhList, "_bmsqb.jpg", "报名申请表.zip");
}

[ActionDescription("批量下载复查申请表")]
public async Task<ActionResult> BatchDownloadReviewApplication(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的成绩单数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CjfcsqId equals f.ID
        where c.CjfcsqId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, f.Path, f.FileData };

    List<string> filePaths = new List<string>();
    List<byte[]> dataList = new List<byte[]>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        if (item.Path != null)
        {
            filePaths.Add(item.Path);
            dataList.Add(null);
        }
        else if (item.FileData != null)
        {
            dataList.Add(item.FileData);
            filePaths.Add(null);
        }
        sfzhList.Add(item.Sfzh);
    }

    return await CreateZIPAsync(filePaths, dataList, sfzhList, "_cjfcsqb.jpg", "复查申请表.zip");
}

[ActionDescription("批量下载承诺书")]
public async Task<ActionResult> BatchDownloadCommitment(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的承诺书数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CnsId equals f.ID
        where c.CnsId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, f.Path, f.FileData };

    List<string> filePaths = new List<string>();
    List<byte[]> dataList = new List<byte[]>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        if (item.Path != null)
        {
            filePaths.Add(item.Path);
            dataList.Add(null);
        }
        else if (item.FileData != null)
        {
            dataList.Add(item.FileData);
            filePaths.Add(null);
        }
        sfzhList.Add(item.Sfzh);
    }

    return await CreateZIPAsync(filePaths, dataList, sfzhList, "_cns.jpg", "承诺书.zip");
}

[ActionDescription("批量下载成绩单")]
public async Task<ActionResult> BatchDownloadScoreTable(string[] ids)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的成绩单数据
    var query = from c in DC.Set<Clsc>()
        join f in DC.Set<FileAttachment>() on c.CjdId equals f.ID
        where c.CjdId != null && ids.Contains(c.ID.ToString())
        select new { c.Sfzh, f.Path, f.FileData };

    List<string> filePaths = new List<string>();
    List<byte[]> dataList = new List<byte[]>();
    List<string> sfzhList = new List<string>();
    foreach (var item in query)
    {
        if (item.Path != null)
        {
            filePaths.Add(item.Path);
            dataList.Add(null);
        }
        else if (item.FileData != null)
        {
            dataList.Add(item.FileData);
            filePaths.Add(null);
        }
        sfzhList.Add(item.Sfzh);
    }

    return await CreateZIPAsync(filePaths, dataList, sfzhList, "_cjd.jpg", "成绩单.zip");
}
```

但是以上的代码还可以优化，因为每一个下载操作只有从数据库中获取数据时使用的字段不一样，大部分都是重复代码，所以可以提取为一个方法：

```cs
private async Task<ActionResult> CreateZIPAsync(List<string> filePaths, List<byte[]> dataList, List<string> sfzhList, string suffix, string zipName)
{
    // 创建临时文件
    string tempFile = Path.GetTempFileName();
    using (Ionic.Zip.ZipFile zip = new Ionic.Zip.ZipFile())
    {
        zip.UseZip64WhenSaving = Ionic.Zip.Zip64Option.Always;
        for (int i = 0; i < sfzhList.Count; i++)
        {
            string newFileName = sfzhList[i] + suffix;
            if (i < filePaths.Count && filePaths[i] != null)
            {
                // 只添加文件名，不添加路径
                zip.AddEntry(newFileName, System.IO.File.ReadAllBytes(filePaths[i]));
            }
            else if (i < dataList.Count && dataList[i] != null)
            {
                zip.AddEntry(newFileName, dataList[i]);
            }
        }

        await Task.Run(() => zip.Save(tempFile));
    }

    // 直接从文件系统中返回文件
    return new FileStreamResult(new FileStream(tempFile, FileMode.Open, FileAccess.Read), "application/zip")
    {
        FileDownloadName = zipName
    };
}

[ActionDescription("批量下载文件")]
public async Task<ActionResult> BatchDownloadFiles(string[] ids, Func<Clsc, Guid?> selector, string suffix, string zipName)
{
    if (ids.Length == 0)
        ids = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();

    // 获取所有的文件数据
    var fileIds = DC.Set<Clsc>().Where(c => ids.Contains(c.ID.ToString())).Select(selector).ToList();
    var fileAttachments = DC.Set<FileAttachment>().Where(f => fileIds.Contains(f.ID)).ToList();

    List<string> filePaths = new List<string>();
    List<byte[]> dataList = new List<byte[]>();
    List<string> sfzhList = new List<string>();
    foreach (var c in DC.Set<Clsc>().Where(c => ids.Contains(c.ID.ToString())))
    {
        var f = fileAttachments.FirstOrDefault(x => x.ID == selector(c));
        if (f != null)
        {
            if (f.Path != null)
            {
                filePaths.Add(f.Path);
                dataList.Add(null);
            }
            else if (f.FileData != null)
            {
                dataList.Add(f.FileData);
                filePaths.Add(null);
            }
            sfzhList.Add(c.Sfzh);
        }
    }

    return await CreateZIPAsync(filePaths, dataList, sfzhList, suffix, zipName);
}

[ActionDescription("批量下载报名申请表")]
public async Task<ActionResult> BatchDownloadApplication(string[] ids)
{
    return await BatchDownloadFiles(ids, c => c.BmsqbId, "_bmsqb.jpg", "报名申请表.zip");
}

[ActionDescription("批量下载复查申请表")]
public async Task<ActionResult> BatchDownloadReviewApplication(string[] ids)
{
    return await BatchDownloadFiles(ids, c => c.CjfcsqId, "_cjfcsqb.jpg", "复查申请表.zip");
}

[ActionDescription("批量下载承诺书")]
public async Task<ActionResult> BatchDownloadCommitment(string[] ids)
{
    return await BatchDownloadFiles(ids, c => c.CnsId, "_cns.jpg", "承诺书.zip");
}
[ActionDescription("批量下载成绩单")]
public async Task<ActionResult> BatchDownloadScoreTable(string[] ids)
{
    return await BatchDownloadFiles(ids, c => c.CjdId, "_cns.jpg", "成绩单.zip");
}
```

530m 的复查申请表：8s

824m 的承诺书：17s

5.1g 的成绩单：1m52s

6.5g 的报名申请表：2m33s

# 准考证下载

## 使用 FastReport

下载 FastReport.Net：https://www.fast-report.com/en/download/fast-report-net/，下载试用版:

![image-20240303141644092](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403031417494.png)

装好了后打开，选择 Design，进入设计页面：

![image-20240303194414820](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403031944994.png)

然后新建一个报表：

![image-20240303194516411](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403031945540.png)

选择一个空白报表：

![image-20240303194545970](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403031945037.png)

然后就可用创建报表中的内容：

![image-20240303194636586](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403031946717.png)

这个报表在保存的时候，会以 `.frx` 为后缀，在代码中需要使用到这个文件。

## 在代码中使用 FastReport

准考证的下载方法放在 \_DefaultController 中。

先在 VS 中，在包管理器中，安装三个包：

+ FastReport.Core
+ FastReport.Compat
+ Microsoft.CodeAnalysis.Commen 

先安装 FastReport.Core ，会报错，需要先安装 FastReport.Compat，然后也会报错，需要先安装 Microsoft.CodeAnalysis.Commen 。所以安装顺序是：Microsoft.CodeAnalysis.Commen --> FastReport.Compat  --> FastReport.Core

![image-20240303124341441](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403031245397.png)

然后使用 Report 类来操作一个报表：

```cs
public byte[] GeneratePdf()
{
    List<Ksqk> list = DC.Set<Ksqk>().Where(x => x.Sfzh == Wtm.LoginUserInfo.ITCode).ToList();

    string webRootPath = _hostingEnvironment.WebRootPath;
    Report report = new Report();
    report.Load(webRootPath + "/Admission.frx");
    report.RegisterData(list, "Ksqk");
    report.Prepare();
    PDFExport export = new PDFExport();
    MemoryStream stream = new MemoryStream();
    report.Export(export, stream);
    var t = stream.GetBuffer();
    stream.Close();
    report.Dispose();

    return t;
}
```

+ `Report report = new Report();` 创建一个报表对象
+ `report.Load(webRootPath + "/Admission.frx");` 加载一个报表文件
  + webRootPath ：这是项目的web根目录：wwwroot
+ `report.RegisterData(list, "Ksqk");` 注册数据源，就是指定报表中数据来源，一般是一个 List 集合，`"Ksqk"` 就是这个数据源的名字，在报表文件中就可以这样来使用数据：`[Ksqk.Xm]`。
+ `report.Prepare();` 准备报表的数据等

比如，在报表文件中这样使用：

![image-20240303195305753](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403031953850.png)

代码这样写：

```cs
public byte[] GeneratePdf()
{
    List<Ksqk> list = DC.Set<Ksqk>().Where(x => x.Sfzh == Wtm.LoginUserInfo.ITCode).ToList();

    string webRootPath = _hostingEnvironment.WebRootPath;
    Report report = new Report();
    report.Load(webRootPath + "/Admission.frx");
    report.RegisterData(list, "Ksqk");
    report.Prepare();
    PDFExport export = new PDFExport();
    MemoryStream stream = new MemoryStream();
    report.Export(export, stream);
    var t = stream.GetBuffer();
    stream.Close();
    report.Dispose();

    return t;
}

[HttpGet("/AdmissionDownload")]
public IActionResult AdmissionDownload()
{
    var pdf = GeneratePdf();

    Response.Headers.Add("Cache-Control", "max-age=31536000, must-revalidate");
    Response.Headers.Add("accept-ranges", "bytes");
    Response.Headers.Add("Access-Control-Expose-Headers", "Content-Disposition");
    return File(pdf, "application/pdf");
}
```

然后访问：http://localhost:25798/AdmissionDownload，就会看到：

![image-20240303195348019](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403031953152.png)

## 显示图片

先在 FastReportDesigner 中使用一个图片的组件：

![image-20240304151016576](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403041510693.png)

+ 要注意这个图片组件的名字，因为在代码中需要通过这个名字来获取到这个组件

然后要将图片数据（byte数组）绑定到这个组件上：在 GeneratePdf 方法中

```cs
// 获取图片数据
List<FileAttachment> imgs = DC.Set<FileAttachment>().Where(x => x.ID == list[0].ZkzpdfId).ToList();
List<byte[]> img = new List<byte[]>();
img.Add(imgs[0].FileData);

// 将数据注册到报表中
report.RegisterData(img, "Photo");

// 找到报表中的图片对象
PictureObject picture = report.FindObject("Picture2") as PictureObject;
if (picture != null)
{
    // 设置图片对象的数据源和数据列
    MemoryStream ms = new MemoryStream(img[0]);
    #pragma warning disable CA1416 // Validate platform compatibility
    Image returnImage = Image.FromStream(ms);
    #pragma warning restore CA1416 // Validate platform compatibility
    picture.Image = returnImage;
}
```

+ `#pragma warning disable CA1416` 这两句主要是为了消除以下这个警告：

  ![image-20240304151329701](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403041513777.png)

  不消除也没问题.

## 设置下载的准考证的名字

在 AdmissionDownload 方法中，通过设置响应头的方式来设置生成的 pdf 的名字：

```cs
// 设置文件名
var name = DC.Set<Ksqk>().Single(x => x.Sfzh == Wtm.LoginUserInfo.ITCode).Xm;
string fileName = "ZSBZKZ_" + name + ".pdf";

// 将文件名添加到 HTTP 响应标头
Response.Headers.Add("Content-Disposition", "inline; filename=" + fileName);
```

## 下载准考证总代码

```cs
[ActionDescription("生成准考证PDF")]
public byte[] GenerateAdmissionPDF()
{
    List<Ksqk> list = DC.Set<Ksqk>().Where(x => x.Sfzh == Wtm.LoginUserInfo.ITCode).ToList();
    List<FileAttachment> imgs = DC.Set<FileAttachment>().Where(x => x.ID == list[0].PhotoId).ToList();
    List<byte[]> img = new List<byte[]>();
    img.Add(imgs[0].FileData);

    string webRootPath = _hostingEnvironment.WebRootPath;

    Report report = new Report();
    report.Load(webRootPath + "/Admission.frx");

    report.RegisterData(list, "Ksqk");
    report.RegisterData(img, "Photo");

    // 找到报表中的图片对象
    PictureObject picture = report.FindObject("Picture2") as PictureObject;
    if (picture != null)
    {
        // 设置图片对象的数据源和数据列
        MemoryStream ms = new MemoryStream(img[0]);
        #pragma warning disable CA1416 // Validate platform compatibility
            Image returnImage = Image.FromStream(ms);
        #pragma warning restore CA1416 // Validate platform compatibility
            picture.Image = returnImage;
    }

    report.Prepare();
    PDFExport export = new PDFExport();
    MemoryStream stream = new MemoryStream();
    report.Export(export, stream);
    var t = stream.GetBuffer();
    stream.Close();
    report.Dispose();

    return t;
}

[HttpGet("/AdmissionDownload")]
[ActionDescription("下载准考证")]
public IActionResult AdmissionDownload()
{
    byte[] pdf = GenerateAdmissionPDF();

    Response.Headers.Add("Cache-Control", "max-age=31536000, must-revalidate");
    Response.Headers.Add("accept-ranges", "bytes");
    Response.Headers.Add("Access-Control-Expose-Headers", "Content-Disposition");

    // 设置文件名
    string fileName = "ZSBZKZ_" + Wtm.LoginUserInfo.ITCode + ".pdf";

    // 将文件名添加到 HTTP 响应标头
    Response.Headers.Add("Content-Disposition", "inline; filename=" + fileName);
    return File(pdf, "application/pdf");
}
```

## 修改准考证下载的页面

在 KsqkListVM1.cs 中，添加一个按钮：

```cs
protected override List<GridAction> InitGridAction()
{
    return new List<GridAction>
    {
        this.MakeAction(null, null,"下载准考证",null,GridActionParameterTypesEnum.NoId).SetShowInRow(true).SetHideOnToolBar(true).SetIconCls("fa fa-arrow-circle-down").SetButtonClass("layui-bg-blue").SetOnClickScript("admissionDownload"),
    };
}
```

这个按钮是调用自己写的 js 方法，所以在准考证下载的页面中，写一个 js 方法：

```html
<script>
	function admissionDownload() {
		// 阻止默认行为，以便手动处理页面跳转
		event.preventDefault();

		// 获取当前时间的时间戳
		var timestamp = new Date().getTime();

		window.open("/AdmissionDownload?t=" + timestamp, "_blank")
	}
</script>
```

+ 加上时间戳防止缓存

# 材料上传的资格审核状态

讲材料上传页面的批量修改改为全部修改，全部修改用户的资格审核状态。

先修改 ClscListVM 中的按钮，将 GridActionParameterTypesEnum.MultiIds 改为 GridActionParameterTypesEnum.MultiIdWithNull，因为这个参数会设置按钮有默认的验证：

```cs
this.MakeAction("Clsc","BatchEdit",Localizer["Sys.BatchEdit"].Value,Localizer["Sys.BatchEdit"].Value,GridActionParameterTypesEnum.MultiIdWithNull,"Data",800).SetShowInRow(false).SetHideOnToolBar(false).SetIconCls("fa fa-pencil-square"),
```

然后在 ClscController.cs 中，判断传过来的 id 数组是不是为空，是的话则从数据库中查到所有的 id，用于修改：

```cs
[ActionDescription("_Page.Data.Clsc.BatchEdit")]
[HttpPost]
public ActionResult BatchEdit(string[] IDs)
{
    if (IDs == null || IDs.Length == 0)
        IDs = DC.Set<Clsc>().Select(x => x.ID.ToString()).ToArray();
    var vm = Wtm.CreateVM<ZsbManagment.ViewModel.Data.ClscVMs.ClscBatchVM>(Ids: IDs);
    return PartialView(vm);
}
```

其他就不需要改了，如果选了数据修改，那么就会修改选中的数据；如果没有选择数据，则会修改全部。 

# 用户生成报名表

新加一个页面，供用户生成自己的报名申请表，为了预防出现学生来考试弄丢了报名表的情况。





# 添加准考证的字段

在考试情况表中添加字段，用于生成准考证。

需要添加或修改的字段：

+ 考点地址
+ 考试日期
+ 科目1考场号、科目2考场号、科目3考场号
+ 科目1座位号、科目2座位号、科目3座位号
+ 考生的个人照片

考生的个人照片字段不需要添加，可以直接修改原来的 pdf 字段即可。

在 Model/Data 下的 Ksqk.cs 中：

```cs
[Display(Name = "_Model._Ksqk._Zkzpdf")]
[Comment("考生照片")]
public FileAttachment Photo { get; set; }

[Display(Name = "_Model._Ksqk._Zkzpdf")]
[Comment("考生照片")]
public Guid? PhotoId { get; set; }

[Comment("考试地址")]
public string ExamLocation { get; set; }

[Comment("考试时间")]
public string ExamDate { get; set; }

[Comment("科目一考场号")]
public string Km1RoomNumber { get; set; }

[Comment("科目二考场号")]
public string Km2RoomNumber { get; set; }

[Comment("科目三考场号")]
public string Km3RoomNumber { get; set; }

[Comment("科目一座位号")]
public string Km1SeatNumber { get; set; }

[Comment("科目二座位号")]
public string Km2SeatNumber { get; set; }

[Comment("科目三座位号")]
public string Km3SeatNumber { get; set; }
```

对应的数据库中的表也要添加字段：

![image-20240307090102255](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403070901422.png)

 修改了 ZkzpdfId 为 PhotoId 后，需要将全文用到 ZkzpdfId 的地方都改为 PhotoId。

然后修改考试情况页面的显示，在详情页中显示出新添加的信息；在修改页面中显示出新添加的信息；在创建的页面中显示出新添加的信息。

字段添加完后，就需要修改生成准考证的代码，将准考证中的字段都来自于材料上传表。基本没有啥改的，就是将图片字段改了，然后需要改报表的模板文件 ：

![image-20240307094438700](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403070944850.png)

# 管理员下载对应的准考证

在考试情况表的页面中，每条数据后，添加一个按钮，这个按钮是供管理员下载对应用户的准考证的，防止学生考试准考证丢了，方便补。

在 KsqkListVM 中，添加按钮，这个按钮还是会调用一个接口：

```cs
this.MakeAction(null,null,"准考证",null,GridActionParameterTypesEnum.SingleId).SetShowDialog(true).SetIsRedirect(true).SetShowInRow(true).SetHideOnToolBar(true).SetIconCls("fa fa-arrow-circle-down").SetButtonClass("layui-bg-blue abtn").SetOnClickScript("downloadAdmissionBySfzh"),
```

然后在 Ksqk 下的 index.cshtml 中实现 downloadAdmissionBySfzh 函数：

```html
<script>
    function downloadAdmissionBySfzh(id) {
        // 阻止默认行为，以便手动处理页面跳转
        event.preventDefault();

        window.open("/DownloadAdmissionBySfzh?id=" + id, "_blank")
    }
</script>
```

+ 这个 id 是点击按钮时，传过来的当前行的数据的 id

然后在 KsqkController 中实现接口：

```cs
[ActionDescription("根据身份证号下载准考证")]
[HttpGet("DownloadAdmissionBySfzh")]
public IActionResult DownloadAdmissionBySfzh(string id)
{
var sfzh = DC.Set<Ksqk>().Where(x => x.ID.ToString() == id).Select(x => x.Sfzh).ToArray()[0];
    List<Ksqk> list = DC.Set<Ksqk>().Where(x => x.Sfzh == sfzh).ToList();
    if (list[0].PhotoId == null)
        return View(sfzh + " This user doesn't have a photo！");
    List<FileAttachment> imgs = DC.Set<FileAttachment>().Where(x => x.ID == list[0].PhotoId).ToList();
    List<byte[]> img = new List<byte[]>();
    // 可能是管理员手动上传图片的话，就是按路径存储的
    if (imgs[0].FileData == null)
    {
        string path = imgs[0].Path;

        // 检查路径是否存在
        if (System.IO.File.Exists(path))
        {
            // 读取文件的所有字节
            imgs[0].FileData = System.IO.File.ReadAllBytes(path);
        }
    }
    img.Add(imgs[0].FileData);

    string webRootPath = _hostingEnvironment.WebRootPath;

    Report report = new Report();
    report.Load(webRootPath + "/Admission.frx");

    report.RegisterData(list, "Ksqk");
    report.RegisterData(img, "Photo");

    // 找到报表中的图片对象
    PictureObject picture = report.FindObject("Picture2") as PictureObject;
    if (picture != null)
    {
    // 设置图片对象的数据源和数据列
    MemoryStream ms = new MemoryStream(img[0]);
    //#pragma warning disable CA1416 // Validate platform compatibility
    Image returnImage = Image.FromStream(ms);
    //#pragma warning restore CA1416 // Validate platform compatibility
    picture.Image = returnImage;
    }

    report.Prepare();
    PDFExport export = new PDFExport();
    MemoryStream stream = new MemoryStream();
    report.Export(export, stream);
    var t = stream.GetBuffer();
    stream.Close();
    report.Dispose();

    Response.Headers.Add("Cache-Control", "max-age=31536000, must-revalidate");
    Response.Headers.Add("accept-ranges", "bytes");
    Response.Headers.Add("Access-Control-Expose-Headers", "Content-Disposition");

    // 设置文件名
    var SFZH = DC.Set<Ksqk>().Single(x => x.Sfzh == sfzh).Sfzh;
    string fileName = "ZSBZKZ_" + SFZH + ".pdf";

    // 将文件名添加到 HTTP 响应标头
    Response.Headers.Add("Content-Disposition", "inline; filename=" + fileName);

    return File(t, "application/pdf");
}
```

+ 就是将默认控制器中的下载准考证的代码拷贝过来的，因为如果想调用默认控制器中的方法的话，需要创建默认控制器的对象，但是这个对象中的 DC 属性是 null。
+ 使用身份证号为 pdf 命名，不需要考虑中文问题，且不会重复。

# 导入学生照片

新建一个页面，用来导入一个 zip 压缩包文件，压缩包中包含所有学生的照片文件，每个文件以身份证号命名，后缀是 jpg。将这些照片保存到数据库中。并将照片信息插入到用户表、学生信息表、考试情况表。

+ 由于系统是采用 local 的方式上传图片，所以如果用户信息或者学生信息表中有图片字段，显示和下载的时候会以 local 的方式去找图片然后显示，也就是说会按照文件路径去找图片，但是实际上图片是存在数据库中的，所以不能正常的显示出来，所以只将图片信息关联到考试情况表中。

在 Areas/Data/Controller是、 下新建一个 ImportPhotosController：

```cs
namespace ZsbManagment.Areas.Data.Controllers
{
    public class ImportPhotosController : BaseController
    {
        [ActionDescription("导入学生照片页面", IsPage = true)]
        public ActionResult Index(string id)
        {
            return View("/Areas/Data/Views/ImportPhotos.cshtml");
        }

        private readonly string _tempFolder;

        public ImportPhotosController(IWebHostEnvironment env)
        {
            _tempFolder = Path.Combine(env.ContentRootPath, "temp");
            Directory.CreateDirectory(_tempFolder); // 确保临时文件夹存在
        }

        [ActionDescription("导入照片")]
        [HttpPost("/ImportPhoto/UploadChunk")]
        public async Task<IActionResult> UploadChunk(IFormFile fileChunk, string identifier, int chunkNumber, int totalChunks)
        {
            if (fileChunk == null || fileChunk.Length == 0)
            {
                return BadRequest("No file chunk uploaded.");
            }

            var tempChunkDir = Path.Combine(_tempFolder, identifier);
            Directory.CreateDirectory(tempChunkDir); // 确保临时文件夹存在

            var tempChunkPath = Path.Combine(tempChunkDir, chunkNumber.ToString().PadLeft(8, '0'));
            await using (var stream = new FileStream(tempChunkPath, FileMode.Create))
            {
                await fileChunk.CopyToAsync(stream);
            }

            return Ok(new { chunkNumber });
        }

        [HttpPost("/ImportPhoto/CompleteUpload")]
        public async Task<IActionResult> CompleteUpload(string identifier, string fileName)
        {
            var tempChunkDir = Path.Combine(_tempFolder, identifier);
            var combinedFilePath = Path.GetTempFileName();

            try
            {
                // 合并文件
                using (var outputStream = new FileStream(combinedFilePath, FileMode.Create))
                {
                    var chunkFiles = Directory.GetFiles(tempChunkDir).OrderBy(f => f).ToList();
                    foreach (var file in chunkFiles)
                    {
                        using (var inputStream = new FileStream(file, FileMode.Open))
                        {
                            await inputStream.CopyToAsync(outputStream);
                        }
                        System.IO.File.Delete(file); // 删除已经合并的分块
                    }
                }

                // 删除临时文件夹
                Directory.Delete(tempChunkDir, true); // 删除临时文件夹及其内容

                // 解压并处理ZIP文件
                int filesAdded = 0;
                using (var zip = new ZipArchive(new FileStream(combinedFilePath, FileMode.Open, FileAccess.Read), ZipArchiveMode.Read))
                {
                    foreach (var entry in zip.Entries)
                    {
                        // 计算文件存储路径
                        var entryPath = Path.Combine(_tempFolder, entry.FullName);
                        var directoryPath = Path.GetDirectoryName(entryPath);

                        // 只有当有确切的目录路径时，才确保目录存在
                        if (!string.IsNullOrEmpty(directoryPath) && !Directory.Exists(directoryPath))
                        {
                            Directory.CreateDirectory(directoryPath);
                        }

                        // 此处不再需要检查是否为目录，因为已经跳过了目录条目
                        using (var fileStream = new FileStream(entryPath, FileMode.Create))
                        using (var entryStream = entry.Open())
                        {
                            await entryStream.CopyToAsync(fileStream);
                        }

                        // 读取文件为byte[]，准备添加到数据库（如需要）
                        byte[] fileData = await System.IO.File.ReadAllBytesAsync(entryPath);

                        var attachment = new FileAttachment
                        {
                            ID = Guid.NewGuid(),
                            FileName = entry.Name,
                            FileExt = Path.GetExtension(entry.Name),
                            Length = entry.Length, // 注意：这里可能需要改为 fileData.Length，因为entry.Length在某些情况下可能不准确
                            UploadTime = DateTime.Now,
                            FileData = fileData
                        };
                        // 添加到数据库逻辑
                        var stuSfzh = attachment.FileName.Split(".")[0];

                        var stuKsqk = DC.Set<Ksqk>().SingleOrDefault(x => x.Sfzh == stuSfzh);
                        if (stuKsqk != null)
                            stuKsqk.PhotoId = attachment.ID;

                        //var stuUser = DC.Set<FrameworkUser>().SingleOrDefault(x => x.ITCode == stuSfzh);
                        //if (stuUser != null)
                        //    stuUser.PhotoId = attachment.ID;

                        //var stuInfo = DC.Set<StudentInfo>().SingleOrDefault(x => x.Sfzh == stuSfzh);
                        //if (stuInfo != null)
                        //    stuInfo.PhotoId = attachment.ID;
                        DC.Set<FileAttachment>().Add(attachment);

                        await DC.SaveChangesAsync();

                        filesAdded++;

                        // 删除解压后的文件（如果不再需要）
                        System.IO.File.Delete(entryPath);
                    }
                }

                return Ok(new { Count = filesAdded });
            }
            catch (Exception ex)
            {
                return StatusCode(500, $"Internal server error: {ex.Message}");
            }
            finally
            {
                if (System.IO.File.Exists(combinedFilePath))
                {
                    System.IO.File.Delete(combinedFilePath); // 确保无论如何都删除临时文件
                }
            }
        }

        private static IEnumerable<List<T>> Batch<T>(List<T> items, int batchSize)
        {
            for (int i = 0; i < items.Count; i += batchSize)
            {
                yield return items.GetRange(i, Math.Min(batchSize, items.Count - i));
            }
        }
    }
}
```

然后在 Areas/Data/Views 下新建一个页面文件 ImportPhotos.cshtml：

```cs
<title>导入学生照片</title>

<style>
    #fileInput {
        padding: 10px;
        margin: 10px;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
        color: #333;
        background-color: #f8f8f8;
        transition: all 0.3s ease;
    }

    #fileInput:hover {
        background-color: #e7e7e7;
    }

    #spinner {
        display: none; /* 默认隐藏加载图标 */
        font-size: 50px;
        position: fixed; /* 固定定位 */
        top: 50%; /* 居中显示 */
        left: 50%;
        transform: translate(-50%, -50%); /* 精确居中 */
        z-index: 9999; /* 确保在最顶层 */
    }

    .layui-icon-loading {
        -webkit-animation: rotating 1s linear infinite;
        -moz-animation: rotating 1s linear infinite;
        -o-animation: rotating 1s linear infinite;
        animation: rotating 1s linear infinite;
    }

    @@keyframes rotating {
        from {
            transform: rotate(0deg);
        }

        to {
            transform: rotate(360deg);
        }
    }
</style>

<div class="layui-container">
    <input type="file" id="fileInput" />
    <span id="spinner" class="layui-icon-loading"></span>
    <div id="progressContainer"></div>
</div>

<script>
    async function uploadChunk(fileChunk, identifier, chunkNumber, totalChunks) {
        const formData = new FormData();
        formData.append('fileChunk', fileChunk);
        formData.append('identifier', identifier);
        formData.append('chunkNumber', chunkNumber);
        formData.append('totalChunks', totalChunks);

        const response = await fetch('/ImportPhoto/UploadChunk', {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            throw new Error('Failed to upload file chunk.');
        }

        const data = await response.json();
        return data.chunkNumber;
    }

    async function completeUpload(identifier, fileName) {
        console.log("completeUpload start...")
        const formData = new FormData();
        formData.append('identifier', identifier);
        formData.append('fileName', fileName);

        const response = await fetch('/ImportPhoto/CompleteUpload', {
            method: 'POST',
            body: formData
        });

        if (!response.ok) {
            const error = await response.text();
            throw new Error(`Failed to complete upload: ${error}`);
        }

        const data = await response.json();
        return data.Count;
    }

    function convertMillisecondsToMinutesSeconds(milliseconds) {
        // 将毫秒转换为秒
        let totalSeconds = Math.floor(milliseconds / 1000);
        // 计算分钟数
        let minutes = Math.floor(totalSeconds / 60);
        // 计算剩余秒数
        let seconds = totalSeconds % 60;

        // 如果秒数小于10，则在前面添加一个零
        seconds = seconds < 10 ? "0" + seconds : seconds;

        return minutes + ":" + seconds;
    }

    const fileInput = document.getElementById('fileInput');
    fileInput.addEventListener('change', handleFileSelection);

    async function handleFileSelection(event) {
        const file = event.target.files[0];
        const chunkSize = 10 * 1024 * 1024; // 10MB chunk size
        const identifier = generateIdentifier(); // Unique identifier for the file
        const totalChunks = Math.ceil(file.size / chunkSize);

        const startTime = Date.now();
        document.getElementById('spinner').style.display = 'block'; // Show loading spinner

        for (let chunkNumber = 1; chunkNumber <= totalChunks; chunkNumber++) {
            const start = (chunkNumber - 1) * chunkSize;
            const end = chunkNumber * chunkSize;
            const chunk = file.slice(start, end);

            try {
                await uploadChunk(chunk, identifier, chunkNumber, totalChunks);
                console.log(`Uploaded chunk ${chunkNumber} of ${totalChunks}`);
            } catch (error) {
                console.error(`Failed to upload chunk ${chunkNumber}: ${error.message}`);
                document.getElementById('spinner').style.display = 'none'; // Hide loading spinner
                alert(`上传失败：${error.message}`); // 弹出错误信息
                return;
            }
        }

        try {
            const filesAdded = await completeUpload(identifier, file.name);
            console.log(`Completed upload. ${filesAdded} files added.`);
            const endTime = Date.now();
            let time = convertMillisecondsToMinutesSeconds(endTime - startTime);
            alert(`上传完成，总共添加了${filesAdded}个文件。共花费${time}时间`); // 弹出完成信息
        } catch (error) {
            console.error(`Failed to complete upload: ${error.message}`);
            alert(`完成上传时出错：${error.message}`); // 弹出完成时的错误信息
        } finally {
            document.getElementById('spinner').style.display = 'none'; // Hide loading spinner
        }
    }

    function generateIdentifier() {
        return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
            (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
        );
    }
</script>
```

代码都是由 AI 写写改改的，实现了大文件上传时，分块上传。

# 下载报名申请表

新建一个页面，用于让学生下载一个报名申请表的模板文件。

在 Areas/StudentQuery/Controllers 下新建一个 BmsqbPDFController：

```cs
namespace ZsbManagment.StudentQuery.Controllers
{
    [Area("StudentQuery")]
    [ActionDescription("生成报名表")]
    public partial class BmsqbPDFController : BaseController
    {
        // 获取网站的根目录
        private readonly IWebHostEnvironment _hostingEnvironment;
        public BmsqbPDFController(IWebHostEnvironment hostingEnvironment)
        {
            _hostingEnvironment = hostingEnvironment;
        }

        [ActionDescription("主页面", IsPage = true)]
        public ActionResult Index(string id)
        {
            return View("/Areas/StudentQuery/Views/_Default/Bmsqbxz.cshtml");
        }


        [ActionDescription("生成报名申请表PDF")]
        public byte[] GenerateBSQMBPdf()
        {
            List<Ksqk> list = DC.Set<Ksqk>().Where(x => x.Sfzh == Wtm.LoginUserInfo.ITCode).ToList();
            List<FileAttachment> imgs = DC.Set<FileAttachment>().Where(x => x.ID == list[0].PhotoId).ToList();
            List<byte[]> img = new List<byte[]>();
            img.Add(imgs[0].FileData);

            string webRootPath = _hostingEnvironment.WebRootPath;

            Report report = new Report();
            report.Load(webRootPath + "/Bmsqb.frx");

            report.RegisterData(list, "Xsxx");
            report.RegisterData(img, "Photo");

            // 找到报表中的图片对象
            PictureObject picture = report.FindObject("Picture1") as PictureObject;
            if (picture != null)
            {
                // 设置图片对象的数据源和数据列
                MemoryStream ms = new MemoryStream(img[0]);
                //#pragma warning disable CA1416 // Validate platform compatibility
                Image returnImage = Image.FromStream(ms);
                //#pragma warning restore CA1416 // Validate platform compatibility
                picture.Image = returnImage;
            }

            report.Prepare();
            PDFExport export = new PDFExport();
            MemoryStream stream = new MemoryStream();
            report.Export(export, stream);
            var t = stream.GetBuffer();
            stream.Close();
            report.Dispose();

            return t;
        }

        [ActionDescription("报名申请表下载")]
        [HttpGet("/BmsqbDownload")]
        public IActionResult BmsqbDownload()
        {
            var pdf = GenerateBSQMBPdf();

            Response.Headers.Add("Cache-Control", "max-age=31536000, must-revalidate");
            Response.Headers.Add("accept-ranges", "bytes");
            Response.Headers.Add("Access-Control-Expose-Headers", "Content-Disposition");

            // 设置文件名
            var SFZH = DC.Set<Ksqk>().Single(x => x.Sfzh == Wtm.LoginUserInfo.ITCode).Sfzh;
            string fileName = "ZSBBMSQB_" + SFZH + ".pdf";

            // 将文件名添加到 HTTP 响应标头
            Response.Headers.Add("Content-Disposition", "inline; filename=" + fileName);
            return File(pdf, "application/pdf");
        }
    }
}
```

+ 主要的代码和下载准考证的代码一样

然后写个前端页面：

```html
<div class="layui-container">
	<div id="g5205078925" style="font-size:20px;color:#0000FF;"> 报名表下载</div>
	<button id="bmsqbbtn" class="layui-btn layui-btn-fluid">下载</button>
</div>

<script>
	$("#bmsqbbtn").on("click", bmsqbDownload)
	function bmsqbDownload() {
		// 阻止默认行为，以便手动处理页面跳转
		event.preventDefault();

		// 获取当前时间的时间戳
		var timestamp = new Date().getTime();

		window.open("/BmsqbDownload?t=" + timestamp, "_blank")
	}
</script>
```

然后需要准备报表文件：

![image-20240308202950666](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403082029992.png)

下载时的效果：

![image-20240308203013336](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403082030504.png)

# 使用 pic2pic 压缩图片

pic2pic 软件的下载地址：https://www.updatestar.com/postdownload/pic2pic/243571

打开软件，如图：

![image-20240308203806911](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403082038072.png)

除了图中圈出来的信息，其他的可以不用修改。亲测将 6.5g 的压缩包缩小到了 2.3g。

然后将这 2.3g 的照片传上去：

![image-20240308204921579](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403082049710.png)

# 承诺书模板下载

在学生上传材料的页面，加一个下载承诺书的按钮。

新建一个承诺书的模板：

![image-20240314203021525](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403142030655.png)

然后在学生页面中的材料上传的页面中新建一个按钮：在 Areas/StudentQuery/Views/\_Default 下的 Xsclsc.cshtml 中：

```html
<div class="layui-row">
    <div class="layui-col" style="position: relative;">
        <img id="g8045229286" style="width:100px;" src="~/images/08db25d3-1d8a-4e8a-8189-2e0c84144f8c.jpg" />
        <button id="cnsbtn" class="layui-btn layui-btn-sm layui-border-blue layui-btn-primary" style="position: absolute; bottom: 0; margin-left:5px;">下载承诺书</button>
    </div>
</div>
<style>
    #cnsbtn:hover {
        background-color: lightblue;
    }
</style>
<script>
    $("#cnsbtn").on("click", cnsDownload)
    function cnsDownload() {
        // 阻止默认行为，以便手动处理页面跳转
        event.preventDefault();

        // 获取当前时间的时间戳
        var timestamp = new Date().getTime();

        window.open("/CnsDownload?t=" + timestamp, "_blank")
    }
</script>
```

然后实现接口，在 Areas/StudentQuery/Controllers 下的 \_DefaultController 中：

```cs
[ActionDescription("承诺书模板下载")]
[HttpGet("/CnsDownload")]
public IActionResult CnsDownload()
{
    var pdf = GenerateCNSPdf();
    if (pdf == null)
        return View("没有图片！");

    Response.Headers.Add("Cache-Control", "max-age=31536000, must-revalidate");
    Response.Headers.Add("accept-ranges", "bytes");
    Response.Headers.Add("Access-Control-Expose-Headers", "Content-Disposition");

    // 设置文件名
    string fileName = "ZSBCNS_" + Wtm.LoginUserInfo.ITCode + ".pdf";

    // 将文件名添加到 HTTP 响应标头
    Response.Headers.Add("Content-Disposition", "inline; filename=" + fileName);
    return File(pdf, "application/pdf");
}

[ActionDescription("生成承诺书模板表PDF")]
public byte[] GenerateCNSPdf()
{
    string webRootPath = _hostingEnvironment.WebRootPath;

    Report report = new Report();
    report.Load(webRootPath + "/Cns.frx");
    report.Prepare();
    PDFExport export = new PDFExport();
    MemoryStream stream = new MemoryStream();
    report.Export(export, stream);
    var t = stream.GetBuffer();
    stream.Close();
    report.Dispose();

    return t;
}
```

最终效果：

![image-20240314203328351](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403142033470.png)

# 成绩复核申请表模板下载

在学生页面的成绩复查申请页面中，提供一个按钮用于下载申请表的模板。

先创建一个模板报表：

![image-20240314203947409](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403142039521.png)

然后在 Areas/StudentQuery/Views/\_Default 下的 Cjfcsq.cshtml 中：

```html
<div id="g6543177844" style="font-size:20px;color:#0000FF;">如需申请复查考试成绩，请下载以下PDF模板，填写信息后上传，同时选择复查科目。</div>
<div class="layui-row">
    <div class="layui-col" style="position: relative;">
        <img id="g9163930160" style="width:200px;" src="~/images/08db25d2-d0c0-46b6-8b99-e61bd935c102.jpg" />
        <button id="cjfcsqbbtn" class="layui-btn layui-btn-sm layui-border-blue layui-btn-primary" style="position: absolute; bottom: 0; margin-left:5px;">下载申请表</button>
    </div>
</div>
<style>
    #cjfcsqbbtn:hover {
        background-color: lightblue;
    }
</style>
<script>
    $("#cjfcsqbbtn").on("click", cnsDownload)
    function cnsDownload() {
        // 阻止默认行为，以便手动处理页面跳转
        event.preventDefault();

        // 获取当前时间的时间戳
        var timestamp = new Date().getTime();

        window.open("/CjfcsqbDownload?t=" + timestamp, "_blank")
    }
</script>
```

再实现接口：在 Areas/StudentQuery/Controllers 下的 \_DefaultController 中：

```cs
[ActionDescription("成绩复查申请表模板下载")]
[HttpGet("/CnsDownload")]
public IActionResult CnsDownload()
{
    var pdf = GenerateCNSPdf();

    Response.Headers.Add("Cache-Control", "max-age=31536000, must-revalidate");
    Response.Headers.Add("accept-ranges", "bytes");
    Response.Headers.Add("Access-Control-Expose-Headers", "Content-Disposition");

    // 设置文件名
    string fileName = "ZSBCJFCSQB_" + Wtm.LoginUserInfo.ITCode + ".pdf";

    // 将文件名添加到 HTTP 响应标头
    Response.Headers.Add("Content-Disposition", "inline; filename=" + fileName);
    return File(pdf, "application/pdf");
}

[ActionDescription("成绩复查申请表模板表PDF")]
public byte[] GenerateCjfcsqbPdf()
{
    string webRootPath = _hostingEnvironment.WebRootPath;

    Report report = new Report();
    report.Load(webRootPath + "/Cjfcsqb.frx");
    report.Prepare();
    PDFExport export = new PDFExport();
    MemoryStream stream = new MemoryStream();
    report.Export(export, stream);
    var t = stream.GetBuffer();
    stream.Close();
    report.Dispose();

    return t;
}
```

最终效果：

![image-20240314204234552](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403142042666.png)

注意：在 StudentQuery 下的默认 Controller 中添加的方法都是在 “准考证下载” 中配置：

![image-20240314204540354](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403142045449.png)

# 合并两个方法

以上承诺书模板和成绩复核申请表的模板方法都是差不多，所以可以合并写：

```cs
[ActionDescription("PDF下载")]
[HttpGet("/PDFDownload")]
public IActionResult PDFDownload(string type)
{
    var pdf = GeneratePDF(type);

    Response.Headers.Add("Cache-Control", "max-age=31536000, must-revalidate");
    Response.Headers.Add("accept-ranges", "bytes");
    Response.Headers.Add("Access-Control-Expose-Headers", "Content-Disposition");

    // 设置文件名
    string fileName = "ZSB" + type + "_" + Wtm.LoginUserInfo.ITCode + ".pdf";

    // 将文件名添加到 HTTP 响应标头
    Response.Headers.Add("Content-Disposition", "inline; filename=" + fileName);
    return File(pdf, "application/pdf");
}

[ActionDescription("生成PDF")]
public byte[] GeneratePDF(string type)
{
    string webRootPath = _hostingEnvironment.WebRootPath;
    string frxName = "/Cns.frx";
    if (type == "CJFCSQB") frxName = "/Cjfcsqb.frx";

    Report report = new Report();
    report.Load(webRootPath + frxName);
    report.Prepare();
    PDFExport export = new PDFExport();
    MemoryStream stream = new MemoryStream();
    report.Export(export, stream);
    var t = stream.GetBuffer();
    stream.Close();
    report.Dispose();

    return t;
}
```

然后前端页面在调用的时候就多传一个参数过来就可以了：

```html
<script>
    $("#cnsbtn").on("click", cnsDownload)
    function cnsDownload() {
        // 阻止默认行为，以便手动处理页面跳转
        event.preventDefault();

        // 获取当前时间的时间戳
        var timestamp = new Date().getTime();

        window.open("/PDFDownload?type=CNS&t=" + timestamp, "_blank")
    }
</script>
```

## 主键冲突

如果这样改了代码的话，再去系统中的菜单管理中开启这个功能的话，可能会出现一个问题：

```html
System.InvalidOperationException: 'The instance of entity type 'FrameworkMenu' cannot be tracked because another instance with the same key value for {'ID'} is already being tracked. When attaching existing entities, ensure that only one entity instance with a given key value is attached. Consider using 'DbContextOptionsBuilder.EnableSensitiveDataLogging' to see the conflicting key values.'
```

这是因为之前的准考证下载的一个方法的名字叫做：GeneratePdf，这个方法名字会被存到数据库中去，但是 MySql 又不区分大小写，而新建的方法名叫做 GeneratePDF，所以就会被认为冲突，所以将准考证下载的方法名改掉即可：GenerateAdmissionPDF。

# 合并三个方法

也将默认控制器中的下载准考证的方法合并到一起：

```cs
[ActionDescription("PDF下载")]
[HttpGet("/PDFDownload")]
public IActionResult PDFDownload(string type)
{
    var pdf = GeneratePDF(type);

    Response.Headers.Add("Cache-Control", "max-age=31536000, must-revalidate");
    Response.Headers.Add("accept-ranges", "bytes");
    Response.Headers.Add("Access-Control-Expose-Headers", "Content-Disposition");

    // 设置文件名
    string fileName = "ZSB" + type + "_" + Wtm.LoginUserInfo.ITCode + ".pdf";

    // 将文件名添加到 HTTP 响应标头
    Response.Headers.Add("Content-Disposition", "inline; filename=" + fileName);
    return File(pdf, "application/pdf");
}

[ActionDescription("生成PDF")]
public byte[] GeneratePDF(string type)
{
    string webRootPath = _hostingEnvironment.WebRootPath;
    string frxName = "/Cns.frx";
    if (type == "CJFCSQB") frxName = "/Cjfcsqb.frx";
    if (type == "ZKZ") frxName = "/Admission.frx";

    Report report = new Report();
    report.Load(webRootPath + frxName);

    if (type == "ZKZ")
    {
        List<Ksqk> list = DC.Set<Ksqk>().Where(x => x.Sfzh == Wtm.LoginUserInfo.ITCode).ToList();
        List<FileAttachment> imgs = DC.Set<FileAttachment>().Where(x => x.ID == list[0].PhotoId).ToList();
        List<byte[]> img = new List<byte[]>();
        if (imgs[0].FileData == null)
        {
            string path = imgs[0].Path;

            // 检查路径是否存在
            if (System.IO.File.Exists(path))
            {
                // 读取文件的所有字节
                imgs[0].FileData = System.IO.File.ReadAllBytes(path);
            }
        }
        img.Add(imgs[0].FileData);
        report.RegisterData(list, "Ksqk");
        report.RegisterData(img, "Photo");
        // 找到报表中的图片对象
        PictureObject picture = report.FindObject("Picture2") as PictureObject;
        if (picture != null)
        {
            // 设置图片对象的数据源和数据列
            MemoryStream ms = new MemoryStream(img[0]);
            #pragma warning disable CA1416 // Validate platform compatibility
                Image returnImage = Image.FromStream(ms);
            #pragma warning restore CA1416 // Validate platform compatibility
                picture.Image = returnImage;
        }
    }

    report.Prepare();
    PDFExport export = new PDFExport();
    MemoryStream stream = new MemoryStream();
    report.Export(export, stream);
    var t = stream.GetBuffer();
    stream.Close();
    report.Dispose();

    return t;
}
```

然后在下载准考证的前端页面：

```html
<script>
	function admissionDownload() {
		// 阻止默认行为，以便手动处理页面跳转
		event.preventDefault();

		// 获取当前时间的时间戳
		var timestamp = new Date().getTime();

		window.open("/PDFDownload?type=ZKZ&t=" + timestamp, "_blank")
	}
</script>
```

# 修改考试情况表的导入模板

导入考试情况的信息时，需要将新加的几个字段一起导入。

在 KsqkImportVM 中，添加需要的字段即可：

```cs

[[Display(Name = "考试地址")]
public ExcelPropety ExamLocation = ExcelPropety.CreateProperty<Ksqk>(x => x.ExamLocation);
[Display(Name = "考试时间")]
public ExcelPropety ExamDate = ExcelPropety.CreateProperty<Ksqk>(x => x.ExamDate);
Display(Name = "科目1考场号")]
public ExcelPropety Km1RoomNumber = ExcelPropety.CreateProperty<Ksqk>(x => x.Km1RoomNumber);
[Display(Name = "科目2考场号")]
public ExcelPropety Km2RoomNumber = ExcelPropety.CreateProperty<Ksqk>(x => x.Km2RoomNumber);
[Display(Name = "科目3考场号")]
public ExcelPropety Km3RoomNumber = ExcelPropety.CreateProperty<Ksqk>(x => x.Km3RoomNumber);
[Display(Name = "科目1座位号")]
public ExcelPropety Km1SeatNumber = ExcelPropety.CreateProperty<Ksqk>(x => x.Km1SeatNumber);
[Display(Name = "科目2座位号")]
public ExcelPropety Km2SeatNumber = ExcelPropety.CreateProperty<Ksqk>(x => x.Km2SeatNumber);
[Display(Name = "科目3座位号")]
public ExcelPropety Km3SeatNumber = ExcelPropety.CreateProperty<Ksqk>(x => x.Km3SeatNumber);
```

# 导出材料上传表

在导出材料上传记录时，会将原来表中的承诺书等附件字段变为控件类型：

![image-20240328132550537](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403281325675.png)

修改这个问题，将每个附件字符的导出值改为 “已上传” 或 “未上传”。在 ClscListVM 中，根据 SearchMode 来区分不同的场景：

```cs
protected override IEnumerable<IGridColumn<Clsc_View>> InitGridHeader()
{
    // 导出时
    if (SearcherMode == ListVMSearchModeEnum.Export)
    {
        return new List<GridColumn<Clsc_View>>
        {
            this.MakeGridHeader(x => x.Clsc_Sfzh).SetTitle(Localizer["Page.身份证号"].Value).SetSort(true),
            this.MakeGridHeader(x => x.Clsc_Xm).SetTitle(Localizer["_Admin.Name"].Value).SetSort(true),
            this.MakeGridHeader(x => x.Clsc_Kslx).SetTitle(Localizer["Page.考生类型"].Value).SetSort(true),
            this.MakeGridHeader(x => x.Clsc_Byxx).SetTitle(Localizer["Page.毕业学校"].Value).SetSort(true),
            this.MakeGridHeader(x => x.Clsc_Bkzy).SetTitle(Localizer["Page.报考专业"].Value).SetSort(true),
            this.MakeGridHeader(x => x.Clsc_Zgshzt).SetTitle(Localizer["Page.资格审核状态"].Value).SetSort(true),
            this.MakeGridHeader(x => x.Clsc_Km1fc).SetTitle(Localizer["Page.科目一成绩复查"].Value).SetSort(true),
            this.MakeGridHeader(x => x.Clsc_Km2fc).SetTitle(Localizer["Page.科目二成绩复查"].Value).SetSort(true),
            this.MakeGridHeader(x => x.Clsc_Km3fc).SetTitle(Localizer["Page.科目三成绩复查"].Value).SetSort(true),
            this.MakeGridHeader(x => x.Clsc_Cjd).SetTitle(Localizer["Page.成绩单"].Value).SetSort(true).SetFormat(ExportFormat),
            this.MakeGridHeader(x => x.Clsc_Cns).SetTitle(Localizer["Page.承诺书"].Value).SetSort(true).SetFormat(ExportFormat),
            this.MakeGridHeader(x => x.Clsc_Cjfcsq).SetTitle(Localizer["Page.成绩复查申请"].Value).SetSort(true).SetFormat(ExportFormat),
            this.MakeGridHeader(x => x.Clsc_Bmsqb).SetTitle(Localizer["Page.报名申请表"].Value).SetSort(true).SetFormat(ExportFormat),
        };
    }
}
```

然后创建一个方法来根据附件是否上传决定对应的导出值：

```cs
// 导出时，记录材料是否上传
private string ExportFormat(Clsc_View entity, object val)
{
    return val == null ? "未上传" : "已上传";
}
```

![image-20240328132853724](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403281328814.png)

# 材料上传导入时更新

不知道为什么没有以更新的方式导入。

可以手动修改 ClscVM 中的 SetDuplicatedCheck 方法，该方法是用来检查重复字段的。
如果导入时根据 SetDuplicatedCheck 方法返回的字段或字段组合存在重复数据，框架默认会更新这条数据，可以通过设置 IsOverWriteExistData 属性禁止更新。当禁止更新的时候，重复数据会报错。

```cs
public override DuplicatedInfo<Clsc> SetDuplicatedCheck()
{
    var rv = CreateFieldsInfo(SimpleField(x => x.Sfzh));
    return rv;
}
```

+ 检查身份证号是否重复，以身份证号更新

# 导入时空白字段不更新

在导入信息时，只更新模板中有值的字段。

在导入考试信息时，在 ksqkImportVM 中，重写 BatchSaveData 方法，在这个方法里面遍历每一条要导入的数据，再遍历每条数据的所有为空的属性，将这些属性替换为原有数据的值。要求导入的数据一定要有身份证号：

```c#
public class KsqkImportVM : BaseImportVM<KsqkTemplateVM, Ksqk>
{
    //import
    public override bool BatchSaveData()
    {
        //获取excel中的数据并保存在EntityList中
        SetEntityList();
        int idx = 1;
        foreach (var item in EntityList)
        {
            idx++;
            // 没有身份证号的数据
            if (item.Sfzh == null || item.Sfzh == "")
            {
                ErrorListVM.EntityList.Add(new ErrorMessage { Message = "没有学生身份证号！", Index = idx });
                return false;
            }
            // 获取原先有的数据
            Ksqk oldEntity = DC.Set<Ksqk>().SingleOrDefault(x => x.Sfzh == item.Sfzh);
            // 说明第一次导入，直接跳过
            if (oldEntity == null)
            {
                continue;
            }
            // 获取所有属性
            Type type = item.GetType();
            var propertyInfos = type.GetProperties();
            // 遍历所有属性
            foreach (var p in propertyInfos)
            {
                // 只判断不为空的属性
                if (p.PropertyType == typeof(string) && (p.GetValue(item, null) == null || String.IsNullOrEmpty(p.GetValue(item, null).ToString()))) 
                    p.SetValue(item, p.GetValue(oldEntity));
            }

        }

        return base.BatchSaveData();
    }
}
```

材料上传的导入同样修改。

# 限制日志条数

日志管理中默认查询所有的日志，但是日志一旦过多后，系统查询就会很慢，所以没有必要将所有的日志信息查出来，可以设置只查询前 1000 条就可以了。

在 ActionLogListVM 中，使用 take() 方法：

```c#
public override IOrderedQueryable<ActionLog> GetSearchQuery()
{
    var query = DC.Set<ActionLog>()
        .CheckContain(Searcher.ITCode, x=>x.ITCode)
        .CheckContain(Searcher.ActionUrl, x=>x.ActionUrl)
        .CheckContain(Searcher.LogType, x=>x.LogType)
        .CheckContain(Searcher.IP, x=>x.IP)
        .CheckBetween(Searcher.ActionTime?.GetStartTime(), Searcher.ActionTime?.GetEndTime(), x=>x.ActionTime, includeMax:false)
        .CheckWhere(Searcher.Duration,x=>x.Duration >= Searcher.Duration)
        .OrderByDescending(x=>x.ActionTime)
        .Take(1000);

    return query;
}
```

# 细节修改

## 去除中英文切换

英文界面是这样的：

![image-20240304152320824](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403041523947.png)

在 Views/Home 的 Layout.cshtml 页面中，注释或删除以下代码即可：

```html
@*<li class="layui-nav-item" lay-unselect>
    <a href="javascript:;">
        <cite>@requestCulture.RequestCulture.UICulture.NativeName</cite>
    </a>
    <dl class="layui-nav-child">
        @foreach (var item in cultureItems)
        {
        <dd>
            <wt:linkbutton url="/_Framework/SetLanguage?culture=@item.Value" target=" ButtonTargetEnum.self" window-width="400" text="@item.Text" is-link="true" />
        </dd>
        }
    </dl>
</li>*@
```

## 去除头像显示

默认是有头像显示的，在右上角用户名处：

![image-20240310210720764](https://gitee.com/LowProfile666/image-bed/raw/master/img/202403102107849.png)

因为代码中是判断用户的 PhotoId 是否为空，而用户的 PhotoId 是在上传学生照片时赋值的，所以它会自动的去数据库中读取这个 id，然后去找图片，但是因为当前的文件存储方式是 local ，所以它会去找对应 id 的图片的路径，然后加载图片，但是用户的头像图片是保存在数据库中的，没有路径，所以就会出现找不到的情况。

所以干脆不显示头像。

在 Views/Home 下的 Layout.cshtml 页面中，注释掉以下代码：

```asp
<a href="javascript:;">
    @*@if (Model.LoginUserInfo?.PhotoId != null)
    {
    <img class="layui-nav-img" src="api/_file/getuserphoto/@Model.LoginUserInfo.PhotoId" />
    }*@
    <cite>@Model.LoginUserInfo.Name</cite>
</a>
```

## 登录页背景展示

![image-20240402111711053](C:/Users/20620/AppData/Roaming/Typora/typora-user-images/image-20240402111711053.png)

在 Views/Login 下的 Login.cshtml 中，在最顶上有一个随机数，这个随机数控制着背景：

```cs
@{
    Layout = null;
    int bgnumber = new Random().Next(1, 7);
}
```

这个随机数用在这：

```cs
 <div class="loginBody app-login-back-@bgnumber" style="flex: 1 1 auto !important; ">
```

将图片名字改为 banner1.jpg、banner2.jpg 等，放在 wwwroot/images 下，就可以了。

+ 好像只能放 6 张图片，多了不显示



# 2024.4.2

导入材料上传数据时，没有以更新的方式导入，而是追加了新的数据。

所以先将新数据以 xlsx 文件的格式通过 navicat 导入数据库中生成一张新的表 clsctemplatevm，然后通过两张表联合查询修改数据库中的数据：

```mysql
update zsbmanagment.clscs AS t1 set Zgshzt=(SELECT shzt from zsbmanagment.clsctemplatevm where sfzh=t1.Sfzh ) 

// UPDATE clscs c
// SET c.Zgshzt = cl.shzt
// INNER JOIN clsctemplatevm cl ON c.Sfzh = cl.sfzh;
```

## 安全更新模式

`SQL_SAFE_UPDATES` 是 MySQL 中的一个系统变量，用于控制是否允许执行不安全的 UPDATE 或 DELETE 语句。设置 `SQL_SAFE_UPDATES` 为 1 表示开启了安全更新模式，这样的话，UPDATE 或 DELETE 语句必须包含 WHERE 子句，以防止无意义或意外的数据更新或删除。如果执行的 UPDATE 或 DELETE 语句没有 WHERE 子句，或者 WHERE 子句不包含任何限制条件，将会被阻止执行，从而避免意外更新或删除整个表中的数据。

这个命令在 mysql 会话中使用，比如：

![image-20240402110258411](https://gitee.com/LowProfile666/image-bed/raw/master/img/202404021103553.png)

使用该命令后，再进行修改操作：

![image-20240402110326642](https://gitee.com/LowProfile666/image-bed/raw/master/img/202404021103743.png)

只能带 where 子句修改：

![image-20240402110624914](https://gitee.com/LowProfile666/image-bed/raw/master/img/202404021106011.png)

如果将安全更新模式关闭或者打开一个新的会话也可以直接修改，因为 `SQL_SAFE_UPDATES` 只影响当前会话。

![image-20240402110732110](https://gitee.com/LowProfile666/image-bed/raw/master/img/202404021107211.png)
